{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Conflux \u00b6 The Conflux Testnet is Live! We are excited to annouce the Conflux testnet release to provide developers and users the early access to our technology. Conflux is a next generation pow-based public blockchain system which can achieve throughput with thousands of transactions per second and transaction confirmation latency in minutes. The key that enables its such high performance is its novel consensus mechanism based on the Tree-Graph (TG) blockchain structure. In this testnet release, the main features include: The Tree-Graph based consensus mechanism The account state store with Merkle-Tree based authentication The Javascript and JsonRpc API for fullnode interaction Solidity compatible smart contract ConfluxScan - the block chain explorer A web-based Conflux wallet","title":"Welcome to Conflux"},{"location":"#welcome-to-conflux","text":"The Conflux Testnet is Live! We are excited to annouce the Conflux testnet release to provide developers and users the early access to our technology. Conflux is a next generation pow-based public blockchain system which can achieve throughput with thousands of transactions per second and transaction confirmation latency in minutes. The key that enables its such high performance is its novel consensus mechanism based on the Tree-Graph (TG) blockchain structure. In this testnet release, the main features include: The Tree-Graph based consensus mechanism The account state store with Merkle-Tree based authentication The Javascript and JsonRpc API for fullnode interaction Solidity compatible smart contract ConfluxScan - the block chain explorer A web-based Conflux wallet","title":"Welcome to Conflux"},{"location":"cli/","text":"Conflux CLI Sub-commands \u00b6 Conflux CLI sub-commands is a collection of command line interfaces which allows you to interact with a local or remote Conflux node. Manage Accounts \u00b6 account sub-command allows you to manage accounts at local machine. new \u00b6 Create a new account at local machine. Usage \u00b6 $ ./conflux.exe account new --help conflux.exe-account-new Create a new account (and its associated key) for the given --chain (default conflux). USAGE: conflux.exe account new [OPTIONS] FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --keys-iterations <NUM> Specify the number of iterations to use when deriving key from the password (bigger is more secure). [default: 10240] --password <FILE> Provide a file containing a password for unlocking an account. Leading and trailing whitespace is trimmed. Example \u00b6 ./conflux.exe account new list \u00b6 List all accounts at local machine. Usage \u00b6 $ ./conflux.exe account list --help conflux.exe-account-list List existing accounts of the given --chain (default conflux). USAGE: conflux.exe account list FLAGS: -h, --help Prints help information -V, --version Prints version information Example \u00b6 ./conflux.exe account list import \u00b6 Import accounts from JSON UTC keystore files. Usage \u00b6 $ ./conflux.exe account import --help conflux.exe-account-import Import accounts from JSON UTC keystore files to the specified --chain (default conflux) USAGE: conflux.exe account import --import-path <PATH>... FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --import-path <PATH>... A list of file paths to import. Example \u00b6 ./conflux.exe account import --import-path ./keystores Public APIs \u00b6 Public API allows you to interact with a local or remote Conflux node via HTTP connection in JSON-RPC protocol. All public APIs are under rpc sub-command, and access to the JSON-RPC API at local machine with default url option. OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] To access JSON-RPC API of remote Conflux node, please specify the correct --url option (e.g. http://10.1.5.6:12537). By default, JSON-RPC is enabled only for local access for security consideration. You can manually enable remote access by configuring jsonrpc_http_port in default.toml file. # jsonrpc_tcp_port=12536 jsonrpc_http_port=12537 # jsonrpc_local_tcp_port=12538 jsonrpc_local_http_port=12539 All available commands are as following: $ ./conflux.exe rpc --help conflux.exe-rpc RPC based subcommands to query blockchain information and send transactions USAGE: conflux.exe rpc [OPTIONS] <SUBCOMMAND> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] SUBCOMMANDS: balance Get balance of specified account best-block-hash Get the best block hash block-by-epoch Get block by epoch block-by-hash Get block by hash block-with-assumption Get block by hash with pivot chain assumption blocks Get blocks of specified epoch call Executes a new message call immediately without creating a transaction code Get bytecode of specified contract debug Debug subcommands (requires jsonrpc_local_http_port configured) epoch Get epoch number estimate-gas Executes a call request immediately without creating a transaction and returns the gas used help Prints this message or the help of the given subcommand(s) nonce Get nonce of specified account price Get recent mean gas price receipt Get receipt by transaction hash send Send a signed transaction and return its hash tx Get transaction by hash Get balance \u00b6 ./conflux.exe rpc balance --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a Get nonce \u00b6 ./conflux.exe rpc none --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a Get current epoch number \u00b6 ./conflux.exe rpc epoch Get block(s) \u00b6 Get Best block hash: ./conflux.exe rpc best-block-hash Get block by epoch: ./conflux.exe rpc block-by-epoch --epoch latest_state Get block by hash: ./conflux.exe rpc block-by-epoch --hash 0xf756b4...c0a6d1 Get blocks in epoch: ./conflux.exe rpc blocks --epoch latest_state Get transaction \u00b6 ./conflux.exe rpc tx --hash 0x718532fe76dbd8c4208c6c5a79588db35c0bf97e7d8a0faa5988ba66ad88b74c Get receipt \u00b6 ./conflux.exe rpc receipt --hash 0x718532fe76dbd8c4208c6c5a79588db35c0bf97e7d8a0faa5988ba66ad88b74c Send signed transaction \u00b6 Send a signed transaction which encoded in HEX format. Generally, this API is used for Java-Script API to send encoded transaction. To send a transaction with CLI, suggest to use private API send transaction . ./conflux.exe rpc send --raw-bytes 0x... Misc \u00b6 Get contract code: ./conflux.exe rpc code --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a Get recent mean gas price: ./conflux.exe rpc price Private APIs \u00b6 Private API allows you to interact with local Conflux node only via HTTP connection in JSON-RPC protocol. Private APIs are provided for user to manage the local Conflux node, and requires the jsonrpc_local_http_port configured in default.toml configuration file. In addition, private APIs also helps developers to debug, test, and monitor the runtime of Conflux node. All private APIs are under debug sub-command, and access to the JSON-RPC API at local machine with default url option. $ ./conflux.exe rpc debug --help conflux.exe-rpc-debug Debug subcommands (requires jsonrpc_local_http_port configured) USAGE: conflux.exe rpc debug [OPTIONS] <SUBCOMMAND> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] SUBCOMMANDS: consensus-graph-state Get the consensus graph state help Prints this message or the help of the given subcommand(s) net Network subcommands send Send a transaction and return its hash sync-phase Get the current synchronization phase test Test subcommands (used for test purpose only) txpool Transaction pool subcommands net \u00b6 net sub-command helps you to inspect the P2P network status. Examples \u00b6 List all connected P2P nodes: ./conflux.exe rpc debug net session List a single P2P node: ./conflux.exe rpc debug net session --id <node_id> Check network egress: ./conflux.exe rpc debug net throttling txpool \u00b6 txpool sub-command helps you to inspect the transaction pool. Examples \u00b6 List transaction pool status: ./conflux.exe rpc debug txpool status List transactions in details: ./conflux.exe rpc debug txpool content List summary of transactions: ./conflux.exe rpc debug txpool inspect Inspect a transaction in detail: ./conflux.exe rpc debug txpool inspect-one --hash <tx_hash> sync-phase \u00b6 Get the synchronization phase of local conflux node. ./conflux.exe rpc debug sync-phase Send transaction \u00b6 Send a transaction to local Conflux node. Usage \u00b6 $ ./conflux.exe rpc debug send --help conflux.exe-rpc-debug-send Send a transaction and return its hash USAGE: conflux.exe rpc debug send [OPTIONS] --from <ADDRESS> --password <STRING> --value <HEX> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --data <HEX> Hash of the method signature and encoded parameters --from <ADDRESS> Transaction from address --gas <HEX> Gas provided for transaction execution [default: 0x5208] --gas-price <HEX> Transaction gas price [default: 0x2540BE400] --nonce <HEX> Transaction nonce --password <STRING> Used to decrypt private key of sender to sign transaction --to <ADDRESS> Transaction to address (empty to create contract) --url <url> URL of RPC server [default: http://localhost:12537] --value <HEX> value sent with this transaction Example \u00b6 Alice transfer 5 Drip (1 CFX = 10^18 Drip) to Bob. Note, the address of Alice must exist at local machine, otherwise please create account for alice at first. ./conflux.exe rpc debug send --from <alice_address> --to <bob_address> --value 0x5 --password 123456 Alice create a contract with gas 3,000,000. You can use solc to compile contract to get the bytecodes. ./conflux.exe rpc debug send --from <alice_address> --value 0x0 --gas 0x\u202d2DC6C0\u202c --data <HEX_contract_bytecodes> --password 123456","title":"CLI Sub-commands"},{"location":"cli/#conflux-cli-sub-commands","text":"Conflux CLI sub-commands is a collection of command line interfaces which allows you to interact with a local or remote Conflux node.","title":"Conflux CLI Sub-commands"},{"location":"cli/#manage-accounts","text":"account sub-command allows you to manage accounts at local machine.","title":"Manage Accounts"},{"location":"cli/#new","text":"Create a new account at local machine.","title":"new"},{"location":"cli/#usage","text":"$ ./conflux.exe account new --help conflux.exe-account-new Create a new account (and its associated key) for the given --chain (default conflux). USAGE: conflux.exe account new [OPTIONS] FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --keys-iterations <NUM> Specify the number of iterations to use when deriving key from the password (bigger is more secure). [default: 10240] --password <FILE> Provide a file containing a password for unlocking an account. Leading and trailing whitespace is trimmed.","title":"Usage"},{"location":"cli/#example","text":"./conflux.exe account new","title":"Example"},{"location":"cli/#list","text":"List all accounts at local machine.","title":"list"},{"location":"cli/#usage_1","text":"$ ./conflux.exe account list --help conflux.exe-account-list List existing accounts of the given --chain (default conflux). USAGE: conflux.exe account list FLAGS: -h, --help Prints help information -V, --version Prints version information","title":"Usage"},{"location":"cli/#example_1","text":"./conflux.exe account list","title":"Example"},{"location":"cli/#import","text":"Import accounts from JSON UTC keystore files.","title":"import"},{"location":"cli/#usage_2","text":"$ ./conflux.exe account import --help conflux.exe-account-import Import accounts from JSON UTC keystore files to the specified --chain (default conflux) USAGE: conflux.exe account import --import-path <PATH>... FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --import-path <PATH>... A list of file paths to import.","title":"Usage"},{"location":"cli/#example_2","text":"./conflux.exe account import --import-path ./keystores","title":"Example"},{"location":"cli/#public-apis","text":"Public API allows you to interact with a local or remote Conflux node via HTTP connection in JSON-RPC protocol. All public APIs are under rpc sub-command, and access to the JSON-RPC API at local machine with default url option. OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] To access JSON-RPC API of remote Conflux node, please specify the correct --url option (e.g. http://10.1.5.6:12537). By default, JSON-RPC is enabled only for local access for security consideration. You can manually enable remote access by configuring jsonrpc_http_port in default.toml file. # jsonrpc_tcp_port=12536 jsonrpc_http_port=12537 # jsonrpc_local_tcp_port=12538 jsonrpc_local_http_port=12539 All available commands are as following: $ ./conflux.exe rpc --help conflux.exe-rpc RPC based subcommands to query blockchain information and send transactions USAGE: conflux.exe rpc [OPTIONS] <SUBCOMMAND> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] SUBCOMMANDS: balance Get balance of specified account best-block-hash Get the best block hash block-by-epoch Get block by epoch block-by-hash Get block by hash block-with-assumption Get block by hash with pivot chain assumption blocks Get blocks of specified epoch call Executes a new message call immediately without creating a transaction code Get bytecode of specified contract debug Debug subcommands (requires jsonrpc_local_http_port configured) epoch Get epoch number estimate-gas Executes a call request immediately without creating a transaction and returns the gas used help Prints this message or the help of the given subcommand(s) nonce Get nonce of specified account price Get recent mean gas price receipt Get receipt by transaction hash send Send a signed transaction and return its hash tx Get transaction by hash","title":"Public APIs"},{"location":"cli/#get-balance","text":"./conflux.exe rpc balance --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a","title":"Get balance"},{"location":"cli/#get-nonce","text":"./conflux.exe rpc none --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a","title":"Get nonce"},{"location":"cli/#get-current-epoch-number","text":"./conflux.exe rpc epoch","title":"Get current epoch number"},{"location":"cli/#get-blocks","text":"Get Best block hash: ./conflux.exe rpc best-block-hash Get block by epoch: ./conflux.exe rpc block-by-epoch --epoch latest_state Get block by hash: ./conflux.exe rpc block-by-epoch --hash 0xf756b4...c0a6d1 Get blocks in epoch: ./conflux.exe rpc blocks --epoch latest_state","title":"Get block(s)"},{"location":"cli/#get-transaction","text":"./conflux.exe rpc tx --hash 0x718532fe76dbd8c4208c6c5a79588db35c0bf97e7d8a0faa5988ba66ad88b74c","title":"Get transaction"},{"location":"cli/#get-receipt","text":"./conflux.exe rpc receipt --hash 0x718532fe76dbd8c4208c6c5a79588db35c0bf97e7d8a0faa5988ba66ad88b74c","title":"Get receipt"},{"location":"cli/#send-signed-transaction","text":"Send a signed transaction which encoded in HEX format. Generally, this API is used for Java-Script API to send encoded transaction. To send a transaction with CLI, suggest to use private API send transaction . ./conflux.exe rpc send --raw-bytes 0x...","title":"Send signed transaction"},{"location":"cli/#misc","text":"Get contract code: ./conflux.exe rpc code --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a Get recent mean gas price: ./conflux.exe rpc price","title":"Misc"},{"location":"cli/#private-apis","text":"Private API allows you to interact with local Conflux node only via HTTP connection in JSON-RPC protocol. Private APIs are provided for user to manage the local Conflux node, and requires the jsonrpc_local_http_port configured in default.toml configuration file. In addition, private APIs also helps developers to debug, test, and monitor the runtime of Conflux node. All private APIs are under debug sub-command, and access to the JSON-RPC API at local machine with default url option. $ ./conflux.exe rpc debug --help conflux.exe-rpc-debug Debug subcommands (requires jsonrpc_local_http_port configured) USAGE: conflux.exe rpc debug [OPTIONS] <SUBCOMMAND> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] SUBCOMMANDS: consensus-graph-state Get the consensus graph state help Prints this message or the help of the given subcommand(s) net Network subcommands send Send a transaction and return its hash sync-phase Get the current synchronization phase test Test subcommands (used for test purpose only) txpool Transaction pool subcommands","title":"Private APIs"},{"location":"cli/#net","text":"net sub-command helps you to inspect the P2P network status.","title":"net"},{"location":"cli/#examples","text":"List all connected P2P nodes: ./conflux.exe rpc debug net session List a single P2P node: ./conflux.exe rpc debug net session --id <node_id> Check network egress: ./conflux.exe rpc debug net throttling","title":"Examples"},{"location":"cli/#txpool","text":"txpool sub-command helps you to inspect the transaction pool.","title":"txpool"},{"location":"cli/#examples_1","text":"List transaction pool status: ./conflux.exe rpc debug txpool status List transactions in details: ./conflux.exe rpc debug txpool content List summary of transactions: ./conflux.exe rpc debug txpool inspect Inspect a transaction in detail: ./conflux.exe rpc debug txpool inspect-one --hash <tx_hash>","title":"Examples"},{"location":"cli/#sync-phase","text":"Get the synchronization phase of local conflux node. ./conflux.exe rpc debug sync-phase","title":"sync-phase"},{"location":"cli/#send-transaction","text":"Send a transaction to local Conflux node.","title":"Send transaction"},{"location":"cli/#usage_3","text":"$ ./conflux.exe rpc debug send --help conflux.exe-rpc-debug-send Send a transaction and return its hash USAGE: conflux.exe rpc debug send [OPTIONS] --from <ADDRESS> --password <STRING> --value <HEX> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --data <HEX> Hash of the method signature and encoded parameters --from <ADDRESS> Transaction from address --gas <HEX> Gas provided for transaction execution [default: 0x5208] --gas-price <HEX> Transaction gas price [default: 0x2540BE400] --nonce <HEX> Transaction nonce --password <STRING> Used to decrypt private key of sender to sign transaction --to <ADDRESS> Transaction to address (empty to create contract) --url <url> URL of RPC server [default: http://localhost:12537] --value <HEX> value sent with this transaction","title":"Usage"},{"location":"cli/#example_3","text":"Alice transfer 5 Drip (1 CFX = 10^18 Drip) to Bob. Note, the address of Alice must exist at local machine, otherwise please create account for alice at first. ./conflux.exe rpc debug send --from <alice_address> --to <bob_address> --value 0x5 --password 123456 Alice create a contract with gas 3,000,000. You can use solc to compile contract to get the bytecodes. ./conflux.exe rpc debug send --from <alice_address> --value 0x0 --gas 0x\u202d2DC6C0\u202c --data <HEX_contract_bytecodes> --password 123456","title":"Example"},{"location":"consensus/","text":"The Conflux Consensus Layer Design and Implementation \u00b6 The Conflux consensus layer processes all incoming blocks received from the synchronization layer, produces the total order of blocks based on the Conflux GHAST consensus algorithm, and invokes the underlying transaction execution engine to run transactions in the determined order. It provides necessary information to assist block generator to prepare the block skeleton of new blocks. It also notifies the transaction pool about processed transactions so that the pool can make better transaction selection decisions. This document is to provide a high-level overview for readers who want to understand the rust implementation of the Conflux consensus layer (in directory core/src/consensus). For more implementation details, see inlined comments in the code. For more information about the Conflux consensus algorithm, see XXX. Design Goals \u00b6 The consensus layer has the following design goals. Process new blocks in the background following the consensus algorithm consistently. We want to minimize the memory usage of each block in the consensus graph. Even with the checkpoint mechanism, the graph will contain 300K-500K blocks in normal case and more than 1M blocks when facing liveness attacks. This may stress the memory. We want to process each block fast. Because full/archive nodes have to process every block from the original genesis when they catch up with the network from scratch, fast block process is important to keep the catch up period short. Robust against potential attacks. Malicious attackers may generate bad blocks at arbitrary position in the tree graph. Structures and Components \u00b6 ConsensusGraph \u00b6 ConsensusGraph (core/src/consensus/mod.rs) is the main struct of the consensus layer. The synchronization layer construct ConsensusGraph with a BlockDataManager which stores all block metadata information in disk. ConsensusGraph::on_new_block() is the key function to send new blocks to the ConsensusGraph struct to process. It also provides a set of public functions to query the status of blocks/transactions. This should be the main interface which other components interact. ConsensusGraphInner \u00b6 ConsensusGraphInner (core/src/consensus/consensus_inner/mod.rs) is the inner structure of ConsensusGraph . ConsensusGraph::on_new_block() acquires the write lock of the inner struct at the start of the function. For the rest of query functions, they only acquire read lock. The internal structure of ConsensusGraphInner is fairly complicated. Generally speaking, it maintains two kinds of information. The first kind of information is the state of the whole tree graph, i.e., the current pivot chain , timer chain , difficulty , etc.. The second kind of information is the state of each block (i.e., ConsensusGraphNode struct for each block). Each block corresponds to a ConsensusGraphNode struct for its information. When it first enters ConsensusGraphInner , it will be inserted into ConsensusGraphInner::arena : Slab<ConsensusGraphNode> . The index in the slab will become the arena index of the block in ConsensusGraphInner . We use the arena index to represent a block internally instead of H256 because it is much cheaper. We will refer back to the fields in ConsensusGraphInner and ConsensusGraphNode when we talk about algorithm mechanism and their implementations. ConsensusNewBlockHandler \u00b6 ConsensusNewBlockHandler (core/src/consensus/consensus_inner/consensus_new_block_handler.rs) contains a set of routines for processing a new block. In theory, this code could be part of ConsensusGraphInner because it mostly manipulates the inner struct. However, these routines are all subroutine of the on_new_block() and the consensus_inner/mod.rs is already very complicated. We therefore decide to put them into a separate file. ConsensusExecutor \u00b6 ConsensusExecutor (core/src/consensus/consensus_inner/consensus_executor.rs) is the interface struct for the standalone transaction execution thread. ConsensusExecutor::enqueue_epoch() allow other struct to send an execution task to execute the epoch of a given pivot chain block asynchronously. Once the computation finishes, the result stateroot will be stored into BlockDataManager . Other threads can call ConsensusExecutor::wait_for_result() to wait for the execution of an epoch if desired. In the current implementation, ConsensusExecutor also contains the routines for the calculation for block rewards, including get_reward_execution_info() and its subroutines. ConfirmationMeter \u00b6 ConfirmationMeter (core/src/consensus/consensus_inner/confirmation_meter.rs) conservatively calculates the confirmation risk of each pivot chain block. Its result will be useful for the storage layer to determine when it is safe to discard old snapshots. It also can be used to serve RPC queries about block confirmation if we decide to provide such RPC. AnticoneCache and PastsetCache \u00b6 AnticoneCache (core/src/consensus/anticone_cache.rs) and PastsetCache (core/src/consensus/pastset_cache.rs) are two structs that implement customized cache for data structures in ConsensusGraphInner . In the implementation of the inner struct, we need to calculate and store the anticone set and the past set of each block. However, it is not possible to store all of these sets in memory. We therefore implement cache style data structures to store sets for recently inserted/accessed blocks. If a anticone/past set is not found in the cache, we will recalculate the set in the current inner struct implementation. Important Algorithmic Mechanisms \u00b6 There are several important algorithmic mechanisms in the Conflux Consensus Layer. Here we will talk about them from the implementation aspect. See XXX for the algorithmic reasoning behind them. Pivot Chain and Total Order \u00b6 The basic idea of the Conflux consensus algorithm is to first make everyone agree on a pivot chain. It then expands the total order from the pivot chain to cover all blocks with a topological sort. As long as the pivot chain does not change/reorg, the total order of blocks will stay the same, so does the derived order of transactions. Comparing with Bitcoin/Ethereum, the consensus in Conflux has two key differences: almost every block will go into the total order, not just the agreed pivot chain. The transaction validity and the block validity are independent . A transaction is invalid if it was included before or it cannot carry out due to insufficient balance. Such invalid transaction will become noop during the execution. However, unlike Bitcoin and Ethereum blocks containing such transactions will not become invalid . In ConsensusGraphInner , the arena index of the current pivot chain blocks are stored in order in the pivot_chain[] vector. To maintain it, we calculate the least common ancestor (LCA) between the new inserted block and the current best block following the GHAST rule. If the fork corresponding to the new inserted block for the LCA ended up to be heavier. We will update the pivot_chain[] from the forked point. Timer Chain \u00b6 Blocks whose PoW quality is timer_chain_difficulty_ratio times higher than the supposed difficulty are timer blocks . The is_timer field of the block will be set to True. The consensus algorithm then finds the longest timer block chain (more accurately, with heaviest accumulated difficulties) similar to the Bitcoin consensus algorithm of finding the longest chain. The arena index of this longest timer chain will be stored into timer_chain[] . The rationale of the timer chain is to provide a coarse grained measurement of the time that cannot be influenced by malicious attacker. Because timer blocks are rare and generated slowly (if timer_chain_difficulty_ratio is properly high), malicious attacker cannot prevent the growth of the timer chain unless it has the majority of the computation power. Therefore how many timer chain blocks appear in the past set of a block is a good indication about the latest possible generation time of the block. We compute this value for each block and store it in timer_chain_height field of the block. Weight Maintenance with Link-Cut Tree \u00b6 To effectively maintain the pivot chain, we need to query the total weight of a subtree. Conflux uses a Link-Cut Tree data structure to maintain the subtree weights in O(log n). Link-Cut Tree can also calculates the LCA of any two nodes in the TreeGraph in O(log n). The weight_tree field in ConsensusGraphInner is the link-cut tree that stores the subtree weight of every node. Note that the implementation of the Link-Cut Tree is in the utils/link-cut-tree directory. Adaptive Weight \u00b6 If the TreeGraph is under a liveness attack, it may fail to converge under one block for a while. To handle this situation, the GHAST algorithm idea is to start generate adaptive blocks, i.e., blocks whose weights are redistributed significantly so that there will be many zero weight blocks with a rare set of very heavy blocks. Specifically, if the PoW quality of an adaptive block is adaptive_heavy_block_ratio higher than the supposed difficulty, the block will have the weight of adaptive_heavy_block_ratio . Otherwise, the block will have the weight of zero. This effectively slows down the confirmation temporarily but will ensure the consensus progress. Because adaptive weight is a mechanism to defend against rare liveness attacks, it should not be turned on during the normal scenario. A new block is adaptive only if 1) one of its ancestor block is still not the dominant subtree comparing to its siblings and 2) a significantly long period of time has past between the generation of the ancestor block and the new block (i.e., the difference of timer_chain_height ). ConsensusGraphInner::adaptive_weight() and its subroutines implement the algorithm to determine whether a block is adaptive or not. Note that the implementation uses another link-cut-tree adaptive_tree as a helper. Please see the inlined comments for the implementation details. Partial Invalid \u00b6 Note that the past set of a new block denotes all the blocks that the generator of the new block observes at the generation time. Therefore, from the past set of a new block, other full nodes could determine whether it chooses the correct parent block and whether it should be adaptive or not. The Conflux consensus algorithm defines those blocks who choose incorrect parents or fill in incorrect adaptive status as partial invalid blocks. For a partial invalid block, the partial_invalid field will be set to True. The algorithm requires the partial invalid blocks being treated differently from the normal blocks in three ways: All honest nodes will not reference directly or indirectly partial invalid blocks until a significant period of time. This time period is measured with the timer_chain_height and the difference has to be more than timer_chain_beta . Yes, it means that if another otherwise perfectly fine block referencing the partial invalid block, both of these two blocks will not be referenced for a while. Partial invalid blocks will have no block reward. They are extremely unlikely to get any reward anyway because of their large anticone set due to the first rule. Partial invalid blocks are excluded from the timer chain consideration. To implement the first rule, the on_new_block() routine in ConsensusNewBlockHandler is separated into two subroutine preactivate_block() and activate_block() . preactivate_block() compute and determine whether a block is partial invalid or not, while activate_block() fully integrate a block into the consensus graph inner data structures. For every new block, the field active_cnt tracks how many inactive blocks it references. A block is inactive if it references directly or indirectly a partial invalid block. activate_block() will be called on a block only when active_cnt of the block becomes zero. The field activated denotes whether a block is active or not. For partially invalid blocks, their activation will be delayed till the current timer chain height of the ledger is timer_chain_beta higher than the invalid block. New generated blocks will not reference any inactive blocks, i.e., these inactive blocks are treated as if they are not in the TreeGraph. Anticone, Past View, and Ledger View \u00b6 In order to check the partial invalid status of each block, we need to operate under the past view of the block to determine its correct parent and its adaptivity. This is different from the current state of the TreeGraph or we call it the ledger view , i.e., all blocks in the anticone and the future set of the block are excluded. Because we process blocks in topological order, the future set of a new block is empty. We therefore need to eliminate all anticone blocks only. compute_and_update_anticone() in ConsensusNewBlockHandler computes the anticone set of a new block. Note that because the anticone set may be very large, we have two implementation level optimizations. First, we represent the anticone set as a set of barrier nodes in the TreeGraph, i.e., a set of subtrees where each block in the subtrees is in the anticone set. Second, we will only maintain the anticone set of the recently accessed/inserted blocks only. When checking whether a block is valid in its past view or not (e.g., in adaptive_weight() and in check_correct_parent() ), we first cut all barrier subtrees from the link-cut weight trees accordingly to get the state of the past view. After the computation, we restore these anticone subtrees back. Check Correct Parent \u00b6 To check whether a new block chooses a correct parent block or not, we first compute the set of blocks inside the epoch of the new block as if the new block is on the pivot chain. We store this set to the field blockset_in_own_view_of_epoch . We then iterate over every candidate block in this set to make sure that the chosen parent block is better than it. Specifically, we find out the two fork blocks of the candidate block and the parent block from their LCA and make sure that the fork of the parent is heavier. This logic is implemented in check_correct_parent() in ConsensusNewBlockHandler . Note that blockset_in_own_view_of_epoch may become too large to hold consistently in memory as well. Especially if a malicious attacker tries to generate invalid blocks to blow up this set. The current implementation will only periodically clear the set and only keep the sets for pivot chain blocks. Note that for pivot chain blocks, this set will also be used during the transaction execution. Fallback Brute Force Methods \u00b6 There are situations where the anticone barrier set is too large if a malicious attacker tries to launch a performance attack on Conflux. This will make the default strategy worse than O(n) because there is a factor of O(log n) for each block in the barrier set when we do the link-cut tree chopping. To this end, we implemented a brute force routine compute_subtree_weights() to compute the subtree weights of each block in a past view for O(n). We also implement check_correct_parent_brutal() and adaptive_weight_impl_brutal() to use the brute-forcely computed subtree weight to do the checking instead. Force Confirmation \u00b6 The Conflux consensus algorithm will force confirm a block if 1) there are timer_chain_beta consecutive timer chain blocks under the subtree of the block and 2) afterward there are at least timer_chain_beta timer chain blocks following (not required in the subtree though). Force confirmation means that new blocks should follow this block as their ancestor no matter what, ignoring subtree weights. Though extremely unlikely a force confirmed block will have lesser weights than its siblings. The force confirmation mechanism is to enable checkpoint, which we will describe later. It is based on the rationale that: Reverting a timer_chain_beta length timer chain is impossible. Therefore force confirmed block will always move along the pivot chain, not drifting between its siblings. We compute the accumulative LCA of the last timer_chain_beta timer chain blocks and store it at the timer_chain_accumulative_lca[] field. This vector is timer_chain_beta shorter than timer_chain[] because the force confirm needs at least timer_chain_beta timer chain block trailing, so their LCAs do not matter. check_correct_parent() and adaptive_weight() and their subroutines also respect this force confirm point during their checking. Specifically, any fork before the force confirm height is ignored. Note that this force confirm rule is also defined based on past view of each block. With the computed anticone information, compute_timer_chain_tuple() in ConsensusGraphInner computes the timer chain related information of each block under its past view. The results of this function is the difference of the timer_chain[] , timer_chain_accumulative_lca[] , and timer_chain_height between the ledger view and the past view. We can use the diff and the current ledger view values to get the past view values. Era \u00b6 In order to implement checkpoint, the Conflux consensus algorithm split the graph in eras. Every era contains era_epoch_count epochs. For example, if the era_epoch_count is 50000, then there is a new era every 50000 epochs. The pivot chain block at the height 50000 will be the genesis of a new era. At the era boundary, there are several differences from the normal case. A block will enter the total order for execution only if 1) it is under the subtree of the previous era and 2) it is inside the past set of the next era in the pivot chain. Anticone penalty calculation for the block reward does not go over the era boundary. Checkpoint \u00b6 Inside ConsensusGraphInner , there are two key height pointers, the current checkpoint era genesis block height ( cur_era_genesis_height ) and the current stable era block height ( cur_era_stable_height ). These two height pointers will always point to some era genesis (being a multiple of era_epoch_count ). Initially, both of these two pointers will point to the true genesis (height 0). A new era genesis block become stable (i.e., cur_era_stable_height moves) if the block is force confirmed in the current TreeGraph. A new era genesis block become a new checkpoint (i.e., cur_era_genesis_height moves) if: The block is force confirmed in the past view of the stable genesis block . In the anticone of this block, there is no timer chain block. should_move_stable_height() and should_form_checkpoint_at() in ConsensusNewBlockHandler are invoked after every new inserted block to test the above two conditions. Generally speaking, the stable block will never be reverted off the pivot chain. Any block in the past set of the checkpoint block is no longer required for the future computation of the consensus layer. Therefore, after a new checkpoint is formed, make_checkpoint_at() in ConsensusNewBlockHandler is called to clean up those blocks that are not in the future set of the new checkpoint. Note that the checkpoint mechanism also changes how we handle a new block. For a new block: If the new block is outside the subtree of the current checkpoint. We only need to insert a stub into our data structure (because two blocks under the subtree may indirectly reference each other via this block). We do not need to care about this block because it is not going to change the timer chain and it is not going to be executed. If the past set of the new block does not contain the stable era block, we do not need to check the partial invalid status of this block. This is because this block will not change the timer chain (note our assumption that timer chain will not reorg more than timer_chain_beta ) and new blocks can reference this block directly (more than tiemr_chain_beta difference). Deferred Execution \u00b6 Because the TreeGraph pivot chain may oscillate temporarily, we defer the transaction execution for DEFERRED_STATE_EPOCH_COUNT epochs (default 5). After a pivot chain update, activate_block() routine will enqueue the execution task of the new pivot chain except the last five epochs. It calls enqueue_epoch() in ConsensusExecutor to enqueue each task. Block Reward Calculation \u00b6 Because there is no explicit coinbase transaction in Conflux, all block rewards are computed implicitly during the transaction execution. In Conflux, the block reward is by the base reward and the penalty ratio based on the total weight of its anticone blocks dividing its own difficulty. This anticone set only considers blocks appearing within the next REWARD_EPOCH_COUNT epochs. Specially, if there is a new era then this anticone set will not count across the era boundary as well. get_pivot_reward_index() in ConsensusExecutor counts this reward anticone threshold. get_reward_execution_info_from_index() in ConsensusExecutor and its subroutines compute this anticone set given the threshold point in the pivot chain. Blame Mechanism \u00b6 It is not feasible to validate the filled state root of a block because we would need to execute all transactions in a different order in the past view of that block. Instead, we will only ask the full nodes to validate the state root results on the current pivot chain. It then fills a blame number to indicate how many levels ancestors from the parent who do not have correct state root. When this number is greater than zero, the filled deferred state root because a Merkel H256 vector that contains the corrected state roots of the ancestors along with the correct one. get_blame_and_deferred_state_for_generation() in ConsensusGraph computes the blame information for the block generation. first_trusted_header_starting_from() is ConsensusGraph is a useful helper function to compute the first trust worthy header that based the subtree blame information. Multi-Thread Design \u00b6 The consensus layer has one thread dedicated to process new blocks from the synchronization layer and one thread dedicated to execute transaction. It of course also has a set of interface APIs that RPC threads and synchronization threads may call. Consensus Worker \u00b6 Consensus Worker is a thread created by the synchronization layer. During the normal running phase, every new block will be sent to a channel connecting the synchronization thread and the consensus worker thread. The consensus work thread consumes each block one by one and invokes consensus::on_new_block() to process it. Note that the synchronization layer ensures the new block to be header-ready when it is delivered to Consensus Worker , i.e., all of its ancestor/past blocks are already delivered to the consensus before it is delivered. This enables the consensus layer to always deal with a complete direct acyclic graph without holes. One advantage of having a single thread to be dedicated on the consensus protocol is that it simplifies the protocol implementation a lot. Because the detail of the consensus protocol is complicated and the implementation involves many sophisticated data structure manipulations, the single thread design makes sure that we do not need to worry about deadlocks or races. Upon the entrance of consensus::on_new_block() , the thread acquires the write lock of the inner of the consensus struct (i.e., ConsensusGraphInner). During the normal phase, this thread should be the only one modifying the inner struct of the consensus layer. Consensus Execution Worker \u00b6 Consensus Execution Worker is a thread created at the start of the consensus layer. It is dedicated to transaction execution. There is a channel connecting Consensus Worker with Consensus Execution Worker . Once the consensus protocol determines the order of the pivot chain, it will send ExecutionTask for each epoch in the pivot chain to the channel. These tasks will be pick up by the Consensus Execution Worker thread one by one. The thread loads the previous state before the executed epoch from the storage layer as the input, runs all transactions in the executed epoch (see ConsensusExecutor::process_epoch_transactions() ), and produces the result state as the output. The rationale of separating the transaction execution from the consensus protocol implementation is for performance. With our blaming mechanism , the execution result state is completely separated from the consensus protocol implementation. The deferred execution mechanism gives us extra room to pipeline the consensus protocol and the transaction execution. It is therefore not wise to block the ConsensusWorker thread to wait for the execution results from coming back. Key Assumptions, Invariants, and Rules \u00b6 If you want to write code to interact with the Conflux consensus layer. It is very important to understand the following assumptions and rules. The consensus layer assumes that the passed BlockDataManager is in a consistent state. It means that the BlockDataManager contains correct current checkpoint/stable height. Blocks before the checkpoint and the stable height are properly checked during previous execution and they are persisted into the BlockDataManager properly. The consensus layer does not check the results it fetches from the block data manager. If it is inconsistent, the consensus layer will execute incorrectly or crash! Besides the subroutines of on_new_block() , no one should hold the write lock of the inner struct ! Right now the only exception for this rule is assemble_new_block_impl() because of computing the adaptive field and this is not good we plan to change it. Acquiring the write lock of the inner struct will very likely to cause deadlock given the complexity of the Consensus layer and its dependency with many other components. Always try to avoid this!","title":"The Conflux Consensus Layer Design and Implementation"},{"location":"consensus/#the-conflux-consensus-layer-design-and-implementation","text":"The Conflux consensus layer processes all incoming blocks received from the synchronization layer, produces the total order of blocks based on the Conflux GHAST consensus algorithm, and invokes the underlying transaction execution engine to run transactions in the determined order. It provides necessary information to assist block generator to prepare the block skeleton of new blocks. It also notifies the transaction pool about processed transactions so that the pool can make better transaction selection decisions. This document is to provide a high-level overview for readers who want to understand the rust implementation of the Conflux consensus layer (in directory core/src/consensus). For more implementation details, see inlined comments in the code. For more information about the Conflux consensus algorithm, see XXX.","title":"The Conflux Consensus Layer Design and Implementation"},{"location":"consensus/#design-goals","text":"The consensus layer has the following design goals. Process new blocks in the background following the consensus algorithm consistently. We want to minimize the memory usage of each block in the consensus graph. Even with the checkpoint mechanism, the graph will contain 300K-500K blocks in normal case and more than 1M blocks when facing liveness attacks. This may stress the memory. We want to process each block fast. Because full/archive nodes have to process every block from the original genesis when they catch up with the network from scratch, fast block process is important to keep the catch up period short. Robust against potential attacks. Malicious attackers may generate bad blocks at arbitrary position in the tree graph.","title":"Design Goals"},{"location":"consensus/#structures-and-components","text":"","title":"Structures and Components"},{"location":"consensus/#consensusgraph","text":"ConsensusGraph (core/src/consensus/mod.rs) is the main struct of the consensus layer. The synchronization layer construct ConsensusGraph with a BlockDataManager which stores all block metadata information in disk. ConsensusGraph::on_new_block() is the key function to send new blocks to the ConsensusGraph struct to process. It also provides a set of public functions to query the status of blocks/transactions. This should be the main interface which other components interact.","title":"ConsensusGraph"},{"location":"consensus/#consensusgraphinner","text":"ConsensusGraphInner (core/src/consensus/consensus_inner/mod.rs) is the inner structure of ConsensusGraph . ConsensusGraph::on_new_block() acquires the write lock of the inner struct at the start of the function. For the rest of query functions, they only acquire read lock. The internal structure of ConsensusGraphInner is fairly complicated. Generally speaking, it maintains two kinds of information. The first kind of information is the state of the whole tree graph, i.e., the current pivot chain , timer chain , difficulty , etc.. The second kind of information is the state of each block (i.e., ConsensusGraphNode struct for each block). Each block corresponds to a ConsensusGraphNode struct for its information. When it first enters ConsensusGraphInner , it will be inserted into ConsensusGraphInner::arena : Slab<ConsensusGraphNode> . The index in the slab will become the arena index of the block in ConsensusGraphInner . We use the arena index to represent a block internally instead of H256 because it is much cheaper. We will refer back to the fields in ConsensusGraphInner and ConsensusGraphNode when we talk about algorithm mechanism and their implementations.","title":"ConsensusGraphInner"},{"location":"consensus/#consensusnewblockhandler","text":"ConsensusNewBlockHandler (core/src/consensus/consensus_inner/consensus_new_block_handler.rs) contains a set of routines for processing a new block. In theory, this code could be part of ConsensusGraphInner because it mostly manipulates the inner struct. However, these routines are all subroutine of the on_new_block() and the consensus_inner/mod.rs is already very complicated. We therefore decide to put them into a separate file.","title":"ConsensusNewBlockHandler"},{"location":"consensus/#consensusexecutor","text":"ConsensusExecutor (core/src/consensus/consensus_inner/consensus_executor.rs) is the interface struct for the standalone transaction execution thread. ConsensusExecutor::enqueue_epoch() allow other struct to send an execution task to execute the epoch of a given pivot chain block asynchronously. Once the computation finishes, the result stateroot will be stored into BlockDataManager . Other threads can call ConsensusExecutor::wait_for_result() to wait for the execution of an epoch if desired. In the current implementation, ConsensusExecutor also contains the routines for the calculation for block rewards, including get_reward_execution_info() and its subroutines.","title":"ConsensusExecutor"},{"location":"consensus/#confirmationmeter","text":"ConfirmationMeter (core/src/consensus/consensus_inner/confirmation_meter.rs) conservatively calculates the confirmation risk of each pivot chain block. Its result will be useful for the storage layer to determine when it is safe to discard old snapshots. It also can be used to serve RPC queries about block confirmation if we decide to provide such RPC.","title":"ConfirmationMeter"},{"location":"consensus/#anticonecache-and-pastsetcache","text":"AnticoneCache (core/src/consensus/anticone_cache.rs) and PastsetCache (core/src/consensus/pastset_cache.rs) are two structs that implement customized cache for data structures in ConsensusGraphInner . In the implementation of the inner struct, we need to calculate and store the anticone set and the past set of each block. However, it is not possible to store all of these sets in memory. We therefore implement cache style data structures to store sets for recently inserted/accessed blocks. If a anticone/past set is not found in the cache, we will recalculate the set in the current inner struct implementation.","title":"AnticoneCache and PastsetCache"},{"location":"consensus/#important-algorithmic-mechanisms","text":"There are several important algorithmic mechanisms in the Conflux Consensus Layer. Here we will talk about them from the implementation aspect. See XXX for the algorithmic reasoning behind them.","title":"Important Algorithmic Mechanisms"},{"location":"consensus/#pivot-chain-and-total-order","text":"The basic idea of the Conflux consensus algorithm is to first make everyone agree on a pivot chain. It then expands the total order from the pivot chain to cover all blocks with a topological sort. As long as the pivot chain does not change/reorg, the total order of blocks will stay the same, so does the derived order of transactions. Comparing with Bitcoin/Ethereum, the consensus in Conflux has two key differences: almost every block will go into the total order, not just the agreed pivot chain. The transaction validity and the block validity are independent . A transaction is invalid if it was included before or it cannot carry out due to insufficient balance. Such invalid transaction will become noop during the execution. However, unlike Bitcoin and Ethereum blocks containing such transactions will not become invalid . In ConsensusGraphInner , the arena index of the current pivot chain blocks are stored in order in the pivot_chain[] vector. To maintain it, we calculate the least common ancestor (LCA) between the new inserted block and the current best block following the GHAST rule. If the fork corresponding to the new inserted block for the LCA ended up to be heavier. We will update the pivot_chain[] from the forked point.","title":"Pivot Chain and Total Order"},{"location":"consensus/#timer-chain","text":"Blocks whose PoW quality is timer_chain_difficulty_ratio times higher than the supposed difficulty are timer blocks . The is_timer field of the block will be set to True. The consensus algorithm then finds the longest timer block chain (more accurately, with heaviest accumulated difficulties) similar to the Bitcoin consensus algorithm of finding the longest chain. The arena index of this longest timer chain will be stored into timer_chain[] . The rationale of the timer chain is to provide a coarse grained measurement of the time that cannot be influenced by malicious attacker. Because timer blocks are rare and generated slowly (if timer_chain_difficulty_ratio is properly high), malicious attacker cannot prevent the growth of the timer chain unless it has the majority of the computation power. Therefore how many timer chain blocks appear in the past set of a block is a good indication about the latest possible generation time of the block. We compute this value for each block and store it in timer_chain_height field of the block.","title":"Timer Chain"},{"location":"consensus/#weight-maintenance-with-link-cut-tree","text":"To effectively maintain the pivot chain, we need to query the total weight of a subtree. Conflux uses a Link-Cut Tree data structure to maintain the subtree weights in O(log n). Link-Cut Tree can also calculates the LCA of any two nodes in the TreeGraph in O(log n). The weight_tree field in ConsensusGraphInner is the link-cut tree that stores the subtree weight of every node. Note that the implementation of the Link-Cut Tree is in the utils/link-cut-tree directory.","title":"Weight Maintenance with Link-Cut Tree"},{"location":"consensus/#adaptive-weight","text":"If the TreeGraph is under a liveness attack, it may fail to converge under one block for a while. To handle this situation, the GHAST algorithm idea is to start generate adaptive blocks, i.e., blocks whose weights are redistributed significantly so that there will be many zero weight blocks with a rare set of very heavy blocks. Specifically, if the PoW quality of an adaptive block is adaptive_heavy_block_ratio higher than the supposed difficulty, the block will have the weight of adaptive_heavy_block_ratio . Otherwise, the block will have the weight of zero. This effectively slows down the confirmation temporarily but will ensure the consensus progress. Because adaptive weight is a mechanism to defend against rare liveness attacks, it should not be turned on during the normal scenario. A new block is adaptive only if 1) one of its ancestor block is still not the dominant subtree comparing to its siblings and 2) a significantly long period of time has past between the generation of the ancestor block and the new block (i.e., the difference of timer_chain_height ). ConsensusGraphInner::adaptive_weight() and its subroutines implement the algorithm to determine whether a block is adaptive or not. Note that the implementation uses another link-cut-tree adaptive_tree as a helper. Please see the inlined comments for the implementation details.","title":"Adaptive Weight"},{"location":"consensus/#partial-invalid","text":"Note that the past set of a new block denotes all the blocks that the generator of the new block observes at the generation time. Therefore, from the past set of a new block, other full nodes could determine whether it chooses the correct parent block and whether it should be adaptive or not. The Conflux consensus algorithm defines those blocks who choose incorrect parents or fill in incorrect adaptive status as partial invalid blocks. For a partial invalid block, the partial_invalid field will be set to True. The algorithm requires the partial invalid blocks being treated differently from the normal blocks in three ways: All honest nodes will not reference directly or indirectly partial invalid blocks until a significant period of time. This time period is measured with the timer_chain_height and the difference has to be more than timer_chain_beta . Yes, it means that if another otherwise perfectly fine block referencing the partial invalid block, both of these two blocks will not be referenced for a while. Partial invalid blocks will have no block reward. They are extremely unlikely to get any reward anyway because of their large anticone set due to the first rule. Partial invalid blocks are excluded from the timer chain consideration. To implement the first rule, the on_new_block() routine in ConsensusNewBlockHandler is separated into two subroutine preactivate_block() and activate_block() . preactivate_block() compute and determine whether a block is partial invalid or not, while activate_block() fully integrate a block into the consensus graph inner data structures. For every new block, the field active_cnt tracks how many inactive blocks it references. A block is inactive if it references directly or indirectly a partial invalid block. activate_block() will be called on a block only when active_cnt of the block becomes zero. The field activated denotes whether a block is active or not. For partially invalid blocks, their activation will be delayed till the current timer chain height of the ledger is timer_chain_beta higher than the invalid block. New generated blocks will not reference any inactive blocks, i.e., these inactive blocks are treated as if they are not in the TreeGraph.","title":"Partial Invalid"},{"location":"consensus/#anticone-past-view-and-ledger-view","text":"In order to check the partial invalid status of each block, we need to operate under the past view of the block to determine its correct parent and its adaptivity. This is different from the current state of the TreeGraph or we call it the ledger view , i.e., all blocks in the anticone and the future set of the block are excluded. Because we process blocks in topological order, the future set of a new block is empty. We therefore need to eliminate all anticone blocks only. compute_and_update_anticone() in ConsensusNewBlockHandler computes the anticone set of a new block. Note that because the anticone set may be very large, we have two implementation level optimizations. First, we represent the anticone set as a set of barrier nodes in the TreeGraph, i.e., a set of subtrees where each block in the subtrees is in the anticone set. Second, we will only maintain the anticone set of the recently accessed/inserted blocks only. When checking whether a block is valid in its past view or not (e.g., in adaptive_weight() and in check_correct_parent() ), we first cut all barrier subtrees from the link-cut weight trees accordingly to get the state of the past view. After the computation, we restore these anticone subtrees back.","title":"Anticone, Past View, and Ledger View"},{"location":"consensus/#check-correct-parent","text":"To check whether a new block chooses a correct parent block or not, we first compute the set of blocks inside the epoch of the new block as if the new block is on the pivot chain. We store this set to the field blockset_in_own_view_of_epoch . We then iterate over every candidate block in this set to make sure that the chosen parent block is better than it. Specifically, we find out the two fork blocks of the candidate block and the parent block from their LCA and make sure that the fork of the parent is heavier. This logic is implemented in check_correct_parent() in ConsensusNewBlockHandler . Note that blockset_in_own_view_of_epoch may become too large to hold consistently in memory as well. Especially if a malicious attacker tries to generate invalid blocks to blow up this set. The current implementation will only periodically clear the set and only keep the sets for pivot chain blocks. Note that for pivot chain blocks, this set will also be used during the transaction execution.","title":"Check Correct Parent"},{"location":"consensus/#fallback-brute-force-methods","text":"There are situations where the anticone barrier set is too large if a malicious attacker tries to launch a performance attack on Conflux. This will make the default strategy worse than O(n) because there is a factor of O(log n) for each block in the barrier set when we do the link-cut tree chopping. To this end, we implemented a brute force routine compute_subtree_weights() to compute the subtree weights of each block in a past view for O(n). We also implement check_correct_parent_brutal() and adaptive_weight_impl_brutal() to use the brute-forcely computed subtree weight to do the checking instead.","title":"Fallback Brute Force Methods"},{"location":"consensus/#force-confirmation","text":"The Conflux consensus algorithm will force confirm a block if 1) there are timer_chain_beta consecutive timer chain blocks under the subtree of the block and 2) afterward there are at least timer_chain_beta timer chain blocks following (not required in the subtree though). Force confirmation means that new blocks should follow this block as their ancestor no matter what, ignoring subtree weights. Though extremely unlikely a force confirmed block will have lesser weights than its siblings. The force confirmation mechanism is to enable checkpoint, which we will describe later. It is based on the rationale that: Reverting a timer_chain_beta length timer chain is impossible. Therefore force confirmed block will always move along the pivot chain, not drifting between its siblings. We compute the accumulative LCA of the last timer_chain_beta timer chain blocks and store it at the timer_chain_accumulative_lca[] field. This vector is timer_chain_beta shorter than timer_chain[] because the force confirm needs at least timer_chain_beta timer chain block trailing, so their LCAs do not matter. check_correct_parent() and adaptive_weight() and their subroutines also respect this force confirm point during their checking. Specifically, any fork before the force confirm height is ignored. Note that this force confirm rule is also defined based on past view of each block. With the computed anticone information, compute_timer_chain_tuple() in ConsensusGraphInner computes the timer chain related information of each block under its past view. The results of this function is the difference of the timer_chain[] , timer_chain_accumulative_lca[] , and timer_chain_height between the ledger view and the past view. We can use the diff and the current ledger view values to get the past view values.","title":"Force Confirmation"},{"location":"consensus/#era","text":"In order to implement checkpoint, the Conflux consensus algorithm split the graph in eras. Every era contains era_epoch_count epochs. For example, if the era_epoch_count is 50000, then there is a new era every 50000 epochs. The pivot chain block at the height 50000 will be the genesis of a new era. At the era boundary, there are several differences from the normal case. A block will enter the total order for execution only if 1) it is under the subtree of the previous era and 2) it is inside the past set of the next era in the pivot chain. Anticone penalty calculation for the block reward does not go over the era boundary.","title":"Era"},{"location":"consensus/#checkpoint","text":"Inside ConsensusGraphInner , there are two key height pointers, the current checkpoint era genesis block height ( cur_era_genesis_height ) and the current stable era block height ( cur_era_stable_height ). These two height pointers will always point to some era genesis (being a multiple of era_epoch_count ). Initially, both of these two pointers will point to the true genesis (height 0). A new era genesis block become stable (i.e., cur_era_stable_height moves) if the block is force confirmed in the current TreeGraph. A new era genesis block become a new checkpoint (i.e., cur_era_genesis_height moves) if: The block is force confirmed in the past view of the stable genesis block . In the anticone of this block, there is no timer chain block. should_move_stable_height() and should_form_checkpoint_at() in ConsensusNewBlockHandler are invoked after every new inserted block to test the above two conditions. Generally speaking, the stable block will never be reverted off the pivot chain. Any block in the past set of the checkpoint block is no longer required for the future computation of the consensus layer. Therefore, after a new checkpoint is formed, make_checkpoint_at() in ConsensusNewBlockHandler is called to clean up those blocks that are not in the future set of the new checkpoint. Note that the checkpoint mechanism also changes how we handle a new block. For a new block: If the new block is outside the subtree of the current checkpoint. We only need to insert a stub into our data structure (because two blocks under the subtree may indirectly reference each other via this block). We do not need to care about this block because it is not going to change the timer chain and it is not going to be executed. If the past set of the new block does not contain the stable era block, we do not need to check the partial invalid status of this block. This is because this block will not change the timer chain (note our assumption that timer chain will not reorg more than timer_chain_beta ) and new blocks can reference this block directly (more than tiemr_chain_beta difference).","title":"Checkpoint"},{"location":"consensus/#deferred-execution","text":"Because the TreeGraph pivot chain may oscillate temporarily, we defer the transaction execution for DEFERRED_STATE_EPOCH_COUNT epochs (default 5). After a pivot chain update, activate_block() routine will enqueue the execution task of the new pivot chain except the last five epochs. It calls enqueue_epoch() in ConsensusExecutor to enqueue each task.","title":"Deferred Execution"},{"location":"consensus/#block-reward-calculation","text":"Because there is no explicit coinbase transaction in Conflux, all block rewards are computed implicitly during the transaction execution. In Conflux, the block reward is by the base reward and the penalty ratio based on the total weight of its anticone blocks dividing its own difficulty. This anticone set only considers blocks appearing within the next REWARD_EPOCH_COUNT epochs. Specially, if there is a new era then this anticone set will not count across the era boundary as well. get_pivot_reward_index() in ConsensusExecutor counts this reward anticone threshold. get_reward_execution_info_from_index() in ConsensusExecutor and its subroutines compute this anticone set given the threshold point in the pivot chain.","title":"Block Reward Calculation"},{"location":"consensus/#blame-mechanism","text":"It is not feasible to validate the filled state root of a block because we would need to execute all transactions in a different order in the past view of that block. Instead, we will only ask the full nodes to validate the state root results on the current pivot chain. It then fills a blame number to indicate how many levels ancestors from the parent who do not have correct state root. When this number is greater than zero, the filled deferred state root because a Merkel H256 vector that contains the corrected state roots of the ancestors along with the correct one. get_blame_and_deferred_state_for_generation() in ConsensusGraph computes the blame information for the block generation. first_trusted_header_starting_from() is ConsensusGraph is a useful helper function to compute the first trust worthy header that based the subtree blame information.","title":"Blame Mechanism"},{"location":"consensus/#multi-thread-design","text":"The consensus layer has one thread dedicated to process new blocks from the synchronization layer and one thread dedicated to execute transaction. It of course also has a set of interface APIs that RPC threads and synchronization threads may call.","title":"Multi-Thread Design"},{"location":"consensus/#consensus-worker","text":"Consensus Worker is a thread created by the synchronization layer. During the normal running phase, every new block will be sent to a channel connecting the synchronization thread and the consensus worker thread. The consensus work thread consumes each block one by one and invokes consensus::on_new_block() to process it. Note that the synchronization layer ensures the new block to be header-ready when it is delivered to Consensus Worker , i.e., all of its ancestor/past blocks are already delivered to the consensus before it is delivered. This enables the consensus layer to always deal with a complete direct acyclic graph without holes. One advantage of having a single thread to be dedicated on the consensus protocol is that it simplifies the protocol implementation a lot. Because the detail of the consensus protocol is complicated and the implementation involves many sophisticated data structure manipulations, the single thread design makes sure that we do not need to worry about deadlocks or races. Upon the entrance of consensus::on_new_block() , the thread acquires the write lock of the inner of the consensus struct (i.e., ConsensusGraphInner). During the normal phase, this thread should be the only one modifying the inner struct of the consensus layer.","title":"Consensus Worker"},{"location":"consensus/#consensus-execution-worker","text":"Consensus Execution Worker is a thread created at the start of the consensus layer. It is dedicated to transaction execution. There is a channel connecting Consensus Worker with Consensus Execution Worker . Once the consensus protocol determines the order of the pivot chain, it will send ExecutionTask for each epoch in the pivot chain to the channel. These tasks will be pick up by the Consensus Execution Worker thread one by one. The thread loads the previous state before the executed epoch from the storage layer as the input, runs all transactions in the executed epoch (see ConsensusExecutor::process_epoch_transactions() ), and produces the result state as the output. The rationale of separating the transaction execution from the consensus protocol implementation is for performance. With our blaming mechanism , the execution result state is completely separated from the consensus protocol implementation. The deferred execution mechanism gives us extra room to pipeline the consensus protocol and the transaction execution. It is therefore not wise to block the ConsensusWorker thread to wait for the execution results from coming back.","title":"Consensus Execution Worker"},{"location":"consensus/#key-assumptions-invariants-and-rules","text":"If you want to write code to interact with the Conflux consensus layer. It is very important to understand the following assumptions and rules. The consensus layer assumes that the passed BlockDataManager is in a consistent state. It means that the BlockDataManager contains correct current checkpoint/stable height. Blocks before the checkpoint and the stable height are properly checked during previous execution and they are persisted into the BlockDataManager properly. The consensus layer does not check the results it fetches from the block data manager. If it is inconsistent, the consensus layer will execute incorrectly or crash! Besides the subroutines of on_new_block() , no one should hold the write lock of the inner struct ! Right now the only exception for this rule is assemble_new_block_impl() because of computing the adaptive field and this is not good we plan to change it. Acquiring the write lock of the inner struct will very likely to cause deadlock given the complexity of the Consensus layer and its dependency with many other components. Always try to avoid this!","title":"Key Assumptions, Invariants, and Rules"},{"location":"design/","text":"Conflux Design Document \u00b6 In this document, we describe the architecture and organization of Conflux software stack and its design rationale. The following figure shows the overview of the Conflux full node stack. It consists of several key components. Peer-to-Peer Layer Synchronization Graph Consensus Graph Storage Layer Transaction Pool Block Generator Generally speaking, the peer-to-peer layer takes charge of disseminating blocks and transactions among the nodes in the entire network where each node maintains several inbound/outbound connections to its peers. Each node also maintains an in-memory synchronization graph data structure. When a new block is received from a peer or generated locally, the block will be first inserted into the synchronization graph where it goes through some basic validation which does not require graph-wise information. At the time when a block enters the synchronization graph, its past-set blocks may not already entered. The synchronization graph monitors the block and puts it into the consensus graph once all its past-set blocks enters the synchronization graph. When a block enters the consensus graph, its past-set blocks should all already entered this graph. Then the consensus algorithm will be conducted based on this newly arrived block to adjust the total order of blocks accordingly. The consensus graph component executes the newly arrived block and updates the account states in the storage layer. Each node maintains a transaction pool that holds the to-be-packed transactions and relays the transactions to its peers that may need them. The block generator component drives the mining efforts, picks transactions from the pool, and packs them into the newly generated block. This document is organized as in the following sections. Consensus Mechanism Block Synchronization Process Transaction Relay","title":"Design & Implementation"},{"location":"design/#conflux-design-document","text":"In this document, we describe the architecture and organization of Conflux software stack and its design rationale. The following figure shows the overview of the Conflux full node stack. It consists of several key components. Peer-to-Peer Layer Synchronization Graph Consensus Graph Storage Layer Transaction Pool Block Generator Generally speaking, the peer-to-peer layer takes charge of disseminating blocks and transactions among the nodes in the entire network where each node maintains several inbound/outbound connections to its peers. Each node also maintains an in-memory synchronization graph data structure. When a new block is received from a peer or generated locally, the block will be first inserted into the synchronization graph where it goes through some basic validation which does not require graph-wise information. At the time when a block enters the synchronization graph, its past-set blocks may not already entered. The synchronization graph monitors the block and puts it into the consensus graph once all its past-set blocks enters the synchronization graph. When a block enters the consensus graph, its past-set blocks should all already entered this graph. Then the consensus algorithm will be conducted based on this newly arrived block to adjust the total order of blocks accordingly. The consensus graph component executes the newly arrived block and updates the account states in the storage layer. Each node maintains a transaction pool that holds the to-be-packed transactions and relays the transactions to its peers that may need them. The block generator component drives the mining efforts, picks transactions from the pool, and packs them into the newly generated block. This document is organized as in the following sections. Consensus Mechanism Block Synchronization Process Transaction Relay","title":"Conflux Design Document"},{"location":"get_started/","text":"Getting Started \u00b6 Here we walk through how to quickly setup conflux full node to join the testnet and how to use Conflux wallet to manage your account, transfer Conflux token, and deploy smart contract. Running Conflux Full Node \u00b6 First, please build the binary as instructed in Installation . To start Conflux manually, you need to edit the default configuration file run/default.toml : Set public_address according to your public IP. The port should be 32323 by default. Set mining_author to the account address to receive mining reward. Conflux team has maintained some full nodes for the test net, and they have been provided as bootnodes . If you want to use other nodes to bootstrap your new node, you should edit this entry. Then you can run the following commands: $ cd run $ ../target/release/conflux --config default.toml It will start a full node and begin syncing the Conflux testnet blockchain. Note that two new directories ( blockchain_db and net_config ) will be created in the current working directory ( run ) to keep the persistent data. Please do not remove them unless data are corrupt or you want to start a fresh new node. To restart a node, just run the same command line in the same directory. Configuring Conflux Full Node \u00b6 Conflux can be configured using either the CLI options or a config file. Should the CLI flags and the config file disagree about a setting, the CLI takes precedence. The config file follows the format of TOML . The path of the configuration file can be set with the CLI option --config path/to/conflux.toml . A default configuration file default.toml with every configuration explained has been provided in the directory run , and you can start customizing your configuration from there. You can list all CLI options by running $ ./conflux --help . The vast majority of CLI options map to a setting in the TOML file, for example --public-address 127.0.0.1:32323 can be set by creating a config file: public_address=\"127.0.0.1:32323\" If you are going to set up a node and let it join the Conflux mainnet(testnet), you need to set the public_address appropriately. It should be set as the IP address of your node which can be accessed publicly from Internet. If your node is covered under a public gateway, you can get its public address by searching \"ip\" in Baidu . If you want to let your node participate the mining process, you need to enable it by setting start_mining as \"true\" and mining_author as the account address that receives the mining reward. Running Test \u00b6 We have both unit tests written in Rust and integration tests written in python. After you make some modifications to the code, you can run these tests to see if the system still runs correctly. First, you need to install the dependencies as instructed in Install Test Dependencies . Then you can run the tests as follows Linux: $ ./dev-support/test.sh This will automatically run the unit tests in our Rust code and the python tests. Others: To run unit tests in Rust: $ cargo test --release --all To run python integration tests: $ ./tests/test_all.py Using Conflux Web Wallet \u00b6 You can access Conflux web wallet and create a new wallet by clicking \"New Wallet\" button that provides you a seed phrase (used to restore your wallet if you close it) and a password (used to unlock your wallet if you lock it when you leave your computer). Once a wallet is created, you can then manage your account addresses, send transactions, and deploy smart contract. In order to issue on-chain operations, you will need Conflux tokens. You can periodically (1 Conflux token per hour) get Conflux tokens from a faucet account. A pop-up box will appear to inform you to get the tokens. For developers to build smart contract, you can use remix to write and compile your contract to generate bytecode which you can then copy-paste to \"Contract\" page of the wallet that is triggered by action \"Contract\".","title":"Getting Started"},{"location":"get_started/#getting-started","text":"Here we walk through how to quickly setup conflux full node to join the testnet and how to use Conflux wallet to manage your account, transfer Conflux token, and deploy smart contract.","title":"Getting Started"},{"location":"get_started/#running-conflux-full-node","text":"First, please build the binary as instructed in Installation . To start Conflux manually, you need to edit the default configuration file run/default.toml : Set public_address according to your public IP. The port should be 32323 by default. Set mining_author to the account address to receive mining reward. Conflux team has maintained some full nodes for the test net, and they have been provided as bootnodes . If you want to use other nodes to bootstrap your new node, you should edit this entry. Then you can run the following commands: $ cd run $ ../target/release/conflux --config default.toml It will start a full node and begin syncing the Conflux testnet blockchain. Note that two new directories ( blockchain_db and net_config ) will be created in the current working directory ( run ) to keep the persistent data. Please do not remove them unless data are corrupt or you want to start a fresh new node. To restart a node, just run the same command line in the same directory.","title":"Running Conflux Full Node"},{"location":"get_started/#configuring-conflux-full-node","text":"Conflux can be configured using either the CLI options or a config file. Should the CLI flags and the config file disagree about a setting, the CLI takes precedence. The config file follows the format of TOML . The path of the configuration file can be set with the CLI option --config path/to/conflux.toml . A default configuration file default.toml with every configuration explained has been provided in the directory run , and you can start customizing your configuration from there. You can list all CLI options by running $ ./conflux --help . The vast majority of CLI options map to a setting in the TOML file, for example --public-address 127.0.0.1:32323 can be set by creating a config file: public_address=\"127.0.0.1:32323\" If you are going to set up a node and let it join the Conflux mainnet(testnet), you need to set the public_address appropriately. It should be set as the IP address of your node which can be accessed publicly from Internet. If your node is covered under a public gateway, you can get its public address by searching \"ip\" in Baidu . If you want to let your node participate the mining process, you need to enable it by setting start_mining as \"true\" and mining_author as the account address that receives the mining reward.","title":"Configuring Conflux Full Node"},{"location":"get_started/#running-test","text":"We have both unit tests written in Rust and integration tests written in python. After you make some modifications to the code, you can run these tests to see if the system still runs correctly. First, you need to install the dependencies as instructed in Install Test Dependencies . Then you can run the tests as follows Linux: $ ./dev-support/test.sh This will automatically run the unit tests in our Rust code and the python tests. Others: To run unit tests in Rust: $ cargo test --release --all To run python integration tests: $ ./tests/test_all.py","title":"Running Test"},{"location":"get_started/#using-conflux-web-wallet","text":"You can access Conflux web wallet and create a new wallet by clicking \"New Wallet\" button that provides you a seed phrase (used to restore your wallet if you close it) and a password (used to unlock your wallet if you lock it when you leave your computer). Once a wallet is created, you can then manage your account addresses, send transactions, and deploy smart contract. In order to issue on-chain operations, you will need Conflux tokens. You can periodically (1 Conflux token per hour) get Conflux tokens from a faucet account. A pop-up box will appear to inform you to get the tokens. For developers to build smart contract, you can use remix to write and compile your contract to generate bytecode which you can then copy-paste to \"Contract\" page of the wallet that is triggered by action \"Contract\".","title":"Using Conflux Web Wallet"},{"location":"install/","text":"Installation \u00b6 Here is a step by step guide on how to build Conflux from the source code and get a node running. Install Build Dependencies \u00b6 Conflux requires latest stable Rust version , clang , and sqlite to build. We recommend installing Rust through rustup . If you don't already have rustup or clang , you can install them like this: Linux: $ curl https://sh.rustup.rs -sSf | sh clang and sqlite can be installed with: Ubuntu: $ sudo apt-get install clang libsqlite3-dev CentOS / RHEL: $ sudo yum install clang sqlite-devel OSX: $ curl https://sh.rustup.rs -sSf | sh You might need to install brew if you need to use it to install clang : $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" clang comes with Xcode command line tools, and can also be installed with homebrew: $ brew install --with-clang llvm Windows: Make sure you have Visual Studio 2015 with C++ support installed. Next, download and run the rustup installer from https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe, start \"VS2015 x64 Native Tools Command Prompt\", and use the following command to install and set up the msvc toolchain: $ rustup default stable-x86_64-pc-windows-msvc clang can be installed with LLVM. Pre-built binaries can be downloaded from Download LLVM . Make sure to add LLVM to the system PATH as instructed. Make sure that these binaries are in your PATH (the instruction will be shown after installing rustup ). After that, you should be able to build Conflux from source. Build from Source Code \u00b6 After installing the dependencies mentioned above, now you can clone our repository and start building the executable binary: # download Conflux code $ git clone https://github.com/Conflux-Chain/conflux-rust $ cd conflux-rust $ git checkout v0.1.7 # build in release mode $ cargo build --release This produces an executable in the ./target/release subdirectory. Note, when compiling a crate and you receive errors, it's in most cases your outdated version of Rust, or some of your crates have to be recompiled. Cleaning the repository will most likely solve the issue if you are on the latest stable version of Rust, try: $ cargo clean && cargo update To start running a Conflux full node, you can follow the instructions at Running Conflux Full Node . Install Test Dependencies \u00b6 We have a test framework written in Python3 (version>=3.6). Required packages can be installed by running $ ./dev-support/dep_pip3.sh Solidity compiler solc is also required, and be installed as follows: Ubuntu sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc OSX brew update brew upgrade brew tap ethereum/ethereum brew install solidity Others You can follow the detailed instructions at Installing the Solidity Compiler . Note that latest solidity compiler may be incompatible with Conflux and may cause the integration test to fail. If you encounter such problem, please install solidity compiler version 0.5.2. To run tests, you can build the source code first and follow the instructions at Running Test .","title":"Installation"},{"location":"install/#installation","text":"Here is a step by step guide on how to build Conflux from the source code and get a node running.","title":"Installation"},{"location":"install/#install-build-dependencies","text":"Conflux requires latest stable Rust version , clang , and sqlite to build. We recommend installing Rust through rustup . If you don't already have rustup or clang , you can install them like this: Linux: $ curl https://sh.rustup.rs -sSf | sh clang and sqlite can be installed with: Ubuntu: $ sudo apt-get install clang libsqlite3-dev CentOS / RHEL: $ sudo yum install clang sqlite-devel OSX: $ curl https://sh.rustup.rs -sSf | sh You might need to install brew if you need to use it to install clang : $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" clang comes with Xcode command line tools, and can also be installed with homebrew: $ brew install --with-clang llvm Windows: Make sure you have Visual Studio 2015 with C++ support installed. Next, download and run the rustup installer from https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe, start \"VS2015 x64 Native Tools Command Prompt\", and use the following command to install and set up the msvc toolchain: $ rustup default stable-x86_64-pc-windows-msvc clang can be installed with LLVM. Pre-built binaries can be downloaded from Download LLVM . Make sure to add LLVM to the system PATH as instructed. Make sure that these binaries are in your PATH (the instruction will be shown after installing rustup ). After that, you should be able to build Conflux from source.","title":"Install Build Dependencies"},{"location":"install/#build-from-source-code","text":"After installing the dependencies mentioned above, now you can clone our repository and start building the executable binary: # download Conflux code $ git clone https://github.com/Conflux-Chain/conflux-rust $ cd conflux-rust $ git checkout v0.1.7 # build in release mode $ cargo build --release This produces an executable in the ./target/release subdirectory. Note, when compiling a crate and you receive errors, it's in most cases your outdated version of Rust, or some of your crates have to be recompiled. Cleaning the repository will most likely solve the issue if you are on the latest stable version of Rust, try: $ cargo clean && cargo update To start running a Conflux full node, you can follow the instructions at Running Conflux Full Node .","title":"Build from Source Code"},{"location":"install/#install-test-dependencies","text":"We have a test framework written in Python3 (version>=3.6). Required packages can be installed by running $ ./dev-support/dep_pip3.sh Solidity compiler solc is also required, and be installed as follows: Ubuntu sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc OSX brew update brew upgrade brew tap ethereum/ethereum brew install solidity Others You can follow the detailed instructions at Installing the Solidity Compiler . Note that latest solidity compiler may be incompatible with Conflux and may cause the integration test to fail. If you encounter such problem, please install solidity compiler version 0.5.2. To run tests, you can build the source code first and follow the instructions at Running Test .","title":"Install Test Dependencies"},{"location":"javascript-api/","text":"Getting Started with ConfluxWeb \u00b6 The conflux-web library is a collection of modules which contain specific functionality for the conflux ecosystem. The conflux-web-cfx is for the conflux blockchain and smart contracts. The conflux-web-utils contains useful helper functions for Dapp developers. Adding conflux-web First you need to get conflux-web into your project. This can be done using the following methods: npm: npm install conflux-web After that you need to create a confluxWeb instance and set a provider. Normally you should connect to a remote/local node. const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); That\u2019s it! now you can use the confluxWeb object. Using Promises All of functions use asynchronous HTTP requests and return promises by default: const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); confluxWeb.cfx.getEpochNumber().then(console.log); A note on big numbers You will always get a BigNumber object for number values as JavaScript is not able to handle big numbers correctly. Look at the following examples: \"101010100324325345346456456456456456456\" // \"101010100324325345346456456456456456456\" 101010100324325345346456456456456456456 // 1.0101010032432535e+38 ConfluxWeb depends on the BN.js library for big numbers, See the BN.js documentation for details. ConfluxWeb by Example \u00b6 Hash Time Locked Contract \u00b6 Here we brought you a ConfluxWeb example. You can learn how to develop a Hash Time Locked Contract (HTLC) with ConfluxWeb API. ConfluxWeb API Reference \u00b6 ConfluxWeb \u00b6 ConfluxWeb.providers \u00b6 Class attribute object Example \u00b6 > ConfluxWeb.providers { HttpProvider: [Function: HttpProvider$1], WebsocketProvider: [Function: WebsocketProvider$1], IpcProvider: [Function: IpcProvider$1] } ConfluxWeb.modules \u00b6 Class attribute object Example \u00b6 > ConfluxWeb.modules { Cfx: [Function: Cfx], Net: [Function: Net] } ConfluxWeb.utils \u00b6 Class attribute Object attribute Property of ConfluxWeb class and instance of ConfluxWeb, See confluxWeb.utils for more. object Example \u00b6 > ConfluxWeb.utils {...} > confluxWeb.utils {...} ConfluxWeb.version \u00b6 Object attribute current version string Example \u00b6 > confluxWeb.version 0.1.21-alpha.0 ConfluxWeb.currentProvider \u00b6 Object attribute current provider instance object Example \u00b6 > confluxWeb.currentProvider; HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... } ConfluxWeb.setProvider \u00b6 Will change the provider for its module. NOTE: When called on the umbrella package cfx it will also set the provider for all sub modules confluxWeb.cfx, etc. function setProvider(provider) Parameters \u00b6 Name Type Required Default Description provider object true A valid provider. Return \u00b6 boolean Example \u00b6 > const ConfluxWeb = require('conflux-web'); > const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); > confluxWeb.currentProvider HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... } > confluxWeb.setProvider(new ConfluxWeb.providers.HttpProvider('http://localhost:12537')); true > confluxWeb.currentProvider HttpProvider { host: 'http://localhost:12537' ... } > confluxWeb.setProvider('http://localhost:12537'); // same as above true > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.setProvider('http://localhost:12537') // change all provider > confluxWeb.currentProvider.host \"http://localhost:12537\" > confluxWeb.cfx.currentProvider.host \"http://localhost:12537\" ConfluxWeb.cfx.Contract \u00b6 ConfluxWeb.cfx.Contract.abiModel \u00b6 abi object Object Example \u00b6 > contract.abiModel AbiModel { abi: { methods: { count: [AbiItemModel], '0x06661abd': [AbiItemModel], 'count()': [AbiItemModel], inc: [AbiItemModel], '0x812600df': [AbiItemModel], 'inc(uint256)': [AbiItemModel], contractConstructor: [AbiItemModel] }, events: {} } } ConfluxWeb.cfx.Contract.address \u00b6 The address used for this contract instance. All transactions generated by confluxWeb from this contract will contain this address as the \"to\". string Example \u00b6 > contract.address; // What you set when new contract. \"0xf02dbcf0eff48e174ca59f1975a7b0042c4d02b7\" ConfluxWeb.cfx.Contract.defaultGas \u00b6 The default maximum gas provided for a transaction (gasLimit). number ConfluxWeb.cfx.Contract.defaultGasPrice \u00b6 The default gas price in drip to use for transactions. number ConfluxWeb.cfx.Contract.methods \u00b6 Creates a transaction object for that method, which then can be called, send, estimated. The methods of this smart contract are available through: The name: myContract.methods.myMethod(123) The name with parameters: myContract.methods 'myMethod(uint256)' The signature: myContract.methods '0x58cf5f10' This allows calling functions with same name but different parameters from the JavaScript contract object. Proxy Example \u00b6 > contract.address; \"0x079352147ce2de227af6fa963f603a35aed8e601\" > await contract.methods.count().call(); BigNumber { _hex: '0xfe' } > await contract.methods.inc(1).call(); // call will get function return value BigNumber { _hex: '0xff' } > await contract.methods.count().call(); // can not change data in block chain by `call` BigNumber { _hex: '0xfe' } > await contract.methods.inc(1).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 100 }); // send a transaction \"0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a\" > await confluxWeb.cfx.getTransactionReceipt('0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a'); { status: true, ... } > await contract.methods.count().call(); // change data in block chain by `send` BigNumber { _hex: '0xff' } ConfluxWeb.cfx.Contract.constructor \u00b6 Creates a new contract instance with all its methods and events defined in its json interface abi object. function constructor(abi,address,options) Parameters \u00b6 Name Type Required Default Description abi object|array true The abi json interface of the contract. address string false The address where the contract is deployed. If undefined, you should deploy contract by data. options object false options.data string false The byte code of the contract. Used when the contract gets deployed. options.from string false The address transactions should be made from. options.gasPrice string false The gas price in drip to use for transactions. options.gas number false The maximum gas provided for a transaction (gasLimit). Return \u00b6 void Example \u00b6 > confluxWeb.cfx.accounts.wallet.add('0xa816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY > const contract = new confluxWeb.cfx.Contract( [ { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"name\": \"inc\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" } ], ); ConfluxWeb.cfx.Contract.deploy \u00b6 function deploy(options) Parameters \u00b6 Name Type Required Default Description options object true options.data string false contract data options.arguments array false contract constructor parameters Return \u00b6 Object Example \u00b6 > await contract.deploy({arguments: [254]}).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 819 }); // deploy contract by `send` \"0x6d1b5d68540faac893e5d5dcfed7fc253a2fd6936634f917c82856a0b19c3838\" > await confluxWeb.cfx.getTransactionReceipt('0xd1d5b66b0d3d215f042f3e4907a3bf0acf5984972527fbca45eb67286835260d'); { status: true, contractCreated: '0x079352147ce2de227af6fa963f603a35aed8e601', ... } > contract.address = '0x079352147ce2de227af6fa963f603a35aed8e601'; // after deploy, you should add address to contract ConfluxWeb.cfx.Contract.clone \u00b6 Clones the current contract instance. function clone() Parameters \u00b6 void Return \u00b6 Object The new contract instance. Example \u00b6 > const clone = contract.clone() > contract.defaultGas === clone.defaultGas; true > contract.defaultGasPrice === clone.defaultGasPrice; true > contract.address === clone.address; // only address difference, and clone one address to be undefined false ConfluxWeb.cfx \u00b6 ConfluxWeb.cfx.defaultAccount \u00b6 This default address is used as the default \"from\" property. 20 Bytes: Any Conflux address. You should have the private key for that address in your node or keystore. string|undefined Example \u00b6 > confluxWeb.cfx.defaultAccount undefined > confluxWeb.cfx.defaultAccount = '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b'; > confluxWeb.cfx.defaultAccount \"0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b\" ConfluxWeb.cfx.defaultEpoch \u00b6 When requests are made that act on the state of conflux, the default epoch parameter determines the height of the epoch. The following options are possible for the default epoch parameter: number : An integer epoch number. \"earliest\" : The earliest epoch where the genesis block in. \"latest_state\" : The latest epoch where the latest block with an executed state in. (default) \"latest_mined\" : The latest epoch where the latest mined block in. number|string Example \u00b6 > confluxWeb.cfx.defaultEpoch; // Default is \"latest_state\" \"latest_state\" ConfluxWeb.cfx.currentProvider \u00b6 Will return the current provider, otherwise null object|null Example \u00b6 > confluxWeb.cfx.currentProvider HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... } ConfluxWeb.cfx.setProvider \u00b6 Will change the provider for its module. function setProvider(cfxProvider) Parameters \u00b6 Name Type Required Default Description cfxProvider object true A valid provider. Return \u00b6 boolean Example \u00b6 > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.setProvider('http://localhost:12537') // change module provider > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://localhost:12537\" ConfluxWeb.cfx.getGasPrice \u00b6 Returns the current gas price oracle. The gas price is determined by the last few blocks median gas price. async function getGasPrice() Parameters \u00b6 void Return \u00b6 Promise.<string> Number string of the current gas price in drip. Example \u00b6 > await confluxWeb.cfx.getGasPrice() \"0\" ConfluxWeb.cfx.getEpochNumber \u00b6 Returns the current epoch number the client is on. async function getEpochNumber() Parameters \u00b6 void Return \u00b6 Promise.<number> Example \u00b6 > await confluxWeb.cfx.getEpochNumber(); 990902 ConfluxWeb.cfx.getBalance \u00b6 Get the balance of an address at a given epoch. async function getBalance(address,defaultEpoch) Parameters \u00b6 Name Type Required Default Description address string true The address to get the balance of. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch. Return \u00b6 Promise.<string> The current balance for the given address in drip. Example \u00b6 > await confluxWeb.cfx.getBalance(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\"); \"685539999999937000\" > await confluxWeb.cfx.getBalance(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\", \"earliest\"); \"0\" ConfluxWeb.cfx.getCode \u00b6 Get the code at a specific address. async function getCode(address,defaultEpoch) Parameters \u00b6 Name Type Required Default Description address string true The address to get the code from. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch. Return \u00b6 Promise.<string> The data at given address Example \u00b6 > await confluxWeb.cfx.getCode(\"0x079352147ce2de227af6fa963f603a35aed8e601\"); \"0x6080604052348015600f57600080fd5b506004361060325760003560e01c806306661abd146037578063812600df146053575b600080fd5b603d6092565b6040518082815260200191505060405180910390f35b607c60048036036020811015606757600080fd5b81019080803590602001909291905050506098565b6040518082815260200191505060405180910390f35b60005481565b60008160008082825401925050819055905091905056fea265627a7a723158203aa4346abf52089d9be8806b8bf35dff408bd9f68f668e528bc8e2e20d74b29064736f6c634300050b0032\" ConfluxWeb.cfx.getBlock \u00b6 Returns a block matching the block number or block hash. async function getBlock(blockHashOrEpochNumber,returnTransactionObjects) Parameters \u00b6 Name Type Required Default Description blockHashOrEpochNumber string|number true The block hash or epoch. returnTransactionObjects boolean false false If true, the returned block will contain all transactions as objects, if false it will only contains the transaction hashes. Return \u00b6 Promise.<object> The block object string miner: The address of the beneficiary to whom the mining rewards were given. string|null hash: Hash of the block. null when its pending block. string parentHash: Hash of the parent block. string[] refereeHashes: Array of referee hashes. number|null epochNumber: The current block epoch number in the client's view. null when it's not in best block's past set. boolean stable: If the block stable or not string nonce: Hash of the generated proof-of-work. null when its pending block. number gasLimit: The maximum gas allowed in this block. string difficulty: Integer string of the difficulty for this block. number height: The block heights. null when its pending block. number size: Integer the size of this block in bytes. number blame: 0 if there's nothing to blame; k if the block is blaming on the state info of its k-th ancestor. boolean adaptive: If the block's weight adaptive or not. number timestamp: The unix timestamp for when the block was collated. string transactionsRoot: The hash of the transactions of the block. string[] transactions: Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. string deferredLogsBloomHash: The hash of the deferred block's log bloom filter string deferredReceiptsRoot: The hash of the receipts of the block after deferred execution. string deferredStateRoot: The root of the final state trie of the block after deferred execution. object deferredStateRootWithAux: Information of deferred state root Example \u00b6 > await confluxWeb.cfx.getBlock(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\"); { \"miner\": \"0x0000000000000000000000000000000000000015\", \"hash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"parentHash\": \"0xa378c9e283c08eac0e2ac51a8c19e61717af812a157eb914d35b171ed20920b9\", \"refereeHashes\": [], \"epochNumber\": 925836, \"stable\": true, \"nonce\": \"0xaaa4a571ad424ec\", \"gasLimit\": 3000000000, \"difficulty\": \"21351313\", \"height\": 925836, \"size\": 384, \"blame\": 0, \"adaptive\": false, \"timestamp\": 1570608173, \"transactionsRoot\": \"0xbe7a9e531d55ed950a217272afa035f57f6c512ca249bae19e214cf2b470562e\" \"transactions\": [ \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\" ], \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xc4ec82320df3b5ce48e22d33cc82f665a274dc920796a3e206be44682b7812a2\", \"deferredStateRootWithAux\": { \"auxInfo\": { \"intermediateDeltaEpochId\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"previousSnapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"stateRoot\": { \"deltaRoot\": \"0xbc71c52f0dae840fd8815de081a2774927077714a5fe7c342b0e5e81f7bcd38e\", \"intermediateDeltaRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"snapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" } }, } > await confluxWeb.cfx.getBlock(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", true); { \"adaptive\": false, \"blame\": 0, \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xc4ec82320df3b5ce48e22d33cc82f665a274dc920796a3e206be44682b7812a2\", \"deferredStateRootWithAux\": { \"auxInfo\": { \"intermediateDeltaEpochId\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"previousSnapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"stateRoot\": { \"deltaRoot\": \"0xbc71c52f0dae840fd8815de081a2774927077714a5fe7c342b0e5e81f7bcd38e\", \"intermediateDeltaRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"snapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" } }, \"difficulty\": \"21351313\", \"epochNumber\": 925836, \"gasLimit\": 3000000000, \"hash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"height\": 925836, \"miner\": \"0x0000000000000000000000000000000000000015\", \"nonce\": \"0xaaa4a571ad424ec\", \"parentHash\": \"0xa378c9e283c08eac0e2ac51a8c19e61717af812a157eb914d35b171ed20920b9\", \"refereeHashes\": [], \"size\": 384, \"stable\": true, \"timestamp\": 1570608173, \"transactions\": [ { \"blockHash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"contractCreated\": null, \"data\": \"0x\", \"from\": \"0xA70ddf9B9750c575Db453Eea6A041f4C8536785A\", \"gas\": 21000, \"gasPrice\": \"819\", \"hash\": \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\", \"nonce\": 921, \"r\": \"0x985743d5d627e8f93e243bfd71e401f7bf5c7b098afeb910952df789312cc7b1\", \"s\": \"0xaaf07bc11d56516f90697fb0f1b8140ec9b252c66e8f3172799e2829d457775\", \"status\": \"0x0\", \"to\": \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\", \"transactionIndex\": 0, \"v\": 1, \"value\": \"1000000000000000000\" } ], \"transactionsRoot\": \"0xbe7a9e531d55ed950a217272afa035f57f6c512ca249bae19e214cf2b470562e\" } ConfluxWeb.cfx.getTransaction \u00b6 Returns a transaction matching the given transaction hash. async function getTransaction(transactionHash) Parameters \u00b6 Name Type Required Default Description transactionHash string true The transaction hash. Return \u00b6 Promise.<object> The transaction object string blockHash: Hash of the block where this transaction was in and got executed. null when its pending. number transactionIndex: Integer of the transactions index position in the block. string hash: Hash of the transaction. number nonce: The number of transactions made by the sender prior to this one. string from: Address of the sender. string to: Address of the receiver. null when its a contract creation transaction. string value: Value transferred in Drip. string data: The data send along with the transaction. number gas: Gas provided by the sender. number gasPrice: Gas price provided by the sender in Drip. string status: '0x0' successful execution; '0x1' exception happened but nonce still increased; '0x2' exception happened and nonce didn't increase. string|null contractCreated: The contract address created, if the transaction was a contract creation, otherwise null. string r: ECDSA signature r string s: ECDSA signature s string v: ECDSA recovery id Example \u00b6 > await confluxWeb.cfx.getTransaction(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\"); { \"blockHash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"transactionIndex\": 0, \"hash\": \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\", \"nonce\": 921, \"from\": \"0xA70ddf9B9750c575Db453Eea6A041f4C8536785A\", \"to\": \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\", \"value\": \"1000000000000000000\" \"data\": \"0x\", \"gas\": 21000, \"gasPrice\": \"819\", \"status\": \"0x0\", \"contractCreated\": null, \"r\": \"0x985743d5d627e8f93e243bfd71e401f7bf5c7b098afeb910952df789312cc7b1\", \"s\": \"0xaaf07bc11d56516f90697fb0f1b8140ec9b252c66e8f3172799e2829d457775\", \"v\": 1, } ConfluxWeb.cfx.getTransactionCount \u00b6 Get the numbers of transactions sent from this address. async function getTransactionCount(address,defaultEpoch) Parameters \u00b6 Name Type Required Default Description address string true The address to get the numbers of transactions from. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch. Return \u00b6 Promise.<number> The number of transactions sent from the given address. Example \u00b6 > await confluxWeb.cfx.getTransactionCount(\"0xa70ddf9b9750c575db453eea6a041f4c8536785a\"); 974 > await confluxWeb.cfx.getTransactionCount(\"0xa70ddf9b9750c575db453eea6a041f4c8536785a\", 'earliest'); 0 ConfluxWeb.cfx.sendSignedTransaction \u00b6 Sends an already signed transaction, generated for example using confluxWeb.cfx.accounts.signTransaction async function sendSignedTransaction(signedTransactionData) Parameters \u00b6 Name Type Required Default Description signedTransactionData string true Signed transaction data in HEX format Return \u00b6 Promise.<string> Transaction hash Example \u00b6 > const ConfluxTx = require('confluxjs-transaction'); > const tx = new ConfluxTx({ nonce: '0x03', gasPrice: '0x01', gasLimit: '0x5208', // 21000 to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', // ADDRESS_TO value: '0x01', }); > tx.sign(Buffer.from('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393', 'hex')); // KEY_FROM > await confluxWeb.cfx.sendSignedTransaction('0x' + tx.serialize().toString('hex')); 0x200b930e95b3c8c54978499c6407ef71fc96a83eced88640fae59b75e1d16ef4 ConfluxWeb.cfx.signTransaction \u00b6 Signs a transaction. This account needs to be unlocked. async function signTransaction(rawTx) Parameters \u00b6 Name Type Required Default Description rawTx object true rawTx.from number true An address or index of a local wallet in confluxWeb.cfx.accounts.wallet. rawTx.to string false The destination address of the message, left undefined for a contract-creation transaction. rawTx.value number|string|BN|BigNumber false The value transferred for the transaction in drip, also the endowment if it\u2019s a contract-creation transaction. rawTx.gas number false To-Be-Determined The amount of gas to use for the transaction (unused gas is refunded). rawTx.gasPrice number|string|BN|BigNumber false confluxWeb.cfx.gasPrice The price of gas for this transaction in drip. rawTx.data string false Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code. rawTx.nonce number false Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce. Return \u00b6 Promise.<object> The RLP encoded transaction. The raw property can be used to send the transaction using confluxWeb.cfx.sendSignedTransaction. string rawTransaction: Raw transaction string string messageHash: Hash of transaction for calculating signature string r: ECDSA signature r string s: ECDSA signature s string v: ECDSA recovery id Example \u00b6 > confluxWeb.cfx.accounts.wallet.add('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY_FROM > await confluxWeb.cfx.signTransaction({ from: 0, // index nonce: 0, // make nonce appropriate gasPrice: 10, gas: 21000, value: new BN('300000000000000000'), // 300000000000000000 drip === 0.3 cfx token to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', // ADDRESS_TO data: '', }); { \"messageHash\": \"53aec3cdccb8ab438303ece4559fc4464a118416828d8c7c0427f5debcd8feae\", \"r\": \"0x1feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2\", \"s\": \"0x0451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67\", \"v\": \"0x01\", \"rawTransaction\": \"0xf867800a825208941ead8630345121d19ee3604128e5dc54b36e8ea6880429d069189e00008001a01feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2a00451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67\" } ConfluxWeb.cfx.call \u00b6 Executes a message call transaction, which is directly executed in the VM of the node, but never mined into the blockchain. async function call(callObject,defaultEpoch) Parameters \u00b6 Name Type Required Default Description callObject object true A transaction object, with the difference that for calls the from property is optional as well. defaultEpoch string|number false conflux.cfx.defaultEpoch Return \u00b6 Promise.<string> The returned data of the call, e.g. A smart contract functions return value. Example \u00b6 > await confluxWeb.cfx.call({ to: \"0x11f4d0a3c12e86b4b5f39b213f7e19d048276dae\", // contract address data: \"0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\" }) 0x000000000000000000000000000000000000000000000000000000000000000a ConfluxWeb.cfx.estimateGas \u00b6 Executes a message call or transaction and returns the amount of the gas used. async function estimateGas(callObject) Parameters \u00b6 Name Type Required Default Description callObject object true A transaction object, with the difference that for calls the from property is optional as well. Return \u00b6 Promise.<number> - the used gas for the simulated call/transaction. Example \u00b6 > await confluxWeb.cfx.estimateGas({ to: \"0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe\", data: \"0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\" }) 0x0000000000000000000000000000000000000000000000000000000000000015 ConfluxWeb.cfx.getTransactionReceipt \u00b6 Returns the receipt of a transaction by transaction hash. NOTE: The receipt is not available for pending transactions and returns null. async function getTransactionReceipt(txHash) Parameters \u00b6 Name Type Required Default Description txHash string true The transaction hash. Return \u00b6 Promise.<object> A transaction receipt object, or null when no receipt was found. boolean status: true if the transaction was successful; false , if the EVM reverted the transaction. number outcomeStatus: 1 status true ; 0 status false . string stateRoot: The state root of transaction execution. number epochNumber: Epoch number where this transaction was in. string blockHash: Hash of the block where this transaction was in. string transactionHash: Hash of the transaction. number index: Integer of the transactions index position in the block. string from: Address of the sender. string to: Address of the receiver. null when its a contract creation transaction. string|null contractCreated: The contract address created, if the transaction was a contract creation, otherwise null. number gasUsed: The amount of gas used by this specific transaction alone. [object] logs: Array of log objects, which this transaction generated. [string] logs[].address: The address of the contract executing at the point of the LOG operation. [string] logs[].topics: The topics associated with the LOG operation. [string] logs[].data: The data associated with the LOG operation. string logsBloom: Example \u00b6 > await confluxWeb.cfx.getTransactionReceipt('0x689258ba9fe2c25bcdc43ebb5c9018d1b56d25b1c87de1b371a19f5548c16dc1'); { status: true, outcomeStatus: 0, stateRoot: '0x75df853d267b40a98f6fe1103a510822bc1582894e8a9e95eb9ff0697545e4d2', epochNumber: 1017673, blockHash: '0xdefb3add0256b12c80f6e4fddde81da9c93ec88861cbee14051379f79624f911', transactionHash: '0x689258ba9fe2c25bcdc43ebb5c9018d1b56d25b1c87de1b371a19f5548c16dc1', index: 0, from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', contractCreated: null, gasUsed: 21000, logs: [], logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', } ConfluxWeb.cfx.getPastLogs \u00b6 Gets past logs, matching the given options. async function getPastLogs(options) Parameters \u00b6 Name Type Required Default Description options object true options.fromEpoch string false The number of the earliest block options.toEpoch string false The number of the latest block options.address string|Array. true An address or a list of addresses to only get logs from particular account(s). options.topics array true An array of values which must each appear in the log entries. The order is important, if you want to leave topics out use null, e.g. [null, '0x12...']. You can also pass an array for each topic with options for that topic e.g. [null, ['option1', 'option2']] Return \u00b6 Promise.<Array.<object>> Array of log objects. Example \u00b6 > await confluxWeb.cfx.getPastLogs({ fromEpoch: '0x0', toEpoch: 'latest_mined', address: '0x169a10a431130B2F4853294A4a966803668af385' }); [ { \"address\": \"0x169a10a431130B2F4853294A4a966803668af385\", \"blockHash\": \"0x9f18cbbbc432d678b94ee6446e9305abf8f02deb0b03877cc0c71c0a71c08faf\", \"epochNumber\": \"0x0\", \"data\": \"0x\", \"logIndex\": 0, \"removed\": false, \"topics\": [ \"0x44d6d25963f097ad14f29f06854a01f575648a1ef82f30e562ccd3889717e339\", \"0x000000000000000000000000c24a31039a4dfc9ee9039bd9241a0c7848b92ae1\" ], \"transactionHash\": \"0xb777fc8ee9c5b5f6eb2b1c7d73106f07eb1692b9db08d9f65affafb82641559f\", \"transactionIndex\": 0, \"transactionLogIndex\": \"0x0\", \"type\": \"mined\", \"id\": \"log_0x5157483fef4019b6a231963496322bbf123b2559f73eef47f60dd5d1b1364fe4\" }, ... ] ConfluxWeb.cfx.account \u00b6 ConfluxWeb.cfx.account.create \u00b6 Generates an account object with private key and public key. NOTE: compare to eth latest, we don\u2019t have sign methods in the return account object function create(entropy) Parameters \u00b6 Name Type Required Default Description entropy string false A random string to increase entropy. If given it should be at least 32 characters. If none is given a random string will be generated using randomHex. Return \u00b6 object The account object. Example \u00b6 > confluxWeb.cfx.accounts.create(); Account { address: '0xbaE14daA250D6BCE69E695217AE8B3ce1dfF7AAe', privateKey: '0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399', ... } ConfluxWeb.cfx.account.privateKeyToAccount \u00b6 Creates an account object from a private key. NOTE: compare to eth latest, we don\u2019t have sign methods in the return account object function privateKeyToAccount(privateKey) Parameters \u00b6 Name Type Required Default Description privateKey string true The private key to convert. Return \u00b6 object The account object. Example \u00b6 > confluxWeb.cfx.accounts.privateKeyToAccount('0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399'); Account { address: '0xbaE14daA250D6BCE69E695217AE8B3ce1dfF7AAe', privateKey: '0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399', ... } ConfluxWeb.cfx.account.recoverTransaction \u00b6 Recovers the Conflux address which was used to sign the given RLP encoded transaction. function recoverTransaction(rawTransaction) Parameters \u00b6 Name Type Required Default Description rawTransaction string true The RLP encoded transaction. Return \u00b6 string The Conflux address used to sign this transaction. Example \u00b6 > confluxWeb.cfx.accounts.recoverTransaction('0xf867800a825208941ead8630345121d19ee3604128e5dc54b36e8ea6880429d069189e00008001a01feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2a00451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67'); \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\" ConfluxWeb.cfx.account.hashMessage \u00b6 function hashMessage(message) Parameters \u00b6 Name Type Required Default Description message string true A message to hash, if its HEX it will be UTF8 decoded before. Return \u00b6 string The hashed message Example \u00b6 > confluxWeb.cfx.accounts.hashMessage(\"Hello World\"); \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\" > confluxWeb.cfx.accounts.hashMessage(confluxWeb.cfx.utf8ToHex(\"Hello World\")); // the below results in the same hash \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\" ConfluxWeb.cfx.account.sign \u00b6 Signs arbitrary data. This data is before UTF-8 HEX decoded and enveloped as follows: \"\\x19Ethereum Signed Message:\\n\" + message.length + message function sign(data,privateKey) Parameters \u00b6 Name Type Required Default Description data string true The data to sign. privateKey string true The private key to sign with. Return \u00b6 object Example \u00b6 > confluxWeb.cfx.accounts.sign('Hello World', 'a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); { \"message\": \"Hello World\", \"messageHash\": \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\", \"v\": \"0x1b\", \"r\": \"0x14e05a1ff41165dc420414e96acd7710a49ff05eecbd2caf520ac8d2e37426b0\", \"s\": \"0x4236443a89cd5a5d14559bc5c115988b704d40dea7e39ed087ae80cd7822f99c\", \"signature\": \"0x14e05a1ff41165dc420414e96acd7710a49ff05eecbd2caf520ac8d2e37426b04236443a89cd5a5d14559bc5c115988b704d40dea7e39ed087ae80cd7822f99c1b\" } ConfluxWeb.cfx.account.recover \u00b6 Recovers the Conflux address which was used to sign the given data. confluxWeb.cfx.accounts.recover(message, signature [, preFixed]); confluxWeb.cfx.accounts.recover(message, v, r, s [, preFixed]); confluxWeb.cfx.accounts.recover(signatureObject); function recover(message,signature,r,s,v,preFixed,signatureObject) Parameters \u00b6 Name Type Required Default Description message string true signature string true The raw RLP encoded signature, OR parameter 2-4 as v, r, s values. r string true First 32 bytes of the signature s string true Next 32 bytes of the signature v string true Recovery value preFixed boolean false false If the last parameter is true, the given message will NOT automatically be prefixed with \"\\x19Ethereum Signed Message:\\n\" + message.length + message, and assumed to be already prefixed. signatureObject object true signatureObject.messageHash string true The hash of the given message already prefixed with \"\\x19Ethereum Signed Message:\\n\" + message.length + message. signatureObject.r string true same as r signatureObject.s string true same as s signatureObject.v string true same as v Return \u00b6 string The Conflux address used to sign this data. Example \u00b6 > confluxWeb.cfx.accounts.recover({ messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655', v: '0x1', r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029' }) \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" > confluxWeb.cfx.accounts.recover('Some data', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a02901'); // message, signature \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" > confluxWeb.cfx.accounts.recover('Some data', '0x01', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029'); // message, v, r, s \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" ConfluxWeb.cfx.account.wallet \u00b6 ConfluxWeb.cfx.account.wallet.create \u00b6 Generates one or more accounts in the wallet. If wallets already exist they will not be overridden. function create(numberOfAccounts,entropy) Parameters \u00b6 Name Type Required Default Description numberOfAccounts number true Number of accounts to create. Leave empty to create an empty wallet. entropy string false A string with random characters as additional entropy when generating accounts. If given it should be at least 32 characters. Return \u00b6 object The wallet object Example \u00b6 > confluxWeb.cfx.accounts.wallet.create(2); Wallet { ... accounts: { '0': Account { address: '0x52B2a035bbC4263D46a327376195e86dbaAF0b42', privateKey: '0x9887b79bd08ac7ee5897a24c50ee366450edd706cd8cec637cbb91234638d6bb', accounts: [Accounts] }, '1': Account { address: '0x52B2a035bbC4263D46a327376195e86dbaAF0b42', privateKey: '0x9887b79bd08ac7ee5897a24c50ee366450edd706cd8cec637cbb91234638d6bb', accounts: [Accounts] }, }, ... } ConfluxWeb.cfx.account.wallet.add \u00b6 Adds an account using a private key or account object to the wallet. function add(account) Parameters \u00b6 Name Type Required Default Description account string|object true A private key or account object created with confluxWeb.cfx.accounts.create(). Return \u00b6 object The added account Example \u00b6 > confluxWeb.cfx.accounts.wallet.add('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); Account { address: '0x4060E99f892E052dF9F59126D3F1eF2240A5df97', privateKey: 'a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393', ... } ConfluxWeb.cfx.account.wallet.remove \u00b6 Removes an account from the wallet. function remove(address) Parameters \u00b6 Name Type Required Default Description address string|number true The account address, or index in the wallet. Return \u00b6 boolean true if the wallet was removed. false if it couldn\u2019t be found. Example \u00b6 > confluxWeb.cfx.accounts.wallet.remove('0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b'); true > confluxWeb.cfx.accounts.wallet.remove(0); true ConfluxWeb.cfx.account.wallet.clear \u00b6 Securely empties the wallet and removes all its accounts. function clear() Parameters \u00b6 void Return \u00b6 Object The wallet object. Example \u00b6 > confluxWeb.cfx.accounts.wallet.clear(); Wallet { accounts: {}, accountsIndex: 0 ... } ConfluxWeb.cfx.Contract.methods \u00b6 ConfluxWeb.cfx.Contract.methods.encodeABI \u00b6 Encodes the ABI for this method. This can be used to send a transaction, call a method, or pass it into another smart contracts method as arguments. NOTE: contract instance create code see Contract.constructor function encodeABI() Parameters \u00b6 void Return \u00b6 string The encoded ABI byte code to send via a transaction or call. Example \u00b6 > await contract.methods.inc(1).encodeABI(); \"0x812600df0000000000000000000000000000000000000000000000000000000000000001\" > await contract.methods.count().encodeABI(); \"0x06661abd\" ConfluxWeb.cfx.Contract.methods.estimateGas \u00b6 Will call estimate the gas a method execution will take when executed in the EVM without sending any transaction. The estimation can differ from the actual gas used when later sending a transaction, as the state of the smart contract can be different at that time. NOTE: contract instance create code see Contract.constructor async function estimateGas() Parameters \u00b6 void Return \u00b6 Promise.<number> Example \u00b6 > await contract.methods.inc(1).estimateGas(); 26928 > await contract.methods.count().estimateGas(); 21655 ConfluxWeb.cfx.Contract.methods.call \u00b6 Will call a \u201cconstant\u201d method and execute its smart contract method in the EVM without sending any transaction. Note calling can not alter the smart contract state. NOTE: contract instance create code see Contract.constructor async function call() Parameters \u00b6 void Return \u00b6 Promise contract method return value Example \u00b6 > await contract.methods.inc(1).call(); BigNumber { _hex: '0xff' } > await contract.methods.count().call(); BigNumber { _hex: '0xfe' } ConfluxWeb.cfx.Contract.methods.send \u00b6 Will send a transaction to the smart contract and execute its method. Note this can alter the smart contract state. NOTE: contract instance create code see Contract.constructor async function send(options) Parameters \u00b6 Name Type Required Default Description options object true options.from string true The address the transaction should be sent from. options.gasPrice string false contract.defaultGasPrice The gas price in wei to use for this transaction. options.gas number false contract.defaultGas The maximum gas provided for this transaction (gas limit). options.value number|string|BN|BigNumber false The value transferred for the transaction in drip. Return \u00b6 Promise.<string> Transaction hash. Example \u00b6 > await contract.methods.inc(1).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 819 }); \"0xb01101228cbd8619ab1f8f017530ff945b655472be211eb828b31bc7c97b9d5c\" ConfluxWeb.utils \u00b6 ConfluxWeb.utils.randomHex \u00b6 The randomHex library to generate cryptographically strong pseudo-random HEX strings from a given byte size. function randomHex(bytesSize) Parameters \u00b6 Name Type Required Default Description bytesSize number true given byte size Return \u00b6 string The generated random HEX string. Example \u00b6 > confluxWeb.utils.randomHex(32) 0xd3185018552117d2c4b5277307c455b4746267b27ea133abd288c0b136c3865c > confluxWeb.utils.randomHex(4) 0x472ace2a > confluxWeb.utils.randomHex(2) 0x52ed > confluxWeb.utils.randomHex(1) 0x3b > confluxWeb.utils.randomHex(0) 0x ConfluxWeb.utils.isBN \u00b6 Checks if a given value is a BN.js instance. function isBN(bn) Parameters \u00b6 Name Type Required Default Description bn BN true An BN.js instance Return \u00b6 boolean Example \u00b6 > const bn = new BN(10) > confluxWeb.utils.isBN(bn) true ConfluxWeb.utils.sha3 \u00b6 Will calculate the sha3 of the input. function sha3(str) Parameters \u00b6 Name Type Required Default Description str string true A string to hash Return \u00b6 string the result hash. Example \u00b6 > confluxWeb.utils.sha3('234'); \"0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79\" > confluxWeb.utils.keccak256('234'); // alias \"0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79\" ConfluxWeb.utils.soliditySha3 \u00b6 Will calculate the sha3 of given input parameters in the same way solidity would. This means arguments will be ABI converted and tightly packed before being hashed. function soliditySha3(args) Parameters \u00b6 Name Type Required Default Description ...args Array.<(string|number|object|BN)> false Return \u00b6 void Example \u00b6 > confluxWeb.utils.soliditySha3('234564535', '0xfff23243', true, -10); \"0x3e27a893dc40ef8a7f0841d96639de2f58a132be5ae466d40087a2cfa83b7179\" > confluxWeb.utils.soliditySha3('Hello!%'); // auto detects: string \"0x661136a4267dba9ccdf6bfddb7c00e714de936674c4bdb065a531cf1cb15c7fc\" > confluxWeb.utils.soliditySha3('234'); // auto detects: uint256 \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3(0xea); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3(new BN('234')); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3({type: 'uint256', value: '234'}); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3({t: 'uint', v: new BN('234')}); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3('0x407D73d8a49eeb85D32Cf465507dd71d507100c1'); \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'bytes', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // same result as above \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'address', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // same as above, but will do a checksum check, if its multi case \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'bytes32', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // different result as above \"0x3c69a194aaf415ba5d6afca734660d0a3d45acdc05d54cd1ca89a8988e7625b4\" > confluxWeb.utils.soliditySha3({t: 'string', v: 'Hello!%'}, {t: 'int8', v:-23}, {t: 'address', v: '0x85F43D8a49eeB85d32Cf465507DD71d507100C1d'}); \"0xa13b31627c1ed7aaded5aecec71baf02fe123797fffd45e662eac8e06fbe4955\" ConfluxWeb.utils.isHex \u00b6 Checks if a given string is a HEX string. function isHex(hex) Parameters \u00b6 Name Type Required Default Description hex string true The given HEX string. Return \u00b6 boolean Example \u00b6 > confluxWeb.utils.isHex('0xc1912'); true > confluxWeb.utils.isHex(0xc1912); true > confluxWeb.utils.isHex('c1912'); true > confluxWeb.utils.isHex(345); // this is tricky, as 345 can be a a HEX representation or a number, be careful when not having a 0x in front! true > confluxWeb.utils.isHex('0xZ1912'); false > confluxWeb.utils.isHex('Hello'); false ConfluxWeb.utils.isHexStrict \u00b6 Checks if a given string is a HEX string. Difference to isHex() is that it expects HEX to be prefixed with 0x. function isHexStrict(hex) Parameters \u00b6 Name Type Required Default Description hex string true The given HEX string. Return \u00b6 boolean Example \u00b6 > confluxWeb.utils.isHexStrict('0xc1912'); true > confluxWeb.utils.isHexStrict(0xc1912); false > confluxWeb.utils.isHexStrict('c1912'); false > confluxWeb.utils.isHexStrict(345); // this is tricky, as 345 can be a a HEX representation or a number, be careful when not having a 0x in front! false > confluxWeb.utils.isHexStrict('0xZ1912'); false > confluxWeb.utils.isHex('Hello'); false ConfluxWeb.utils.isAddress \u00b6 Checks if a given string is a valid Conflux address. It will also check the checksum, if the address has upper and lowercase letters. function isAddress(address) Parameters \u00b6 Name Type Required Default Description address string true An address string. Return \u00b6 string The checksum address. Example \u00b6 > confluxWeb.utils.isAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d'); true > confluxWeb.utils.isAddress('c1912fee45d61c87cc5ea59dae31190fffff232d'); true > confluxWeb.utils.isAddress('0XC1912FEE45D61C87CC5EA59DAE31190FFFFF232D'); // as all is uppercase, no checksum will be checked true > confluxWeb.utils.isAddress('0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); true > confluxWeb.utils.isAddress('0xC1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); // wrong checksum false ConfluxWeb.utils.toChecksumAddress \u00b6 Will convert an upper or lowercase Conflux address to a checksum address. function toChecksumAddress(address) Parameters \u00b6 Name Type Required Default Description address string true An address string. Return \u00b6 void Example \u00b6 > confluxWeb.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff2323'); \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\" > confluxWeb.utils.toChecksumAddress('0XC1912FEE45D61C87CC5EA59DAE31190FFFFF232D'); // same as above \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\" ConfluxWeb.utils.checkAddressChecksum \u00b6 Checks the checksum of a given address. Will also return false on non-checksum addresses. function checkAddressChecksum(address) Parameters \u00b6 Name Type Required Default Description address string true An address string. Return \u00b6 boolean true when the checksum of the address is valid, false if its not a checksum address, or the checksum is invalid. Example \u00b6 > confluxWeb.utils.checkAddressChecksum('0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); true ConfluxWeb.utils.toHex \u00b6 Will auto convert any given value to HEX. Number strings will interpreted as numbers. Text strings will be interpreted as UTF-8 strings. function toHex(value) Parameters \u00b6 Name Type Required Default Description value string|number|BN|BigNumber true The input to convert to HEX. Return \u00b6 string The resulting HEX string. Example \u00b6 > confluxWeb.utils.toHex('234'); \"0xea\" > confluxWeb.utils.toHex(234); \"0xea\" > confluxWeb.utils.toHex(new BN('234')); \"0xea\" > confluxWeb.utils.toHex(new BigNumber('234')); \"0xea\" > confluxWeb.utils.toHex('I have 100\u20ac'); \"0x49206861766520313030e282ac\" ConfluxWeb.utils.toBN \u00b6 Will safely convert any given value (including BigNumber.js instances) into a BN.js instance, for handling big numbers in JavaScript. NOTE: For just the BN.js class use utils.BN function toBN(num) Parameters \u00b6 Name Type Required Default Description num number|string true Number to convert to a big number. Return \u00b6 BN The BN.js instance. Example \u00b6 > confluxWeb.utils.toBN(1234).toString(); \"1234\" > confluxWeb.utils.toBN('1234').add(confluxWeb.utils.toBN('1')).toString(); \"1235\" > confluxWeb.utils.toBN('0xea').toString(); \"234\" ConfluxWeb.utils.hexToNumber \u00b6 Returns the number representation of a given HEX value. NOTE: This is not useful for big numbers, rather use utils.toBN instead. function hexToNumber(hex) Parameters \u00b6 Name Type Required Default Description hex string true A string to hash. Return \u00b6 number Example \u00b6 > confluxWeb.utils.hexToNumber('0xea'); 234 ConfluxWeb.utils.hexToNumberString \u00b6 Returns the number representation of a given HEX value as a string. function hexToNumberString(hex) Parameters \u00b6 Name Type Required Default Description hex string true A string to hash Return \u00b6 string The number as a string Example \u00b6 > confluxWeb.utils.hexToNumberString('0xea'); \"234\" ConfluxWeb.utils.numberToHex \u00b6 Returns the HEX representation of a given number value. function numberToHex(num) Parameters \u00b6 Name Type Required Default Description num number|string|BN|BigNumber true A number as string or number. Return \u00b6 string The HEX value of the given number. Example \u00b6 > confluxWeb.utils.numberToHex('234'); '0xea' ConfluxWeb.utils.hexToUtf8 \u00b6 Returns the UTF-8 string representation of a given HEX value. function hexToUtf8(hex) Parameters \u00b6 Name Type Required Default Description hex string true A HEX string to convert to a UTF-8 string. Return \u00b6 string The UTF-8 string. Example \u00b6 > confluxWeb.utils.hexToUtf8('0x49206861766520313030e282ac'); \"I have 100\u20ac\" ConfluxWeb.utils.hexToAscii \u00b6 Returns the ASCII string representation of a given HEX value. function hexToAscii(hex) Parameters \u00b6 Name Type Required Default Description hex string true A HEX string to convert to a ASCII string. Return \u00b6 string The ASCII string. Example \u00b6 > confluxWeb.utils.hexToAscii('0x4920686176652031303021'); \"I have 100!\" ConfluxWeb.utils.utf8ToHex \u00b6 Returns the HEX representation of a given UTF-8 string. function utf8ToHex(str) Parameters \u00b6 Name Type Required Default Description str string true A UTF-8 string to convert to a HEX string. Return \u00b6 string The HEX string Example \u00b6 > confluxWeb.utils.utf8ToHex('I have 100\u20ac'); \"0x49206861766520313030e282ac\" ConfluxWeb.utils.asciiToHex \u00b6 Returns the HEX representation of a given ASCII string. NOTE: it behaves differently from 1.2.1 function asciiToHex(str) Parameters \u00b6 Name Type Required Default Description str string true A ASCII string to convert to a HEX string. Return \u00b6 string The HEX string Example \u00b6 > confluxWeb.utils.asciiToHex('I have 100!'); \"0x4920686176652031303021\" ConfluxWeb.utils.hexToBytes \u00b6 Returns a byte array from the given HEX string. NOTE: it behaves differently from 1.2.1 function hexToBytes(hex) Parameters \u00b6 Name Type Required Default Description hex string true A HEX to convert. Return \u00b6 array The byte array. Example \u00b6 > confluxWeb.utils.hexToBytes('0x000000ea'); [ 0, 0, 0, 234 ] > confluxWeb.utils.hexToBytes(0x000000ea); [ 234 ] ConfluxWeb.utils.bytesToHex \u00b6 Returns a HEX string from a byte array. function bytesToHex(byteArray) Parameters \u00b6 Name Type Required Default Description byteArray array true A byte array to convert. Return \u00b6 string The HEX string Example \u00b6 > confluxWeb.utils.bytesToHex([ 72, 101, 108, 108, 111, 33, 36 ]); \"0x48656c6c6f2124\" ConfluxWeb.utils.toDrip \u00b6 Converts any cfx value value into drip. NOTE: \"drip\" are the smallest conflux unit, and you should always make calculations in drip and convert only for display reasons. NOTE: can not pass a Number, only string or BN are acceptable function toDrip(str,unit) Parameters \u00b6 Name Type Required Default Description str string|BN true The value unit string false \"cfx\" The cfx to convert from. Possible units are ['cfx', 'gdrip', 'drip'] Return \u00b6 string|BN If a number, or string is given it returns a number string, otherwise a BN.js instance. Example \u00b6 > confluxWeb.utils.toDrip('1'); \"1000000000000000000\" > confluxWeb.utils.toDrip('1', 'cfx'); \"1000000000000000000\" > confluxWeb.utils.toDrip('1', 'gdrip'); \"1000000000\" > confluxWeb.utils.toDrip('1', 'drip'); \"1\" ConfluxWeb.utils.fromDrip \u00b6 Converts any drip value into a cfx value. NOTE: \"drip\" are the smallest conflux unit, and you should always make calculations in drip and convert only for display reasons. NOTE: can not pass a Number, only string or BN are acceptable function fromDrip(str,unit) Parameters \u00b6 Name Type Required Default Description str string|BN true The value in drip unit string false \"cfx\" The cfx to convert to. Possible units are ['cfx', 'gdrip', 'drip'] Return \u00b6 string|BN If a number, or string is given it returns a number string, otherwise a BN.js instance. Example \u00b6 > confluxWeb.utils.fromDrip('1'); \"0.000000000000000001\" > confluxWeb.utils.fromDrip('1', 'cfx'); \"0.000000000000000001\" > confluxWeb.utils.fromDrip('1', 'gdrip'); \"0.000000001\" > confluxWeb.utils.fromDrip('1', 'gdrip'); \"1\" ConfluxWeb.utils.padLeft \u00b6 Adds a padding on the left of a string, Useful for adding paddings to HEX strings. function padLeft(value,characterAmount,sign) Parameters \u00b6 Name Type Required Default Description value string true The string to add padding on the left. characterAmount number true The number of characters the total string should have. sign string false \"0\" The character sign to use. Return \u00b6 string The padded string. Example \u00b6 > confluxWeb.utils.padLeft('0x3456ff', 20); \"0x000000000000003456ff\" > confluxWeb.utils.padLeft(0x3456ff, 20); \"0x000000000000003456ff\" > confluxWeb.utils.padLeft('Hello', 20, 'x'); \"xxxxxxxxxxxxxxxHello\" ConfluxWeb.utils.padRight \u00b6 Adds a padding on the right of a string, Useful for adding paddings to HEX strings. function padRight(value,characterAmount,sign) Parameters \u00b6 Name Type Required Default Description value string true The string to add padding on the right. characterAmount number true The number of characters the total string should have. sign string false \"0\" The character sign to use. Return \u00b6 string The padded string. Example \u00b6 > confluxWeb.utils.padRight('0x3456ff', 20); \"0x3456ff00000000000000\" > confluxWeb.utils.padRight(0x3456ff, 20); \"0x3456ff00000000000000\" > confluxWeb.utils.padRight('Hello', 20, 'x'); \"Helloxxxxxxxxxxxxxxx\" ConfluxWeb.utils.toTwosComplement \u00b6 Converts a negative numer into a two\u2019s complement. function toTwosComplement(value) Parameters \u00b6 Name Type Required Default Description value number|string|BigNumber true The number to convert. Return \u00b6 string The converted hex string. Example \u00b6 > confluxWeb.utils.toTwosComplement('-1'); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" > confluxWeb.utils.toTwosComplement(-1); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" > confluxWeb.utils.toTwosComplement('0x1'); \"0x0000000000000000000000000000000000000000000000000000000000000001\" > confluxWeb.utils.toTwosComplement(-15); \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1\" > confluxWeb.utils.toTwosComplement('-0x1'); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"","title":"JavaScript API"},{"location":"javascript-api/#getting-started-with-confluxweb","text":"The conflux-web library is a collection of modules which contain specific functionality for the conflux ecosystem. The conflux-web-cfx is for the conflux blockchain and smart contracts. The conflux-web-utils contains useful helper functions for Dapp developers. Adding conflux-web First you need to get conflux-web into your project. This can be done using the following methods: npm: npm install conflux-web After that you need to create a confluxWeb instance and set a provider. Normally you should connect to a remote/local node. const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); That\u2019s it! now you can use the confluxWeb object. Using Promises All of functions use asynchronous HTTP requests and return promises by default: const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); confluxWeb.cfx.getEpochNumber().then(console.log); A note on big numbers You will always get a BigNumber object for number values as JavaScript is not able to handle big numbers correctly. Look at the following examples: \"101010100324325345346456456456456456456\" // \"101010100324325345346456456456456456456\" 101010100324325345346456456456456456456 // 1.0101010032432535e+38 ConfluxWeb depends on the BN.js library for big numbers, See the BN.js documentation for details.","title":"Getting Started with ConfluxWeb"},{"location":"javascript-api/#confluxweb-by-example","text":"","title":"ConfluxWeb by Example"},{"location":"javascript-api/#hash-time-locked-contract","text":"Here we brought you a ConfluxWeb example. You can learn how to develop a Hash Time Locked Contract (HTLC) with ConfluxWeb API.","title":"Hash Time Locked Contract"},{"location":"javascript-api/#confluxweb-api-reference","text":"","title":"ConfluxWeb API Reference"},{"location":"javascript-api/#confluxweb","text":"","title":"ConfluxWeb"},{"location":"javascript-api/#confluxwebproviders","text":"Class attribute object","title":"ConfluxWeb.providers"},{"location":"javascript-api/#example","text":"> ConfluxWeb.providers { HttpProvider: [Function: HttpProvider$1], WebsocketProvider: [Function: WebsocketProvider$1], IpcProvider: [Function: IpcProvider$1] }","title":"Example"},{"location":"javascript-api/#confluxwebmodules","text":"Class attribute object","title":"ConfluxWeb.modules"},{"location":"javascript-api/#example_1","text":"> ConfluxWeb.modules { Cfx: [Function: Cfx], Net: [Function: Net] }","title":"Example"},{"location":"javascript-api/#confluxwebutils","text":"Class attribute Object attribute Property of ConfluxWeb class and instance of ConfluxWeb, See confluxWeb.utils for more. object","title":"ConfluxWeb.utils"},{"location":"javascript-api/#example_2","text":"> ConfluxWeb.utils {...} > confluxWeb.utils {...}","title":"Example"},{"location":"javascript-api/#confluxwebversion","text":"Object attribute current version string","title":"ConfluxWeb.version"},{"location":"javascript-api/#example_3","text":"> confluxWeb.version 0.1.21-alpha.0","title":"Example"},{"location":"javascript-api/#confluxwebcurrentprovider","text":"Object attribute current provider instance object","title":"ConfluxWeb.currentProvider"},{"location":"javascript-api/#example_4","text":"> confluxWeb.currentProvider; HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... }","title":"Example"},{"location":"javascript-api/#confluxwebsetprovider","text":"Will change the provider for its module. NOTE: When called on the umbrella package cfx it will also set the provider for all sub modules confluxWeb.cfx, etc. function setProvider(provider)","title":"ConfluxWeb.setProvider"},{"location":"javascript-api/#parameters","text":"Name Type Required Default Description provider object true A valid provider.","title":"Parameters"},{"location":"javascript-api/#return","text":"boolean","title":"Return"},{"location":"javascript-api/#example_5","text":"> const ConfluxWeb = require('conflux-web'); > const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); > confluxWeb.currentProvider HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... } > confluxWeb.setProvider(new ConfluxWeb.providers.HttpProvider('http://localhost:12537')); true > confluxWeb.currentProvider HttpProvider { host: 'http://localhost:12537' ... } > confluxWeb.setProvider('http://localhost:12537'); // same as above true > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.setProvider('http://localhost:12537') // change all provider > confluxWeb.currentProvider.host \"http://localhost:12537\" > confluxWeb.cfx.currentProvider.host \"http://localhost:12537\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontract","text":"","title":"ConfluxWeb.cfx.Contract"},{"location":"javascript-api/#confluxwebcfxcontractabimodel","text":"abi object Object","title":"ConfluxWeb.cfx.Contract.abiModel"},{"location":"javascript-api/#example_6","text":"> contract.abiModel AbiModel { abi: { methods: { count: [AbiItemModel], '0x06661abd': [AbiItemModel], 'count()': [AbiItemModel], inc: [AbiItemModel], '0x812600df': [AbiItemModel], 'inc(uint256)': [AbiItemModel], contractConstructor: [AbiItemModel] }, events: {} } }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractaddress","text":"The address used for this contract instance. All transactions generated by confluxWeb from this contract will contain this address as the \"to\". string","title":"ConfluxWeb.cfx.Contract.address"},{"location":"javascript-api/#example_7","text":"> contract.address; // What you set when new contract. \"0xf02dbcf0eff48e174ca59f1975a7b0042c4d02b7\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractdefaultgas","text":"The default maximum gas provided for a transaction (gasLimit). number","title":"ConfluxWeb.cfx.Contract.defaultGas"},{"location":"javascript-api/#confluxwebcfxcontractdefaultgasprice","text":"The default gas price in drip to use for transactions. number","title":"ConfluxWeb.cfx.Contract.defaultGasPrice"},{"location":"javascript-api/#confluxwebcfxcontractmethods","text":"Creates a transaction object for that method, which then can be called, send, estimated. The methods of this smart contract are available through: The name: myContract.methods.myMethod(123) The name with parameters: myContract.methods 'myMethod(uint256)' The signature: myContract.methods '0x58cf5f10' This allows calling functions with same name but different parameters from the JavaScript contract object. Proxy","title":"ConfluxWeb.cfx.Contract.methods"},{"location":"javascript-api/#example_8","text":"> contract.address; \"0x079352147ce2de227af6fa963f603a35aed8e601\" > await contract.methods.count().call(); BigNumber { _hex: '0xfe' } > await contract.methods.inc(1).call(); // call will get function return value BigNumber { _hex: '0xff' } > await contract.methods.count().call(); // can not change data in block chain by `call` BigNumber { _hex: '0xfe' } > await contract.methods.inc(1).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 100 }); // send a transaction \"0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a\" > await confluxWeb.cfx.getTransactionReceipt('0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a'); { status: true, ... } > await contract.methods.count().call(); // change data in block chain by `send` BigNumber { _hex: '0xff' }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractconstructor","text":"Creates a new contract instance with all its methods and events defined in its json interface abi object. function constructor(abi,address,options)","title":"ConfluxWeb.cfx.Contract.constructor"},{"location":"javascript-api/#parameters_1","text":"Name Type Required Default Description abi object|array true The abi json interface of the contract. address string false The address where the contract is deployed. If undefined, you should deploy contract by data. options object false options.data string false The byte code of the contract. Used when the contract gets deployed. options.from string false The address transactions should be made from. options.gasPrice string false The gas price in drip to use for transactions. options.gas number false The maximum gas provided for a transaction (gasLimit).","title":"Parameters"},{"location":"javascript-api/#return_1","text":"void","title":"Return"},{"location":"javascript-api/#example_9","text":"> confluxWeb.cfx.accounts.wallet.add('0xa816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY > const contract = new confluxWeb.cfx.Contract( [ { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"name\": \"inc\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" } ], );","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractdeploy","text":"function deploy(options)","title":"ConfluxWeb.cfx.Contract.deploy"},{"location":"javascript-api/#parameters_2","text":"Name Type Required Default Description options object true options.data string false contract data options.arguments array false contract constructor parameters","title":"Parameters"},{"location":"javascript-api/#return_2","text":"Object","title":"Return"},{"location":"javascript-api/#example_10","text":"> await contract.deploy({arguments: [254]}).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 819 }); // deploy contract by `send` \"0x6d1b5d68540faac893e5d5dcfed7fc253a2fd6936634f917c82856a0b19c3838\" > await confluxWeb.cfx.getTransactionReceipt('0xd1d5b66b0d3d215f042f3e4907a3bf0acf5984972527fbca45eb67286835260d'); { status: true, contractCreated: '0x079352147ce2de227af6fa963f603a35aed8e601', ... } > contract.address = '0x079352147ce2de227af6fa963f603a35aed8e601'; // after deploy, you should add address to contract","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractclone","text":"Clones the current contract instance. function clone()","title":"ConfluxWeb.cfx.Contract.clone"},{"location":"javascript-api/#parameters_3","text":"void","title":"Parameters"},{"location":"javascript-api/#return_3","text":"Object The new contract instance.","title":"Return"},{"location":"javascript-api/#example_11","text":"> const clone = contract.clone() > contract.defaultGas === clone.defaultGas; true > contract.defaultGasPrice === clone.defaultGasPrice; true > contract.address === clone.address; // only address difference, and clone one address to be undefined false","title":"Example"},{"location":"javascript-api/#confluxwebcfx","text":"","title":"ConfluxWeb.cfx"},{"location":"javascript-api/#confluxwebcfxdefaultaccount","text":"This default address is used as the default \"from\" property. 20 Bytes: Any Conflux address. You should have the private key for that address in your node or keystore. string|undefined","title":"ConfluxWeb.cfx.defaultAccount"},{"location":"javascript-api/#example_12","text":"> confluxWeb.cfx.defaultAccount undefined > confluxWeb.cfx.defaultAccount = '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b'; > confluxWeb.cfx.defaultAccount \"0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxdefaultepoch","text":"When requests are made that act on the state of conflux, the default epoch parameter determines the height of the epoch. The following options are possible for the default epoch parameter: number : An integer epoch number. \"earliest\" : The earliest epoch where the genesis block in. \"latest_state\" : The latest epoch where the latest block with an executed state in. (default) \"latest_mined\" : The latest epoch where the latest mined block in. number|string","title":"ConfluxWeb.cfx.defaultEpoch"},{"location":"javascript-api/#example_13","text":"> confluxWeb.cfx.defaultEpoch; // Default is \"latest_state\" \"latest_state\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxcurrentprovider","text":"Will return the current provider, otherwise null object|null","title":"ConfluxWeb.cfx.currentProvider"},{"location":"javascript-api/#example_14","text":"> confluxWeb.cfx.currentProvider HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxsetprovider","text":"Will change the provider for its module. function setProvider(cfxProvider)","title":"ConfluxWeb.cfx.setProvider"},{"location":"javascript-api/#parameters_4","text":"Name Type Required Default Description cfxProvider object true A valid provider.","title":"Parameters"},{"location":"javascript-api/#return_4","text":"boolean","title":"Return"},{"location":"javascript-api/#example_15","text":"> confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.setProvider('http://localhost:12537') // change module provider > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://localhost:12537\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetgasprice","text":"Returns the current gas price oracle. The gas price is determined by the last few blocks median gas price. async function getGasPrice()","title":"ConfluxWeb.cfx.getGasPrice"},{"location":"javascript-api/#parameters_5","text":"void","title":"Parameters"},{"location":"javascript-api/#return_5","text":"Promise.<string> Number string of the current gas price in drip.","title":"Return"},{"location":"javascript-api/#example_16","text":"> await confluxWeb.cfx.getGasPrice() \"0\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetepochnumber","text":"Returns the current epoch number the client is on. async function getEpochNumber()","title":"ConfluxWeb.cfx.getEpochNumber"},{"location":"javascript-api/#parameters_6","text":"void","title":"Parameters"},{"location":"javascript-api/#return_6","text":"Promise.<number>","title":"Return"},{"location":"javascript-api/#example_17","text":"> await confluxWeb.cfx.getEpochNumber(); 990902","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetbalance","text":"Get the balance of an address at a given epoch. async function getBalance(address,defaultEpoch)","title":"ConfluxWeb.cfx.getBalance"},{"location":"javascript-api/#parameters_7","text":"Name Type Required Default Description address string true The address to get the balance of. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch.","title":"Parameters"},{"location":"javascript-api/#return_7","text":"Promise.<string> The current balance for the given address in drip.","title":"Return"},{"location":"javascript-api/#example_18","text":"> await confluxWeb.cfx.getBalance(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\"); \"685539999999937000\" > await confluxWeb.cfx.getBalance(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\", \"earliest\"); \"0\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetcode","text":"Get the code at a specific address. async function getCode(address,defaultEpoch)","title":"ConfluxWeb.cfx.getCode"},{"location":"javascript-api/#parameters_8","text":"Name Type Required Default Description address string true The address to get the code from. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch.","title":"Parameters"},{"location":"javascript-api/#return_8","text":"Promise.<string> The data at given address","title":"Return"},{"location":"javascript-api/#example_19","text":"> await confluxWeb.cfx.getCode(\"0x079352147ce2de227af6fa963f603a35aed8e601\"); \"0x6080604052348015600f57600080fd5b506004361060325760003560e01c806306661abd146037578063812600df146053575b600080fd5b603d6092565b6040518082815260200191505060405180910390f35b607c60048036036020811015606757600080fd5b81019080803590602001909291905050506098565b6040518082815260200191505060405180910390f35b60005481565b60008160008082825401925050819055905091905056fea265627a7a723158203aa4346abf52089d9be8806b8bf35dff408bd9f68f668e528bc8e2e20d74b29064736f6c634300050b0032\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetblock","text":"Returns a block matching the block number or block hash. async function getBlock(blockHashOrEpochNumber,returnTransactionObjects)","title":"ConfluxWeb.cfx.getBlock"},{"location":"javascript-api/#parameters_9","text":"Name Type Required Default Description blockHashOrEpochNumber string|number true The block hash or epoch. returnTransactionObjects boolean false false If true, the returned block will contain all transactions as objects, if false it will only contains the transaction hashes.","title":"Parameters"},{"location":"javascript-api/#return_9","text":"Promise.<object> The block object string miner: The address of the beneficiary to whom the mining rewards were given. string|null hash: Hash of the block. null when its pending block. string parentHash: Hash of the parent block. string[] refereeHashes: Array of referee hashes. number|null epochNumber: The current block epoch number in the client's view. null when it's not in best block's past set. boolean stable: If the block stable or not string nonce: Hash of the generated proof-of-work. null when its pending block. number gasLimit: The maximum gas allowed in this block. string difficulty: Integer string of the difficulty for this block. number height: The block heights. null when its pending block. number size: Integer the size of this block in bytes. number blame: 0 if there's nothing to blame; k if the block is blaming on the state info of its k-th ancestor. boolean adaptive: If the block's weight adaptive or not. number timestamp: The unix timestamp for when the block was collated. string transactionsRoot: The hash of the transactions of the block. string[] transactions: Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. string deferredLogsBloomHash: The hash of the deferred block's log bloom filter string deferredReceiptsRoot: The hash of the receipts of the block after deferred execution. string deferredStateRoot: The root of the final state trie of the block after deferred execution. object deferredStateRootWithAux: Information of deferred state root","title":"Return"},{"location":"javascript-api/#example_20","text":"> await confluxWeb.cfx.getBlock(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\"); { \"miner\": \"0x0000000000000000000000000000000000000015\", \"hash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"parentHash\": \"0xa378c9e283c08eac0e2ac51a8c19e61717af812a157eb914d35b171ed20920b9\", \"refereeHashes\": [], \"epochNumber\": 925836, \"stable\": true, \"nonce\": \"0xaaa4a571ad424ec\", \"gasLimit\": 3000000000, \"difficulty\": \"21351313\", \"height\": 925836, \"size\": 384, \"blame\": 0, \"adaptive\": false, \"timestamp\": 1570608173, \"transactionsRoot\": \"0xbe7a9e531d55ed950a217272afa035f57f6c512ca249bae19e214cf2b470562e\" \"transactions\": [ \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\" ], \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xc4ec82320df3b5ce48e22d33cc82f665a274dc920796a3e206be44682b7812a2\", \"deferredStateRootWithAux\": { \"auxInfo\": { \"intermediateDeltaEpochId\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"previousSnapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"stateRoot\": { \"deltaRoot\": \"0xbc71c52f0dae840fd8815de081a2774927077714a5fe7c342b0e5e81f7bcd38e\", \"intermediateDeltaRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"snapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" } }, } > await confluxWeb.cfx.getBlock(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", true); { \"adaptive\": false, \"blame\": 0, \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xc4ec82320df3b5ce48e22d33cc82f665a274dc920796a3e206be44682b7812a2\", \"deferredStateRootWithAux\": { \"auxInfo\": { \"intermediateDeltaEpochId\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"previousSnapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"stateRoot\": { \"deltaRoot\": \"0xbc71c52f0dae840fd8815de081a2774927077714a5fe7c342b0e5e81f7bcd38e\", \"intermediateDeltaRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"snapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" } }, \"difficulty\": \"21351313\", \"epochNumber\": 925836, \"gasLimit\": 3000000000, \"hash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"height\": 925836, \"miner\": \"0x0000000000000000000000000000000000000015\", \"nonce\": \"0xaaa4a571ad424ec\", \"parentHash\": \"0xa378c9e283c08eac0e2ac51a8c19e61717af812a157eb914d35b171ed20920b9\", \"refereeHashes\": [], \"size\": 384, \"stable\": true, \"timestamp\": 1570608173, \"transactions\": [ { \"blockHash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"contractCreated\": null, \"data\": \"0x\", \"from\": \"0xA70ddf9B9750c575Db453Eea6A041f4C8536785A\", \"gas\": 21000, \"gasPrice\": \"819\", \"hash\": \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\", \"nonce\": 921, \"r\": \"0x985743d5d627e8f93e243bfd71e401f7bf5c7b098afeb910952df789312cc7b1\", \"s\": \"0xaaf07bc11d56516f90697fb0f1b8140ec9b252c66e8f3172799e2829d457775\", \"status\": \"0x0\", \"to\": \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\", \"transactionIndex\": 0, \"v\": 1, \"value\": \"1000000000000000000\" } ], \"transactionsRoot\": \"0xbe7a9e531d55ed950a217272afa035f57f6c512ca249bae19e214cf2b470562e\" }","title":"Example"},{"location":"javascript-api/#confluxwebcfxgettransaction","text":"Returns a transaction matching the given transaction hash. async function getTransaction(transactionHash)","title":"ConfluxWeb.cfx.getTransaction"},{"location":"javascript-api/#parameters_10","text":"Name Type Required Default Description transactionHash string true The transaction hash.","title":"Parameters"},{"location":"javascript-api/#return_10","text":"Promise.<object> The transaction object string blockHash: Hash of the block where this transaction was in and got executed. null when its pending. number transactionIndex: Integer of the transactions index position in the block. string hash: Hash of the transaction. number nonce: The number of transactions made by the sender prior to this one. string from: Address of the sender. string to: Address of the receiver. null when its a contract creation transaction. string value: Value transferred in Drip. string data: The data send along with the transaction. number gas: Gas provided by the sender. number gasPrice: Gas price provided by the sender in Drip. string status: '0x0' successful execution; '0x1' exception happened but nonce still increased; '0x2' exception happened and nonce didn't increase. string|null contractCreated: The contract address created, if the transaction was a contract creation, otherwise null. string r: ECDSA signature r string s: ECDSA signature s string v: ECDSA recovery id","title":"Return"},{"location":"javascript-api/#example_21","text":"> await confluxWeb.cfx.getTransaction(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\"); { \"blockHash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"transactionIndex\": 0, \"hash\": \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\", \"nonce\": 921, \"from\": \"0xA70ddf9B9750c575Db453Eea6A041f4C8536785A\", \"to\": \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\", \"value\": \"1000000000000000000\" \"data\": \"0x\", \"gas\": 21000, \"gasPrice\": \"819\", \"status\": \"0x0\", \"contractCreated\": null, \"r\": \"0x985743d5d627e8f93e243bfd71e401f7bf5c7b098afeb910952df789312cc7b1\", \"s\": \"0xaaf07bc11d56516f90697fb0f1b8140ec9b252c66e8f3172799e2829d457775\", \"v\": 1, }","title":"Example"},{"location":"javascript-api/#confluxwebcfxgettransactioncount","text":"Get the numbers of transactions sent from this address. async function getTransactionCount(address,defaultEpoch)","title":"ConfluxWeb.cfx.getTransactionCount"},{"location":"javascript-api/#parameters_11","text":"Name Type Required Default Description address string true The address to get the numbers of transactions from. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch.","title":"Parameters"},{"location":"javascript-api/#return_11","text":"Promise.<number> The number of transactions sent from the given address.","title":"Return"},{"location":"javascript-api/#example_22","text":"> await confluxWeb.cfx.getTransactionCount(\"0xa70ddf9b9750c575db453eea6a041f4c8536785a\"); 974 > await confluxWeb.cfx.getTransactionCount(\"0xa70ddf9b9750c575db453eea6a041f4c8536785a\", 'earliest'); 0","title":"Example"},{"location":"javascript-api/#confluxwebcfxsendsignedtransaction","text":"Sends an already signed transaction, generated for example using confluxWeb.cfx.accounts.signTransaction async function sendSignedTransaction(signedTransactionData)","title":"ConfluxWeb.cfx.sendSignedTransaction"},{"location":"javascript-api/#parameters_12","text":"Name Type Required Default Description signedTransactionData string true Signed transaction data in HEX format","title":"Parameters"},{"location":"javascript-api/#return_12","text":"Promise.<string> Transaction hash","title":"Return"},{"location":"javascript-api/#example_23","text":"> const ConfluxTx = require('confluxjs-transaction'); > const tx = new ConfluxTx({ nonce: '0x03', gasPrice: '0x01', gasLimit: '0x5208', // 21000 to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', // ADDRESS_TO value: '0x01', }); > tx.sign(Buffer.from('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393', 'hex')); // KEY_FROM > await confluxWeb.cfx.sendSignedTransaction('0x' + tx.serialize().toString('hex')); 0x200b930e95b3c8c54978499c6407ef71fc96a83eced88640fae59b75e1d16ef4","title":"Example"},{"location":"javascript-api/#confluxwebcfxsigntransaction","text":"Signs a transaction. This account needs to be unlocked. async function signTransaction(rawTx)","title":"ConfluxWeb.cfx.signTransaction"},{"location":"javascript-api/#parameters_13","text":"Name Type Required Default Description rawTx object true rawTx.from number true An address or index of a local wallet in confluxWeb.cfx.accounts.wallet. rawTx.to string false The destination address of the message, left undefined for a contract-creation transaction. rawTx.value number|string|BN|BigNumber false The value transferred for the transaction in drip, also the endowment if it\u2019s a contract-creation transaction. rawTx.gas number false To-Be-Determined The amount of gas to use for the transaction (unused gas is refunded). rawTx.gasPrice number|string|BN|BigNumber false confluxWeb.cfx.gasPrice The price of gas for this transaction in drip. rawTx.data string false Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code. rawTx.nonce number false Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.","title":"Parameters"},{"location":"javascript-api/#return_13","text":"Promise.<object> The RLP encoded transaction. The raw property can be used to send the transaction using confluxWeb.cfx.sendSignedTransaction. string rawTransaction: Raw transaction string string messageHash: Hash of transaction for calculating signature string r: ECDSA signature r string s: ECDSA signature s string v: ECDSA recovery id","title":"Return"},{"location":"javascript-api/#example_24","text":"> confluxWeb.cfx.accounts.wallet.add('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY_FROM > await confluxWeb.cfx.signTransaction({ from: 0, // index nonce: 0, // make nonce appropriate gasPrice: 10, gas: 21000, value: new BN('300000000000000000'), // 300000000000000000 drip === 0.3 cfx token to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', // ADDRESS_TO data: '', }); { \"messageHash\": \"53aec3cdccb8ab438303ece4559fc4464a118416828d8c7c0427f5debcd8feae\", \"r\": \"0x1feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2\", \"s\": \"0x0451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67\", \"v\": \"0x01\", \"rawTransaction\": \"0xf867800a825208941ead8630345121d19ee3604128e5dc54b36e8ea6880429d069189e00008001a01feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2a00451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67\" }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcall","text":"Executes a message call transaction, which is directly executed in the VM of the node, but never mined into the blockchain. async function call(callObject,defaultEpoch)","title":"ConfluxWeb.cfx.call"},{"location":"javascript-api/#parameters_14","text":"Name Type Required Default Description callObject object true A transaction object, with the difference that for calls the from property is optional as well. defaultEpoch string|number false conflux.cfx.defaultEpoch","title":"Parameters"},{"location":"javascript-api/#return_14","text":"Promise.<string> The returned data of the call, e.g. A smart contract functions return value.","title":"Return"},{"location":"javascript-api/#example_25","text":"> await confluxWeb.cfx.call({ to: \"0x11f4d0a3c12e86b4b5f39b213f7e19d048276dae\", // contract address data: \"0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\" }) 0x000000000000000000000000000000000000000000000000000000000000000a","title":"Example"},{"location":"javascript-api/#confluxwebcfxestimategas","text":"Executes a message call or transaction and returns the amount of the gas used. async function estimateGas(callObject)","title":"ConfluxWeb.cfx.estimateGas"},{"location":"javascript-api/#parameters_15","text":"Name Type Required Default Description callObject object true A transaction object, with the difference that for calls the from property is optional as well.","title":"Parameters"},{"location":"javascript-api/#return_15","text":"Promise.<number> - the used gas for the simulated call/transaction.","title":"Return"},{"location":"javascript-api/#example_26","text":"> await confluxWeb.cfx.estimateGas({ to: \"0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe\", data: \"0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\" }) 0x0000000000000000000000000000000000000000000000000000000000000015","title":"Example"},{"location":"javascript-api/#confluxwebcfxgettransactionreceipt","text":"Returns the receipt of a transaction by transaction hash. NOTE: The receipt is not available for pending transactions and returns null. async function getTransactionReceipt(txHash)","title":"ConfluxWeb.cfx.getTransactionReceipt"},{"location":"javascript-api/#parameters_16","text":"Name Type Required Default Description txHash string true The transaction hash.","title":"Parameters"},{"location":"javascript-api/#return_16","text":"Promise.<object> A transaction receipt object, or null when no receipt was found. boolean status: true if the transaction was successful; false , if the EVM reverted the transaction. number outcomeStatus: 1 status true ; 0 status false . string stateRoot: The state root of transaction execution. number epochNumber: Epoch number where this transaction was in. string blockHash: Hash of the block where this transaction was in. string transactionHash: Hash of the transaction. number index: Integer of the transactions index position in the block. string from: Address of the sender. string to: Address of the receiver. null when its a contract creation transaction. string|null contractCreated: The contract address created, if the transaction was a contract creation, otherwise null. number gasUsed: The amount of gas used by this specific transaction alone. [object] logs: Array of log objects, which this transaction generated. [string] logs[].address: The address of the contract executing at the point of the LOG operation. [string] logs[].topics: The topics associated with the LOG operation. [string] logs[].data: The data associated with the LOG operation. string logsBloom:","title":"Return"},{"location":"javascript-api/#example_27","text":"> await confluxWeb.cfx.getTransactionReceipt('0x689258ba9fe2c25bcdc43ebb5c9018d1b56d25b1c87de1b371a19f5548c16dc1'); { status: true, outcomeStatus: 0, stateRoot: '0x75df853d267b40a98f6fe1103a510822bc1582894e8a9e95eb9ff0697545e4d2', epochNumber: 1017673, blockHash: '0xdefb3add0256b12c80f6e4fddde81da9c93ec88861cbee14051379f79624f911', transactionHash: '0x689258ba9fe2c25bcdc43ebb5c9018d1b56d25b1c87de1b371a19f5548c16dc1', index: 0, from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', contractCreated: null, gasUsed: 21000, logs: [], logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', }","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetpastlogs","text":"Gets past logs, matching the given options. async function getPastLogs(options)","title":"ConfluxWeb.cfx.getPastLogs"},{"location":"javascript-api/#parameters_17","text":"Name Type Required Default Description options object true options.fromEpoch string false The number of the earliest block options.toEpoch string false The number of the latest block options.address string|Array. true An address or a list of addresses to only get logs from particular account(s). options.topics array true An array of values which must each appear in the log entries. The order is important, if you want to leave topics out use null, e.g. [null, '0x12...']. You can also pass an array for each topic with options for that topic e.g. [null, ['option1', 'option2']]","title":"Parameters"},{"location":"javascript-api/#return_17","text":"Promise.<Array.<object>> Array of log objects.","title":"Return"},{"location":"javascript-api/#example_28","text":"> await confluxWeb.cfx.getPastLogs({ fromEpoch: '0x0', toEpoch: 'latest_mined', address: '0x169a10a431130B2F4853294A4a966803668af385' }); [ { \"address\": \"0x169a10a431130B2F4853294A4a966803668af385\", \"blockHash\": \"0x9f18cbbbc432d678b94ee6446e9305abf8f02deb0b03877cc0c71c0a71c08faf\", \"epochNumber\": \"0x0\", \"data\": \"0x\", \"logIndex\": 0, \"removed\": false, \"topics\": [ \"0x44d6d25963f097ad14f29f06854a01f575648a1ef82f30e562ccd3889717e339\", \"0x000000000000000000000000c24a31039a4dfc9ee9039bd9241a0c7848b92ae1\" ], \"transactionHash\": \"0xb777fc8ee9c5b5f6eb2b1c7d73106f07eb1692b9db08d9f65affafb82641559f\", \"transactionIndex\": 0, \"transactionLogIndex\": \"0x0\", \"type\": \"mined\", \"id\": \"log_0x5157483fef4019b6a231963496322bbf123b2559f73eef47f60dd5d1b1364fe4\" }, ... ]","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccount","text":"","title":"ConfluxWeb.cfx.account"},{"location":"javascript-api/#confluxwebcfxaccountcreate","text":"Generates an account object with private key and public key. NOTE: compare to eth latest, we don\u2019t have sign methods in the return account object function create(entropy)","title":"ConfluxWeb.cfx.account.create"},{"location":"javascript-api/#parameters_18","text":"Name Type Required Default Description entropy string false A random string to increase entropy. If given it should be at least 32 characters. If none is given a random string will be generated using randomHex.","title":"Parameters"},{"location":"javascript-api/#return_18","text":"object The account object.","title":"Return"},{"location":"javascript-api/#example_29","text":"> confluxWeb.cfx.accounts.create(); Account { address: '0xbaE14daA250D6BCE69E695217AE8B3ce1dfF7AAe', privateKey: '0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399', ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountprivatekeytoaccount","text":"Creates an account object from a private key. NOTE: compare to eth latest, we don\u2019t have sign methods in the return account object function privateKeyToAccount(privateKey)","title":"ConfluxWeb.cfx.account.privateKeyToAccount"},{"location":"javascript-api/#parameters_19","text":"Name Type Required Default Description privateKey string true The private key to convert.","title":"Parameters"},{"location":"javascript-api/#return_19","text":"object The account object.","title":"Return"},{"location":"javascript-api/#example_30","text":"> confluxWeb.cfx.accounts.privateKeyToAccount('0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399'); Account { address: '0xbaE14daA250D6BCE69E695217AE8B3ce1dfF7AAe', privateKey: '0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399', ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountrecovertransaction","text":"Recovers the Conflux address which was used to sign the given RLP encoded transaction. function recoverTransaction(rawTransaction)","title":"ConfluxWeb.cfx.account.recoverTransaction"},{"location":"javascript-api/#parameters_20","text":"Name Type Required Default Description rawTransaction string true The RLP encoded transaction.","title":"Parameters"},{"location":"javascript-api/#return_20","text":"string The Conflux address used to sign this transaction.","title":"Return"},{"location":"javascript-api/#example_31","text":"> confluxWeb.cfx.accounts.recoverTransaction('0xf867800a825208941ead8630345121d19ee3604128e5dc54b36e8ea6880429d069189e00008001a01feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2a00451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67'); \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccounthashmessage","text":"function hashMessage(message)","title":"ConfluxWeb.cfx.account.hashMessage"},{"location":"javascript-api/#parameters_21","text":"Name Type Required Default Description message string true A message to hash, if its HEX it will be UTF8 decoded before.","title":"Parameters"},{"location":"javascript-api/#return_21","text":"string The hashed message","title":"Return"},{"location":"javascript-api/#example_32","text":"> confluxWeb.cfx.accounts.hashMessage(\"Hello World\"); \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\" > confluxWeb.cfx.accounts.hashMessage(confluxWeb.cfx.utf8ToHex(\"Hello World\")); // the below results in the same hash \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountsign","text":"Signs arbitrary data. This data is before UTF-8 HEX decoded and enveloped as follows: \"\\x19Ethereum Signed Message:\\n\" + message.length + message function sign(data,privateKey)","title":"ConfluxWeb.cfx.account.sign"},{"location":"javascript-api/#parameters_22","text":"Name Type Required Default Description data string true The data to sign. privateKey string true The private key to sign with.","title":"Parameters"},{"location":"javascript-api/#return_22","text":"object","title":"Return"},{"location":"javascript-api/#example_33","text":"> confluxWeb.cfx.accounts.sign('Hello World', 'a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); { \"message\": \"Hello World\", \"messageHash\": \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\", \"v\": \"0x1b\", \"r\": \"0x14e05a1ff41165dc420414e96acd7710a49ff05eecbd2caf520ac8d2e37426b0\", \"s\": \"0x4236443a89cd5a5d14559bc5c115988b704d40dea7e39ed087ae80cd7822f99c\", \"signature\": \"0x14e05a1ff41165dc420414e96acd7710a49ff05eecbd2caf520ac8d2e37426b04236443a89cd5a5d14559bc5c115988b704d40dea7e39ed087ae80cd7822f99c1b\" }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountrecover","text":"Recovers the Conflux address which was used to sign the given data. confluxWeb.cfx.accounts.recover(message, signature [, preFixed]); confluxWeb.cfx.accounts.recover(message, v, r, s [, preFixed]); confluxWeb.cfx.accounts.recover(signatureObject); function recover(message,signature,r,s,v,preFixed,signatureObject)","title":"ConfluxWeb.cfx.account.recover"},{"location":"javascript-api/#parameters_23","text":"Name Type Required Default Description message string true signature string true The raw RLP encoded signature, OR parameter 2-4 as v, r, s values. r string true First 32 bytes of the signature s string true Next 32 bytes of the signature v string true Recovery value preFixed boolean false false If the last parameter is true, the given message will NOT automatically be prefixed with \"\\x19Ethereum Signed Message:\\n\" + message.length + message, and assumed to be already prefixed. signatureObject object true signatureObject.messageHash string true The hash of the given message already prefixed with \"\\x19Ethereum Signed Message:\\n\" + message.length + message. signatureObject.r string true same as r signatureObject.s string true same as s signatureObject.v string true same as v","title":"Parameters"},{"location":"javascript-api/#return_23","text":"string The Conflux address used to sign this data.","title":"Return"},{"location":"javascript-api/#example_34","text":"> confluxWeb.cfx.accounts.recover({ messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655', v: '0x1', r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029' }) \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" > confluxWeb.cfx.accounts.recover('Some data', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a02901'); // message, signature \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" > confluxWeb.cfx.accounts.recover('Some data', '0x01', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029'); // message, v, r, s \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountwallet","text":"","title":"ConfluxWeb.cfx.account.wallet"},{"location":"javascript-api/#confluxwebcfxaccountwalletcreate","text":"Generates one or more accounts in the wallet. If wallets already exist they will not be overridden. function create(numberOfAccounts,entropy)","title":"ConfluxWeb.cfx.account.wallet.create"},{"location":"javascript-api/#parameters_24","text":"Name Type Required Default Description numberOfAccounts number true Number of accounts to create. Leave empty to create an empty wallet. entropy string false A string with random characters as additional entropy when generating accounts. If given it should be at least 32 characters.","title":"Parameters"},{"location":"javascript-api/#return_24","text":"object The wallet object","title":"Return"},{"location":"javascript-api/#example_35","text":"> confluxWeb.cfx.accounts.wallet.create(2); Wallet { ... accounts: { '0': Account { address: '0x52B2a035bbC4263D46a327376195e86dbaAF0b42', privateKey: '0x9887b79bd08ac7ee5897a24c50ee366450edd706cd8cec637cbb91234638d6bb', accounts: [Accounts] }, '1': Account { address: '0x52B2a035bbC4263D46a327376195e86dbaAF0b42', privateKey: '0x9887b79bd08ac7ee5897a24c50ee366450edd706cd8cec637cbb91234638d6bb', accounts: [Accounts] }, }, ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountwalletadd","text":"Adds an account using a private key or account object to the wallet. function add(account)","title":"ConfluxWeb.cfx.account.wallet.add"},{"location":"javascript-api/#parameters_25","text":"Name Type Required Default Description account string|object true A private key or account object created with confluxWeb.cfx.accounts.create().","title":"Parameters"},{"location":"javascript-api/#return_25","text":"object The added account","title":"Return"},{"location":"javascript-api/#example_36","text":"> confluxWeb.cfx.accounts.wallet.add('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); Account { address: '0x4060E99f892E052dF9F59126D3F1eF2240A5df97', privateKey: 'a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393', ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountwalletremove","text":"Removes an account from the wallet. function remove(address)","title":"ConfluxWeb.cfx.account.wallet.remove"},{"location":"javascript-api/#parameters_26","text":"Name Type Required Default Description address string|number true The account address, or index in the wallet.","title":"Parameters"},{"location":"javascript-api/#return_26","text":"boolean true if the wallet was removed. false if it couldn\u2019t be found.","title":"Return"},{"location":"javascript-api/#example_37","text":"> confluxWeb.cfx.accounts.wallet.remove('0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b'); true > confluxWeb.cfx.accounts.wallet.remove(0); true","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountwalletclear","text":"Securely empties the wallet and removes all its accounts. function clear()","title":"ConfluxWeb.cfx.account.wallet.clear"},{"location":"javascript-api/#parameters_27","text":"void","title":"Parameters"},{"location":"javascript-api/#return_27","text":"Object The wallet object.","title":"Return"},{"location":"javascript-api/#example_38","text":"> confluxWeb.cfx.accounts.wallet.clear(); Wallet { accounts: {}, accountsIndex: 0 ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractmethods_1","text":"","title":"ConfluxWeb.cfx.Contract.methods"},{"location":"javascript-api/#confluxwebcfxcontractmethodsencodeabi","text":"Encodes the ABI for this method. This can be used to send a transaction, call a method, or pass it into another smart contracts method as arguments. NOTE: contract instance create code see Contract.constructor function encodeABI()","title":"ConfluxWeb.cfx.Contract.methods.encodeABI"},{"location":"javascript-api/#parameters_28","text":"void","title":"Parameters"},{"location":"javascript-api/#return_28","text":"string The encoded ABI byte code to send via a transaction or call.","title":"Return"},{"location":"javascript-api/#example_39","text":"> await contract.methods.inc(1).encodeABI(); \"0x812600df0000000000000000000000000000000000000000000000000000000000000001\" > await contract.methods.count().encodeABI(); \"0x06661abd\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractmethodsestimategas","text":"Will call estimate the gas a method execution will take when executed in the EVM without sending any transaction. The estimation can differ from the actual gas used when later sending a transaction, as the state of the smart contract can be different at that time. NOTE: contract instance create code see Contract.constructor async function estimateGas()","title":"ConfluxWeb.cfx.Contract.methods.estimateGas"},{"location":"javascript-api/#parameters_29","text":"void","title":"Parameters"},{"location":"javascript-api/#return_29","text":"Promise.<number>","title":"Return"},{"location":"javascript-api/#example_40","text":"> await contract.methods.inc(1).estimateGas(); 26928 > await contract.methods.count().estimateGas(); 21655","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractmethodscall","text":"Will call a \u201cconstant\u201d method and execute its smart contract method in the EVM without sending any transaction. Note calling can not alter the smart contract state. NOTE: contract instance create code see Contract.constructor async function call()","title":"ConfluxWeb.cfx.Contract.methods.call"},{"location":"javascript-api/#parameters_30","text":"void","title":"Parameters"},{"location":"javascript-api/#return_30","text":"Promise contract method return value","title":"Return"},{"location":"javascript-api/#example_41","text":"> await contract.methods.inc(1).call(); BigNumber { _hex: '0xff' } > await contract.methods.count().call(); BigNumber { _hex: '0xfe' }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractmethodssend","text":"Will send a transaction to the smart contract and execute its method. Note this can alter the smart contract state. NOTE: contract instance create code see Contract.constructor async function send(options)","title":"ConfluxWeb.cfx.Contract.methods.send"},{"location":"javascript-api/#parameters_31","text":"Name Type Required Default Description options object true options.from string true The address the transaction should be sent from. options.gasPrice string false contract.defaultGasPrice The gas price in wei to use for this transaction. options.gas number false contract.defaultGas The maximum gas provided for this transaction (gas limit). options.value number|string|BN|BigNumber false The value transferred for the transaction in drip.","title":"Parameters"},{"location":"javascript-api/#return_31","text":"Promise.<string> Transaction hash.","title":"Return"},{"location":"javascript-api/#example_42","text":"> await contract.methods.inc(1).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 819 }); \"0xb01101228cbd8619ab1f8f017530ff945b655472be211eb828b31bc7c97b9d5c\"","title":"Example"},{"location":"javascript-api/#confluxwebutils_1","text":"","title":"ConfluxWeb.utils"},{"location":"javascript-api/#confluxwebutilsrandomhex","text":"The randomHex library to generate cryptographically strong pseudo-random HEX strings from a given byte size. function randomHex(bytesSize)","title":"ConfluxWeb.utils.randomHex"},{"location":"javascript-api/#parameters_32","text":"Name Type Required Default Description bytesSize number true given byte size","title":"Parameters"},{"location":"javascript-api/#return_32","text":"string The generated random HEX string.","title":"Return"},{"location":"javascript-api/#example_43","text":"> confluxWeb.utils.randomHex(32) 0xd3185018552117d2c4b5277307c455b4746267b27ea133abd288c0b136c3865c > confluxWeb.utils.randomHex(4) 0x472ace2a > confluxWeb.utils.randomHex(2) 0x52ed > confluxWeb.utils.randomHex(1) 0x3b > confluxWeb.utils.randomHex(0) 0x","title":"Example"},{"location":"javascript-api/#confluxwebutilsisbn","text":"Checks if a given value is a BN.js instance. function isBN(bn)","title":"ConfluxWeb.utils.isBN"},{"location":"javascript-api/#parameters_33","text":"Name Type Required Default Description bn BN true An BN.js instance","title":"Parameters"},{"location":"javascript-api/#return_33","text":"boolean","title":"Return"},{"location":"javascript-api/#example_44","text":"> const bn = new BN(10) > confluxWeb.utils.isBN(bn) true","title":"Example"},{"location":"javascript-api/#confluxwebutilssha3","text":"Will calculate the sha3 of the input. function sha3(str)","title":"ConfluxWeb.utils.sha3"},{"location":"javascript-api/#parameters_34","text":"Name Type Required Default Description str string true A string to hash","title":"Parameters"},{"location":"javascript-api/#return_34","text":"string the result hash.","title":"Return"},{"location":"javascript-api/#example_45","text":"> confluxWeb.utils.sha3('234'); \"0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79\" > confluxWeb.utils.keccak256('234'); // alias \"0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79\"","title":"Example"},{"location":"javascript-api/#confluxwebutilssoliditysha3","text":"Will calculate the sha3 of given input parameters in the same way solidity would. This means arguments will be ABI converted and tightly packed before being hashed. function soliditySha3(args)","title":"ConfluxWeb.utils.soliditySha3"},{"location":"javascript-api/#parameters_35","text":"Name Type Required Default Description ...args Array.<(string|number|object|BN)> false","title":"Parameters"},{"location":"javascript-api/#return_35","text":"void","title":"Return"},{"location":"javascript-api/#example_46","text":"> confluxWeb.utils.soliditySha3('234564535', '0xfff23243', true, -10); \"0x3e27a893dc40ef8a7f0841d96639de2f58a132be5ae466d40087a2cfa83b7179\" > confluxWeb.utils.soliditySha3('Hello!%'); // auto detects: string \"0x661136a4267dba9ccdf6bfddb7c00e714de936674c4bdb065a531cf1cb15c7fc\" > confluxWeb.utils.soliditySha3('234'); // auto detects: uint256 \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3(0xea); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3(new BN('234')); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3({type: 'uint256', value: '234'}); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3({t: 'uint', v: new BN('234')}); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3('0x407D73d8a49eeb85D32Cf465507dd71d507100c1'); \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'bytes', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // same result as above \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'address', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // same as above, but will do a checksum check, if its multi case \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'bytes32', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // different result as above \"0x3c69a194aaf415ba5d6afca734660d0a3d45acdc05d54cd1ca89a8988e7625b4\" > confluxWeb.utils.soliditySha3({t: 'string', v: 'Hello!%'}, {t: 'int8', v:-23}, {t: 'address', v: '0x85F43D8a49eeB85d32Cf465507DD71d507100C1d'}); \"0xa13b31627c1ed7aaded5aecec71baf02fe123797fffd45e662eac8e06fbe4955\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsishex","text":"Checks if a given string is a HEX string. function isHex(hex)","title":"ConfluxWeb.utils.isHex"},{"location":"javascript-api/#parameters_36","text":"Name Type Required Default Description hex string true The given HEX string.","title":"Parameters"},{"location":"javascript-api/#return_36","text":"boolean","title":"Return"},{"location":"javascript-api/#example_47","text":"> confluxWeb.utils.isHex('0xc1912'); true > confluxWeb.utils.isHex(0xc1912); true > confluxWeb.utils.isHex('c1912'); true > confluxWeb.utils.isHex(345); // this is tricky, as 345 can be a a HEX representation or a number, be careful when not having a 0x in front! true > confluxWeb.utils.isHex('0xZ1912'); false > confluxWeb.utils.isHex('Hello'); false","title":"Example"},{"location":"javascript-api/#confluxwebutilsishexstrict","text":"Checks if a given string is a HEX string. Difference to isHex() is that it expects HEX to be prefixed with 0x. function isHexStrict(hex)","title":"ConfluxWeb.utils.isHexStrict"},{"location":"javascript-api/#parameters_37","text":"Name Type Required Default Description hex string true The given HEX string.","title":"Parameters"},{"location":"javascript-api/#return_37","text":"boolean","title":"Return"},{"location":"javascript-api/#example_48","text":"> confluxWeb.utils.isHexStrict('0xc1912'); true > confluxWeb.utils.isHexStrict(0xc1912); false > confluxWeb.utils.isHexStrict('c1912'); false > confluxWeb.utils.isHexStrict(345); // this is tricky, as 345 can be a a HEX representation or a number, be careful when not having a 0x in front! false > confluxWeb.utils.isHexStrict('0xZ1912'); false > confluxWeb.utils.isHex('Hello'); false","title":"Example"},{"location":"javascript-api/#confluxwebutilsisaddress","text":"Checks if a given string is a valid Conflux address. It will also check the checksum, if the address has upper and lowercase letters. function isAddress(address)","title":"ConfluxWeb.utils.isAddress"},{"location":"javascript-api/#parameters_38","text":"Name Type Required Default Description address string true An address string.","title":"Parameters"},{"location":"javascript-api/#return_38","text":"string The checksum address.","title":"Return"},{"location":"javascript-api/#example_49","text":"> confluxWeb.utils.isAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d'); true > confluxWeb.utils.isAddress('c1912fee45d61c87cc5ea59dae31190fffff232d'); true > confluxWeb.utils.isAddress('0XC1912FEE45D61C87CC5EA59DAE31190FFFFF232D'); // as all is uppercase, no checksum will be checked true > confluxWeb.utils.isAddress('0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); true > confluxWeb.utils.isAddress('0xC1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); // wrong checksum false","title":"Example"},{"location":"javascript-api/#confluxwebutilstochecksumaddress","text":"Will convert an upper or lowercase Conflux address to a checksum address. function toChecksumAddress(address)","title":"ConfluxWeb.utils.toChecksumAddress"},{"location":"javascript-api/#parameters_39","text":"Name Type Required Default Description address string true An address string.","title":"Parameters"},{"location":"javascript-api/#return_39","text":"void","title":"Return"},{"location":"javascript-api/#example_50","text":"> confluxWeb.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff2323'); \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\" > confluxWeb.utils.toChecksumAddress('0XC1912FEE45D61C87CC5EA59DAE31190FFFFF232D'); // same as above \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"","title":"Example"},{"location":"javascript-api/#confluxwebutilscheckaddresschecksum","text":"Checks the checksum of a given address. Will also return false on non-checksum addresses. function checkAddressChecksum(address)","title":"ConfluxWeb.utils.checkAddressChecksum"},{"location":"javascript-api/#parameters_40","text":"Name Type Required Default Description address string true An address string.","title":"Parameters"},{"location":"javascript-api/#return_40","text":"boolean true when the checksum of the address is valid, false if its not a checksum address, or the checksum is invalid.","title":"Return"},{"location":"javascript-api/#example_51","text":"> confluxWeb.utils.checkAddressChecksum('0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); true","title":"Example"},{"location":"javascript-api/#confluxwebutilstohex","text":"Will auto convert any given value to HEX. Number strings will interpreted as numbers. Text strings will be interpreted as UTF-8 strings. function toHex(value)","title":"ConfluxWeb.utils.toHex"},{"location":"javascript-api/#parameters_41","text":"Name Type Required Default Description value string|number|BN|BigNumber true The input to convert to HEX.","title":"Parameters"},{"location":"javascript-api/#return_41","text":"string The resulting HEX string.","title":"Return"},{"location":"javascript-api/#example_52","text":"> confluxWeb.utils.toHex('234'); \"0xea\" > confluxWeb.utils.toHex(234); \"0xea\" > confluxWeb.utils.toHex(new BN('234')); \"0xea\" > confluxWeb.utils.toHex(new BigNumber('234')); \"0xea\" > confluxWeb.utils.toHex('I have 100\u20ac'); \"0x49206861766520313030e282ac\"","title":"Example"},{"location":"javascript-api/#confluxwebutilstobn","text":"Will safely convert any given value (including BigNumber.js instances) into a BN.js instance, for handling big numbers in JavaScript. NOTE: For just the BN.js class use utils.BN function toBN(num)","title":"ConfluxWeb.utils.toBN"},{"location":"javascript-api/#parameters_42","text":"Name Type Required Default Description num number|string true Number to convert to a big number.","title":"Parameters"},{"location":"javascript-api/#return_42","text":"BN The BN.js instance.","title":"Return"},{"location":"javascript-api/#example_53","text":"> confluxWeb.utils.toBN(1234).toString(); \"1234\" > confluxWeb.utils.toBN('1234').add(confluxWeb.utils.toBN('1')).toString(); \"1235\" > confluxWeb.utils.toBN('0xea').toString(); \"234\"","title":"Example"},{"location":"javascript-api/#confluxwebutilshextonumber","text":"Returns the number representation of a given HEX value. NOTE: This is not useful for big numbers, rather use utils.toBN instead. function hexToNumber(hex)","title":"ConfluxWeb.utils.hexToNumber"},{"location":"javascript-api/#parameters_43","text":"Name Type Required Default Description hex string true A string to hash.","title":"Parameters"},{"location":"javascript-api/#return_43","text":"number","title":"Return"},{"location":"javascript-api/#example_54","text":"> confluxWeb.utils.hexToNumber('0xea'); 234","title":"Example"},{"location":"javascript-api/#confluxwebutilshextonumberstring","text":"Returns the number representation of a given HEX value as a string. function hexToNumberString(hex)","title":"ConfluxWeb.utils.hexToNumberString"},{"location":"javascript-api/#parameters_44","text":"Name Type Required Default Description hex string true A string to hash","title":"Parameters"},{"location":"javascript-api/#return_44","text":"string The number as a string","title":"Return"},{"location":"javascript-api/#example_55","text":"> confluxWeb.utils.hexToNumberString('0xea'); \"234\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsnumbertohex","text":"Returns the HEX representation of a given number value. function numberToHex(num)","title":"ConfluxWeb.utils.numberToHex"},{"location":"javascript-api/#parameters_45","text":"Name Type Required Default Description num number|string|BN|BigNumber true A number as string or number.","title":"Parameters"},{"location":"javascript-api/#return_45","text":"string The HEX value of the given number.","title":"Return"},{"location":"javascript-api/#example_56","text":"> confluxWeb.utils.numberToHex('234'); '0xea'","title":"Example"},{"location":"javascript-api/#confluxwebutilshextoutf8","text":"Returns the UTF-8 string representation of a given HEX value. function hexToUtf8(hex)","title":"ConfluxWeb.utils.hexToUtf8"},{"location":"javascript-api/#parameters_46","text":"Name Type Required Default Description hex string true A HEX string to convert to a UTF-8 string.","title":"Parameters"},{"location":"javascript-api/#return_46","text":"string The UTF-8 string.","title":"Return"},{"location":"javascript-api/#example_57","text":"> confluxWeb.utils.hexToUtf8('0x49206861766520313030e282ac'); \"I have 100\u20ac\"","title":"Example"},{"location":"javascript-api/#confluxwebutilshextoascii","text":"Returns the ASCII string representation of a given HEX value. function hexToAscii(hex)","title":"ConfluxWeb.utils.hexToAscii"},{"location":"javascript-api/#parameters_47","text":"Name Type Required Default Description hex string true A HEX string to convert to a ASCII string.","title":"Parameters"},{"location":"javascript-api/#return_47","text":"string The ASCII string.","title":"Return"},{"location":"javascript-api/#example_58","text":"> confluxWeb.utils.hexToAscii('0x4920686176652031303021'); \"I have 100!\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsutf8tohex","text":"Returns the HEX representation of a given UTF-8 string. function utf8ToHex(str)","title":"ConfluxWeb.utils.utf8ToHex"},{"location":"javascript-api/#parameters_48","text":"Name Type Required Default Description str string true A UTF-8 string to convert to a HEX string.","title":"Parameters"},{"location":"javascript-api/#return_48","text":"string The HEX string","title":"Return"},{"location":"javascript-api/#example_59","text":"> confluxWeb.utils.utf8ToHex('I have 100\u20ac'); \"0x49206861766520313030e282ac\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsasciitohex","text":"Returns the HEX representation of a given ASCII string. NOTE: it behaves differently from 1.2.1 function asciiToHex(str)","title":"ConfluxWeb.utils.asciiToHex"},{"location":"javascript-api/#parameters_49","text":"Name Type Required Default Description str string true A ASCII string to convert to a HEX string.","title":"Parameters"},{"location":"javascript-api/#return_49","text":"string The HEX string","title":"Return"},{"location":"javascript-api/#example_60","text":"> confluxWeb.utils.asciiToHex('I have 100!'); \"0x4920686176652031303021\"","title":"Example"},{"location":"javascript-api/#confluxwebutilshextobytes","text":"Returns a byte array from the given HEX string. NOTE: it behaves differently from 1.2.1 function hexToBytes(hex)","title":"ConfluxWeb.utils.hexToBytes"},{"location":"javascript-api/#parameters_50","text":"Name Type Required Default Description hex string true A HEX to convert.","title":"Parameters"},{"location":"javascript-api/#return_50","text":"array The byte array.","title":"Return"},{"location":"javascript-api/#example_61","text":"> confluxWeb.utils.hexToBytes('0x000000ea'); [ 0, 0, 0, 234 ] > confluxWeb.utils.hexToBytes(0x000000ea); [ 234 ]","title":"Example"},{"location":"javascript-api/#confluxwebutilsbytestohex","text":"Returns a HEX string from a byte array. function bytesToHex(byteArray)","title":"ConfluxWeb.utils.bytesToHex"},{"location":"javascript-api/#parameters_51","text":"Name Type Required Default Description byteArray array true A byte array to convert.","title":"Parameters"},{"location":"javascript-api/#return_51","text":"string The HEX string","title":"Return"},{"location":"javascript-api/#example_62","text":"> confluxWeb.utils.bytesToHex([ 72, 101, 108, 108, 111, 33, 36 ]); \"0x48656c6c6f2124\"","title":"Example"},{"location":"javascript-api/#confluxwebutilstodrip","text":"Converts any cfx value value into drip. NOTE: \"drip\" are the smallest conflux unit, and you should always make calculations in drip and convert only for display reasons. NOTE: can not pass a Number, only string or BN are acceptable function toDrip(str,unit)","title":"ConfluxWeb.utils.toDrip"},{"location":"javascript-api/#parameters_52","text":"Name Type Required Default Description str string|BN true The value unit string false \"cfx\" The cfx to convert from. Possible units are ['cfx', 'gdrip', 'drip']","title":"Parameters"},{"location":"javascript-api/#return_52","text":"string|BN If a number, or string is given it returns a number string, otherwise a BN.js instance.","title":"Return"},{"location":"javascript-api/#example_63","text":"> confluxWeb.utils.toDrip('1'); \"1000000000000000000\" > confluxWeb.utils.toDrip('1', 'cfx'); \"1000000000000000000\" > confluxWeb.utils.toDrip('1', 'gdrip'); \"1000000000\" > confluxWeb.utils.toDrip('1', 'drip'); \"1\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsfromdrip","text":"Converts any drip value into a cfx value. NOTE: \"drip\" are the smallest conflux unit, and you should always make calculations in drip and convert only for display reasons. NOTE: can not pass a Number, only string or BN are acceptable function fromDrip(str,unit)","title":"ConfluxWeb.utils.fromDrip"},{"location":"javascript-api/#parameters_53","text":"Name Type Required Default Description str string|BN true The value in drip unit string false \"cfx\" The cfx to convert to. Possible units are ['cfx', 'gdrip', 'drip']","title":"Parameters"},{"location":"javascript-api/#return_53","text":"string|BN If a number, or string is given it returns a number string, otherwise a BN.js instance.","title":"Return"},{"location":"javascript-api/#example_64","text":"> confluxWeb.utils.fromDrip('1'); \"0.000000000000000001\" > confluxWeb.utils.fromDrip('1', 'cfx'); \"0.000000000000000001\" > confluxWeb.utils.fromDrip('1', 'gdrip'); \"0.000000001\" > confluxWeb.utils.fromDrip('1', 'gdrip'); \"1\"","title":"Example"},{"location":"javascript-api/#confluxwebutilspadleft","text":"Adds a padding on the left of a string, Useful for adding paddings to HEX strings. function padLeft(value,characterAmount,sign)","title":"ConfluxWeb.utils.padLeft"},{"location":"javascript-api/#parameters_54","text":"Name Type Required Default Description value string true The string to add padding on the left. characterAmount number true The number of characters the total string should have. sign string false \"0\" The character sign to use.","title":"Parameters"},{"location":"javascript-api/#return_54","text":"string The padded string.","title":"Return"},{"location":"javascript-api/#example_65","text":"> confluxWeb.utils.padLeft('0x3456ff', 20); \"0x000000000000003456ff\" > confluxWeb.utils.padLeft(0x3456ff, 20); \"0x000000000000003456ff\" > confluxWeb.utils.padLeft('Hello', 20, 'x'); \"xxxxxxxxxxxxxxxHello\"","title":"Example"},{"location":"javascript-api/#confluxwebutilspadright","text":"Adds a padding on the right of a string, Useful for adding paddings to HEX strings. function padRight(value,characterAmount,sign)","title":"ConfluxWeb.utils.padRight"},{"location":"javascript-api/#parameters_55","text":"Name Type Required Default Description value string true The string to add padding on the right. characterAmount number true The number of characters the total string should have. sign string false \"0\" The character sign to use.","title":"Parameters"},{"location":"javascript-api/#return_55","text":"string The padded string.","title":"Return"},{"location":"javascript-api/#example_66","text":"> confluxWeb.utils.padRight('0x3456ff', 20); \"0x3456ff00000000000000\" > confluxWeb.utils.padRight(0x3456ff, 20); \"0x3456ff00000000000000\" > confluxWeb.utils.padRight('Hello', 20, 'x'); \"Helloxxxxxxxxxxxxxxx\"","title":"Example"},{"location":"javascript-api/#confluxwebutilstotwoscomplement","text":"Converts a negative numer into a two\u2019s complement. function toTwosComplement(value)","title":"ConfluxWeb.utils.toTwosComplement"},{"location":"javascript-api/#parameters_56","text":"Name Type Required Default Description value number|string|BigNumber true The number to convert.","title":"Parameters"},{"location":"javascript-api/#return_56","text":"string The converted hex string.","title":"Return"},{"location":"javascript-api/#example_67","text":"> confluxWeb.utils.toTwosComplement('-1'); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" > confluxWeb.utils.toTwosComplement(-1); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" > confluxWeb.utils.toTwosComplement('0x1'); \"0x0000000000000000000000000000000000000000000000000000000000000001\" > confluxWeb.utils.toTwosComplement(-15); \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1\" > confluxWeb.utils.toTwosComplement('-0x1'); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"","title":"Example"},{"location":"javascript-example/","text":"Smart Contracts on Conflux Chain \u00b6 This document will show you the way to deploy a smart contract on conflux chain and interact with it. Preparation \u00b6 At the beginning, we should get the bytecode and ABI of the smart contract we want to deploy, check here for more details. Here we use Hash Time Locked Contract(HTLC): const data = '0x608060405234801561001057600080fd5b5060103373ffffffffffffffffffffffffffffffffffffffff167f7067f915d1c61a35abf2d3154544a7d09111584b648bdef0826a3f4f9a19f11a60405160405180910390a3611355806100656000396000f3fe608060405260043610610078576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063335ef5bd1461007d57806363615149146100e957806368ec2294146101465780637249fbb614610195578063bbe4fd50146101e8578063e16c7d9814610213575b600080fd5b6100d36004803603606081101561009357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001909291905050506102f3565b6040518082815260200191505060405180910390f35b3480156100f557600080fd5b5061012c6004803603604081101561010c57600080fd5b8101908080359060200190929190803590602001909291905050506107d7565b604051808215151515815260200191505060405180910390f35b34801561015257600080fd5b5061017f6004803603602081101561016957600080fd5b8101908080359060200190929190505050610cb3565b6040518082815260200191505060405180910390f35b3480156101a157600080fd5b506101ce600480360360208110156101b857600080fd5b8101908080359060200190929190505050610d7b565b604051808215151515815260200191505060405180910390f35b3480156101f457600080fd5b506101fd61119e565b6040518082815260200191505060405180910390f35b34801561021f57600080fd5b5061024c6004803603602081101561023657600080fd5b81019080803590602001909291905050506111a6565b604051808973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200187815260200186815260200185815260200184151515158152602001831515151581526020018281526020019850505050505050505060405180910390f35b6000803411151561036c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f6d73672e76616c7565206d757374206265203e2030000000000000000000000081525060200191505060405180910390fd5b81428111151561040a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001807f74696d656c6f636b2074696d65206d75737420626520696e207468652066757481526020017f757265000000000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b60023386348787604051602001808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401848152602001838152602001828152602001955050505050506040516020818303038152906040526040518082805190602001908083835b6020831015156104f757805182526020820191506020810190506020830392506104d2565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610539573d6000803e3d6000fd5b5050506040513d602081101561054e57600080fd5b8101908080519060200190929190505050915061056a826112bb565b156105dd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260138152602001807f4475706c696361746520636f6e7472616374210000000000000000000000000081525060200191505060405180910390fd5b610100604051908101604052803373ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff168152602001348152602001858152602001848152602001600015158152602001600015158152602001600060010281525060008084815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160020155606082015181600301556080820151816004015560a08201518160050160006101000a81548160ff02191690831515021790555060c08201518160050160016101000a81548160ff02191690831515021790555060e082015181600601559050508473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16837f329a8316ed9c3b2299597538371c2944c5026574e803b1ec31d6113e1cd67bde34888860405180848152602001838152602001828152602001935050505060405180910390a4509392505050565b6000826107e3816112bb565b1515610857576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f636f6e7472616374496420646f6573206e6f742065786973740000000000000081525060200191505060405180910390fd5b8383600281604051602001808281526020019150506040516020818303038152906040526040518082805190602001908083835b6020831015156108b0578051825260208201915060208101905060208303925061088b565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa1580156108f2573d6000803e3d6000fd5b5050506040513d602081101561090757600080fd5b8101908080519060200190929190505050600080848152602001908152602001600020600301541415156109a3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f686173686c6f636b206861736820646f6573206e6f74206d617463680000000081525060200191505060405180910390fd5b853373ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515610a7c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f776974686472617761626c653a206e6f7420726563656976657200000000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160009054906101000a900460ff161515141515610b1a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601f8152602001807f776974686472617761626c653a20616c72656164792077697468647261776e0081525060200191505060405180910390fd5b4260008083815260200190815260200160002060040154111515610bcc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001807f776974686472617761626c653a2074696d656c6f636b2074696d65206d75737481526020017f20626520696e207468652066757475726500000000000000000000000000000081525060400191505060405180910390fd5b6000806000898152602001908152602001600020905086816006018190555060018160050160006101000a81548160ff0219169083151502179055508060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600201549081150290604051600060405180830381858888f19350505050158015610c76573d6000803e3d6000fd5b50877fd6fd4c8e45bf0c70693141c7ce46451b6a6a28ac8386fca2ba914044e0e2391660405160405180910390a260019550505050505092915050565b6000600282604051602001808281526020019150506040516020818303038152906040526040518082805190602001908083835b602083101515610d0c5780518252602082019150602081019050602083039250610ce7565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610d4e573d6000803e3d6000fd5b5050506040513d6020811015610d6357600080fd5b81019080805190602001909291905050509050919050565b600081610d87816112bb565b1515610dfb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f636f6e7472616374496420646f6573206e6f742065786973740000000000000081525060200191505060405180910390fd5b823373ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515610ed4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f726566756e6461626c653a206e6f742073656e6465720000000000000000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160019054906101000a900460ff161515141515610f72576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f726566756e6461626c653a20616c726561647920726566756e6465640000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160009054906101000a900460ff161515141515611010576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f726566756e6461626c653a20616c72656164792077697468647261776e00000081525060200191505060405180910390fd5b4260008083815260200190815260200160002060040154111515156110c3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001807f726566756e6461626c653a2074696d656c6f636b206e6f74207965742070617381526020017f736564000000000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b6000806000868152602001908152602001600020905060018160050160016101000a81548160ff0219169083151502179055508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600201549081150290604051600060405180830381858888f19350505050158015611164573d6000803e3d6000fd5b50847f989b3a845197c9aec15f8982bbb30b5da714050e662a7a287bb1a94c81e2e70e60405160405180910390a260019350505050919050565b600042905090565b600080600080600080600080600015156111bf8a6112bb565b1515141561120057600080600080600080600080879750869650859550846001029450839350806001029050975097509750975097509750975097506112b0565b60008060008b815260200190815260200160002090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168260020154836003015484600401548560050160009054906101000a900460ff168660050160019054906101000a900460ff16876006015487975086965098509850985098509850985098509850505b919395975091939597565b60008073ffffffffffffffffffffffffffffffffffffffff1660008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415905091905056fea165627a7a72305820933970f75b5a7e373d3dcd9b9b46074042159b21a16d450c072e94ab9230d2ec0029'; const abi = [{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_hashlock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"newContract\",\"outputs\":[{\"name\":\"contractId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_preimage\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"bytes32\"}],\"name\":\"getSha256\",\"outputs\":[{\"name\":\"hashvalue\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getContract\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"name\":\"timelock\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"bool\"},{\"name\":\"refunded\",\"type\":\"bool\"},{\"name\":\"preimage\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"LogHTLCNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"Constructed\",\"type\":\"event\"}]; The source code of corresponding Solidity code can be found here: https://github.com/posaggen/confluxWeb-HTLC-Example/blob/master/HashedTimelock.sol We will use this smart contract as example in the rest of this document. Deploy \u00b6 Create a confluxWeb instance and set a proper provider: const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); Add a wallet account using your private key. For new Conflux user, new accounts can be created from official website: https://wallet.confluxscan.io/login const priv_key = '0xdd84f341fb45c764a094d35bf484367b8d2797a997142f9c5cd4d488556f0db7'; const pub_key = '0x81f3521d71990945b99e1c592750d7157f2b544f'; confluxWeb.cfx.accounts.wallet.add(priv_key); Check your balance. For new Conflux users, they can claim some conflux test token at the mainpage of web wallet. ConfluxWeb.cfx.getBalance(pub_key).then(console.log); Construct a contract instance with ABI: const cfx_htlc = new confluxWeb.cfx.Contract(abi); call deploy() method and send the transaction to create contract, get the transaction hash: const tx_hash = await cfx_htlc.deploy({ data: data, }).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); Here, our contract creation transaction has been sent and we should wait for its receipt to make sure the transaction has been confirmed and executed. Following function periodically requests transaction receipt from Conflux chain until it got the receipt whose state root is not empty, which means the transaction has been executed successfully and the state tree has been computed. const sleep = (ms) => { return new Promise(resolve => setTimeout(resolve, ms)); }; async function waitForReceipt(hash) { while (true) { // get receipt let res = await confluxWeb.cfx.getTransactionReceipt(hash); if (res != null) { // make sure state root is already calculated if (res.stateRoot != '0x0000000000000000000000000000000000000000000000000000000000000000') { return res; } } await sleep(10000); } } Retrieve transaction receipt and get the address of the smart contract created in this transaction: const receipt = await waitForReceipt(tx_hash); let cfx_htlc_addr = receipt.contractCreated; Now we have deployed the HTLC successfully. Here is a summary of the code about deploy: async function deployHTLC() { // get contract instance from abi const cfx_htlc = new confluxWeb.cfx.Contract(abi); // deploy contract and send transaction const tx_hash = await cfx_htlc.deploy({ data: data, }).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); // wait for receipt const receipt = await waitForReceipt(tx_hash); return receipt.contractCreated; } Call method \u00b6 In this session, we will fund some money to the HTLC and build a hash timed lock. Firstly, we need to set the hash secret, timelock and amount of conflux: const secret = \"0xc4d2751c52311d0d7efe44e5c4195e058ad5ef4bb89b3e1761b24dc277b132c2\"; const secret_hash = \"0x2bc79b7514884ab00da924607d71542cc4fed3beb8518e747726ae30ab6c7944\"; const timelock = confluxWeb.utils.toHex(BigNumber((new Date()).getTime() + 3600 * 72)); const amount = confluxWeb.utils.toHex(BigNumber(10000000000000000)); // 1e16 = 0.01 cfx(eth) Then we try to interact with the HTLC we deployed just now. To do this, we need to construct a contract instance from the contract address and ABI: const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); Same as above, we call the newContract method and send a transaction, then wait for its receipt. const tx_hash = await cfx_htlc.methods.newContract(pub_key, secret_hash, timelock).send({ from: pub_key, gas: 10000000, gasPrice: 100, value: amount, }); const receipt = await waitForReceipt(tx_hash); After that, we successfully created a new hash timed lock and we can check its id from the events emitted during the execution of the smart contract method: let logs = await confluxWeb.cfx.getPastLogs({ fromEpoch: 'earliest', toEpoch: 'latest_mined', address : cfx_htlc_addr, topics: [confluxWeb.utils.soliditySha3(\"LogHTLCNew(bytes32,address,address,uint256,bytes32,uint256)\")], }); let htlc_id = null; for (let i = 0; i < logs.length; ++i) if (logs[i].transactionHash === tx_hash) htlc_id = logs[i].topics[1]; Summary of the code of this session: async function fund(cfx_htlc_addr) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // call methods newContract() to build a new htlc to pub_key itself const tx_hash = await cfx_htlc.methods.newContract(pub_key, secret_hash, timelock).send({ from: pub_key, gas: 10000000, gasPrice: 100, value: amount, }); const receipt = await waitForReceipt(tx_hash); // get the created hash time lock id from event logs let logs = await confluxWeb.cfx.getPastLogs({ fromEpoch: 'earliest', toEpoch: 'latest_mined', address : cfx_htlc_addr, topics: [confluxWeb.utils.soliditySha3(\"LogHTLCNew(bytes32,address,address,uint256,bytes32,uint256)\")], }); for (let i = 0; i < logs.length; ++i) if (logs[i].transactionHash === tx_hash) return logs[i].topics[1]; } Check \u00b6 We can will use a 'constant' call to getContract method to check the hash timed lock we created, make sure its parameters is correct: // check if created HTLC is valid using a \"constant\" call async function checkHTLC(cfx_htlc_addr, htlc_id) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // make a call to get information of HTLC with htlc_id let c = await cfx_htlc.methods.getContract(htlc_id).call(); // check information if (pub_key !== c[0].toLowerCase() || pub_key !== c[1].toLowerCase() || amount !== confluxWeb.utils.toHex(c[2]) || secret_hash !== c[3] || timelock !== confluxWeb.utils.toHex(c[4]) || c[5] || c[6]) { return false; } return true; } Withdraw \u00b6 Now we want to withdraw the money. Similar to fund, we call withdraw method to do this: async function withdraw(cfx_htlc_addr, htlc_id) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // call methods newContract() to build a new htlc to pub_key itself const tx_hash = await cfx_htlc.methods.withdraw(htlc_id, secret).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); const receipt = await waitForReceipt(tx_hash); return receipt.outcomeStatus; } Summary \u00b6 In this document, we showed the basic ways to use ConfluxWeb library to develop smart contract on Conflux chain, including deployment, interaction, monitoring the events. The summary of the HTLC demo can be found here .","title":"Smart Contracts on Conflux Chain"},{"location":"javascript-example/#smart-contracts-on-conflux-chain","text":"This document will show you the way to deploy a smart contract on conflux chain and interact with it.","title":"Smart Contracts on Conflux Chain"},{"location":"javascript-example/#preparation","text":"At the beginning, we should get the bytecode and ABI of the smart contract we want to deploy, check here for more details. Here we use Hash Time Locked Contract(HTLC): const data = '0x608060405234801561001057600080fd5b5060103373ffffffffffffffffffffffffffffffffffffffff167f7067f915d1c61a35abf2d3154544a7d09111584b648bdef0826a3f4f9a19f11a60405160405180910390a3611355806100656000396000f3fe608060405260043610610078576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063335ef5bd1461007d57806363615149146100e957806368ec2294146101465780637249fbb614610195578063bbe4fd50146101e8578063e16c7d9814610213575b600080fd5b6100d36004803603606081101561009357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001909291905050506102f3565b6040518082815260200191505060405180910390f35b3480156100f557600080fd5b5061012c6004803603604081101561010c57600080fd5b8101908080359060200190929190803590602001909291905050506107d7565b604051808215151515815260200191505060405180910390f35b34801561015257600080fd5b5061017f6004803603602081101561016957600080fd5b8101908080359060200190929190505050610cb3565b6040518082815260200191505060405180910390f35b3480156101a157600080fd5b506101ce600480360360208110156101b857600080fd5b8101908080359060200190929190505050610d7b565b604051808215151515815260200191505060405180910390f35b3480156101f457600080fd5b506101fd61119e565b6040518082815260200191505060405180910390f35b34801561021f57600080fd5b5061024c6004803603602081101561023657600080fd5b81019080803590602001909291905050506111a6565b604051808973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200187815260200186815260200185815260200184151515158152602001831515151581526020018281526020019850505050505050505060405180910390f35b6000803411151561036c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f6d73672e76616c7565206d757374206265203e2030000000000000000000000081525060200191505060405180910390fd5b81428111151561040a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001807f74696d656c6f636b2074696d65206d75737420626520696e207468652066757481526020017f757265000000000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b60023386348787604051602001808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401848152602001838152602001828152602001955050505050506040516020818303038152906040526040518082805190602001908083835b6020831015156104f757805182526020820191506020810190506020830392506104d2565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610539573d6000803e3d6000fd5b5050506040513d602081101561054e57600080fd5b8101908080519060200190929190505050915061056a826112bb565b156105dd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260138152602001807f4475706c696361746520636f6e7472616374210000000000000000000000000081525060200191505060405180910390fd5b610100604051908101604052803373ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff168152602001348152602001858152602001848152602001600015158152602001600015158152602001600060010281525060008084815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160020155606082015181600301556080820151816004015560a08201518160050160006101000a81548160ff02191690831515021790555060c08201518160050160016101000a81548160ff02191690831515021790555060e082015181600601559050508473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16837f329a8316ed9c3b2299597538371c2944c5026574e803b1ec31d6113e1cd67bde34888860405180848152602001838152602001828152602001935050505060405180910390a4509392505050565b6000826107e3816112bb565b1515610857576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f636f6e7472616374496420646f6573206e6f742065786973740000000000000081525060200191505060405180910390fd5b8383600281604051602001808281526020019150506040516020818303038152906040526040518082805190602001908083835b6020831015156108b0578051825260208201915060208101905060208303925061088b565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa1580156108f2573d6000803e3d6000fd5b5050506040513d602081101561090757600080fd5b8101908080519060200190929190505050600080848152602001908152602001600020600301541415156109a3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f686173686c6f636b206861736820646f6573206e6f74206d617463680000000081525060200191505060405180910390fd5b853373ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515610a7c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f776974686472617761626c653a206e6f7420726563656976657200000000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160009054906101000a900460ff161515141515610b1a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601f8152602001807f776974686472617761626c653a20616c72656164792077697468647261776e0081525060200191505060405180910390fd5b4260008083815260200190815260200160002060040154111515610bcc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001807f776974686472617761626c653a2074696d656c6f636b2074696d65206d75737481526020017f20626520696e207468652066757475726500000000000000000000000000000081525060400191505060405180910390fd5b6000806000898152602001908152602001600020905086816006018190555060018160050160006101000a81548160ff0219169083151502179055508060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600201549081150290604051600060405180830381858888f19350505050158015610c76573d6000803e3d6000fd5b50877fd6fd4c8e45bf0c70693141c7ce46451b6a6a28ac8386fca2ba914044e0e2391660405160405180910390a260019550505050505092915050565b6000600282604051602001808281526020019150506040516020818303038152906040526040518082805190602001908083835b602083101515610d0c5780518252602082019150602081019050602083039250610ce7565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610d4e573d6000803e3d6000fd5b5050506040513d6020811015610d6357600080fd5b81019080805190602001909291905050509050919050565b600081610d87816112bb565b1515610dfb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f636f6e7472616374496420646f6573206e6f742065786973740000000000000081525060200191505060405180910390fd5b823373ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515610ed4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f726566756e6461626c653a206e6f742073656e6465720000000000000000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160019054906101000a900460ff161515141515610f72576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f726566756e6461626c653a20616c726561647920726566756e6465640000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160009054906101000a900460ff161515141515611010576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f726566756e6461626c653a20616c72656164792077697468647261776e00000081525060200191505060405180910390fd5b4260008083815260200190815260200160002060040154111515156110c3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001807f726566756e6461626c653a2074696d656c6f636b206e6f74207965742070617381526020017f736564000000000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b6000806000868152602001908152602001600020905060018160050160016101000a81548160ff0219169083151502179055508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600201549081150290604051600060405180830381858888f19350505050158015611164573d6000803e3d6000fd5b50847f989b3a845197c9aec15f8982bbb30b5da714050e662a7a287bb1a94c81e2e70e60405160405180910390a260019350505050919050565b600042905090565b600080600080600080600080600015156111bf8a6112bb565b1515141561120057600080600080600080600080879750869650859550846001029450839350806001029050975097509750975097509750975097506112b0565b60008060008b815260200190815260200160002090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168260020154836003015484600401548560050160009054906101000a900460ff168660050160019054906101000a900460ff16876006015487975086965098509850985098509850985098509850505b919395975091939597565b60008073ffffffffffffffffffffffffffffffffffffffff1660008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415905091905056fea165627a7a72305820933970f75b5a7e373d3dcd9b9b46074042159b21a16d450c072e94ab9230d2ec0029'; const abi = [{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_hashlock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"newContract\",\"outputs\":[{\"name\":\"contractId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_preimage\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"bytes32\"}],\"name\":\"getSha256\",\"outputs\":[{\"name\":\"hashvalue\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getContract\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"name\":\"timelock\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"bool\"},{\"name\":\"refunded\",\"type\":\"bool\"},{\"name\":\"preimage\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"LogHTLCNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"Constructed\",\"type\":\"event\"}]; The source code of corresponding Solidity code can be found here: https://github.com/posaggen/confluxWeb-HTLC-Example/blob/master/HashedTimelock.sol We will use this smart contract as example in the rest of this document.","title":"Preparation"},{"location":"javascript-example/#deploy","text":"Create a confluxWeb instance and set a proper provider: const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); Add a wallet account using your private key. For new Conflux user, new accounts can be created from official website: https://wallet.confluxscan.io/login const priv_key = '0xdd84f341fb45c764a094d35bf484367b8d2797a997142f9c5cd4d488556f0db7'; const pub_key = '0x81f3521d71990945b99e1c592750d7157f2b544f'; confluxWeb.cfx.accounts.wallet.add(priv_key); Check your balance. For new Conflux users, they can claim some conflux test token at the mainpage of web wallet. ConfluxWeb.cfx.getBalance(pub_key).then(console.log); Construct a contract instance with ABI: const cfx_htlc = new confluxWeb.cfx.Contract(abi); call deploy() method and send the transaction to create contract, get the transaction hash: const tx_hash = await cfx_htlc.deploy({ data: data, }).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); Here, our contract creation transaction has been sent and we should wait for its receipt to make sure the transaction has been confirmed and executed. Following function periodically requests transaction receipt from Conflux chain until it got the receipt whose state root is not empty, which means the transaction has been executed successfully and the state tree has been computed. const sleep = (ms) => { return new Promise(resolve => setTimeout(resolve, ms)); }; async function waitForReceipt(hash) { while (true) { // get receipt let res = await confluxWeb.cfx.getTransactionReceipt(hash); if (res != null) { // make sure state root is already calculated if (res.stateRoot != '0x0000000000000000000000000000000000000000000000000000000000000000') { return res; } } await sleep(10000); } } Retrieve transaction receipt and get the address of the smart contract created in this transaction: const receipt = await waitForReceipt(tx_hash); let cfx_htlc_addr = receipt.contractCreated; Now we have deployed the HTLC successfully. Here is a summary of the code about deploy: async function deployHTLC() { // get contract instance from abi const cfx_htlc = new confluxWeb.cfx.Contract(abi); // deploy contract and send transaction const tx_hash = await cfx_htlc.deploy({ data: data, }).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); // wait for receipt const receipt = await waitForReceipt(tx_hash); return receipt.contractCreated; }","title":"Deploy"},{"location":"javascript-example/#call-method","text":"In this session, we will fund some money to the HTLC and build a hash timed lock. Firstly, we need to set the hash secret, timelock and amount of conflux: const secret = \"0xc4d2751c52311d0d7efe44e5c4195e058ad5ef4bb89b3e1761b24dc277b132c2\"; const secret_hash = \"0x2bc79b7514884ab00da924607d71542cc4fed3beb8518e747726ae30ab6c7944\"; const timelock = confluxWeb.utils.toHex(BigNumber((new Date()).getTime() + 3600 * 72)); const amount = confluxWeb.utils.toHex(BigNumber(10000000000000000)); // 1e16 = 0.01 cfx(eth) Then we try to interact with the HTLC we deployed just now. To do this, we need to construct a contract instance from the contract address and ABI: const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); Same as above, we call the newContract method and send a transaction, then wait for its receipt. const tx_hash = await cfx_htlc.methods.newContract(pub_key, secret_hash, timelock).send({ from: pub_key, gas: 10000000, gasPrice: 100, value: amount, }); const receipt = await waitForReceipt(tx_hash); After that, we successfully created a new hash timed lock and we can check its id from the events emitted during the execution of the smart contract method: let logs = await confluxWeb.cfx.getPastLogs({ fromEpoch: 'earliest', toEpoch: 'latest_mined', address : cfx_htlc_addr, topics: [confluxWeb.utils.soliditySha3(\"LogHTLCNew(bytes32,address,address,uint256,bytes32,uint256)\")], }); let htlc_id = null; for (let i = 0; i < logs.length; ++i) if (logs[i].transactionHash === tx_hash) htlc_id = logs[i].topics[1]; Summary of the code of this session: async function fund(cfx_htlc_addr) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // call methods newContract() to build a new htlc to pub_key itself const tx_hash = await cfx_htlc.methods.newContract(pub_key, secret_hash, timelock).send({ from: pub_key, gas: 10000000, gasPrice: 100, value: amount, }); const receipt = await waitForReceipt(tx_hash); // get the created hash time lock id from event logs let logs = await confluxWeb.cfx.getPastLogs({ fromEpoch: 'earliest', toEpoch: 'latest_mined', address : cfx_htlc_addr, topics: [confluxWeb.utils.soliditySha3(\"LogHTLCNew(bytes32,address,address,uint256,bytes32,uint256)\")], }); for (let i = 0; i < logs.length; ++i) if (logs[i].transactionHash === tx_hash) return logs[i].topics[1]; }","title":"Call method"},{"location":"javascript-example/#check","text":"We can will use a 'constant' call to getContract method to check the hash timed lock we created, make sure its parameters is correct: // check if created HTLC is valid using a \"constant\" call async function checkHTLC(cfx_htlc_addr, htlc_id) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // make a call to get information of HTLC with htlc_id let c = await cfx_htlc.methods.getContract(htlc_id).call(); // check information if (pub_key !== c[0].toLowerCase() || pub_key !== c[1].toLowerCase() || amount !== confluxWeb.utils.toHex(c[2]) || secret_hash !== c[3] || timelock !== confluxWeb.utils.toHex(c[4]) || c[5] || c[6]) { return false; } return true; }","title":"Check"},{"location":"javascript-example/#withdraw","text":"Now we want to withdraw the money. Similar to fund, we call withdraw method to do this: async function withdraw(cfx_htlc_addr, htlc_id) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // call methods newContract() to build a new htlc to pub_key itself const tx_hash = await cfx_htlc.methods.withdraw(htlc_id, secret).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); const receipt = await waitForReceipt(tx_hash); return receipt.outcomeStatus; }","title":"Withdraw"},{"location":"javascript-example/#summary","text":"In this document, we showed the basic ways to use ConfluxWeb library to develop smart contract on Conflux chain, including deployment, interaction, monitoring the events. The summary of the HTLC demo can be found here .","title":"Summary"},{"location":"json-rpc/","text":"Conflux JSON-RPC API \u00b6 The Conflux JSON-RPC API is a collection of interfaces which allow you to interact with a local or remote Conflux node, using an HTTP connection in JSON-RPC protocol. The following is an API reference documentation with examples. JSON-RPC \u00b6 JSON is a lightweight data-interchange format. It can represent numbers, strings, ordered sequences of values, and collections of name/value pairs. JSON-RPC is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over HTTP, or in many various message passing environments. It uses JSON (RFC 4627) as data format. JavaScript API \u00b6 There will be a JavaScript library comming soon for you to interact with a Conflux node from inside a JavaScript application, which gives a convenient interface for the RPC methods. JSON-RPC endpoint && support \u00b6 Currently, Conflux has a Rust implementation that supports JSON-RPC 2.0 and HTTP. HEX value encoding \u00b6 At present there are two key datatypes that are passed over JSON: unformatted byte arrays and quantities. Both are passed with a hex encoding, however with different requirements to formatting: When encoding QUANTITIES (integers, numbers): encode as hex, prefix with \"0x\", the most compact representation (slight exception: zero should be represented as \"0x0\"). Examples: 0x41 (65 in decimal) 0x400 (1024 in decimal) WRONG: 0x (should always have at least one digit - zero is \"0x0\") WRONG: 0x0400 (no leading zeroes allowed) WRONG: ff (must be prefixed 0x) When encoding UNFORMATTED DATA (byte arrays, account addresses, hashes, bytecode arrays): encode as hex, prefix with \"0x\", two hex digits per byte. Examples: 0x41 (size 1, \"A\") 0x004200 (size 3, \"\\0B\\0\") 0x (size 0, \"\") WRONG: 0xf0f0f (must be even number of digits) WRONG: 004200 (must be prefixed 0x) The default epoch parameter \u00b6 The following methods have a default epoch parameter: cfx_getTransactionCount cfx_getBalance cfx_getBlockByEpochNumber cfx_epochNumber cfx_getBlocksByEpoch When requests are made that act on the state of conflux, the default epoch parameter determines the height of the epoch. The following options are possible for the default epoch parameter: HEX String - an integer epoch number String \"earliest\" for the earliest epoch where the genesis block in String \"latest_mined\" - for the latest epoch where the latest mined block in String \"latest_state\" - for the latest epoch where the latest block with an executed state in Curl Examples Explained \u00b6 The curl options below might return a response where the node complains about the content type, this is because the --data option sets the content type to application/x-www-form-urlencoded . If your node does complain, manually set the header by placing -H \"Content-Type: application/json\" at the start of the call. The examples also include the URL/IP & port combination which must be the last argument given to curl e.x. http://localhost:12345 Example for cfx_getbestblockhash curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBestBlockHash\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:12345 JSON-RPC methods \u00b6 cfx_getTransactionByHash \u00b6 Returns the information about a transaction requested by transaction hash. Parameters \u00b6 DATA, 32 Bytes - hash of a transaction params: [ '0x88df016429689c079f3b2f6ad39fa052532c56795b733da78a91ebe6a713944b', ] Returns \u00b6 Object - A transaction object, or null when no transaction was found: blockHash : DATA , 32 Bytes - hash of the block where this transaction was in and got executed. null when its pending. data : DATA - the data send along with the transaction. from : DATA , 20 Bytes - address of the sender. gas : QUANTITY - gas provided by the sender. gasPrice : QUANTITY - gas price provided by the sender in Drip. hash : DATA , 32 Bytes - hash of the transaction. nonce : QUANTITY - the number of transactions made by the sender prior to this one. r : DATA , 32 Bytes - ECDSA signature r s : DATA , 32 Bytes - ECDSA signature s to : DATA , 20 Bytes - address of the receiver. null when its a contract creation transaction. transactionIndex : QUANTITY - integer of the transaction's index position in the block. null when its pending. v : QUANTITY - ECDSA recovery id value : QUANTITY - value transferred in Drip. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionByHash\",\"params\":[\"0xc92e7a598f6fe4c091dd604d84b23c5af6f0338d9612c76a1fb06dfdaed548b2\"],\"id\":1}' // Result { \"id\" : 1, \"jsonrpc\" : \"2.0\", \"result\" : { \"s\" : \"0x7dde8fb74652930d390a6dcec61ffef014bed2a30ebab0e9ceedd487959f6964\", \"v\" : \"0x0\", \"gas\" : \"0x5208\", \"data\" : \"0x\", \"blockHash\" : \"0x63d88f4de98e3c324baa4eb146c2cf714d5ecd6554549bbf6a0fc3a17b166a47\", \"gasPrice\" : \"0x1\", \"to\" : \"0x2a2c1a99e1ae7416118e335ac1032902377ce850\", \"r\" : \"0x72f494f114324bda0b0abade293ef529fe22301ea7bf66fdcbf1b399c0189778\", \"transactionIndex\" : \"0x4a\", \"value\" : \"0x1\", \"nonce\" : \"0x2\", \"from\" : \"0x28ca21e860bd91851bfca4406e429f74f09e4be3\", \"hash\" : \"0xc92e7a598f6fe4c091dd604d84b23c5af6f0338d9612c76a1fb06dfdaed548b2\" } } cfx_getBlockByHash \u00b6 Returns information about a block by hash. Parameters \u00b6 DATA , 32 Bytes - Hash of a block. Boolean - If true it returns the full transaction objects, if false only the hashes of the transactions. params: [ '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331', true ] Returns \u00b6 Object - A block object, or null when no block was found: hash : DATA , 32 Bytes - hash of the block. null when its pending block. epochNumber : QUANTITY - the current block epoch number in the client's view. null when it's not in best block's past set. height : QUANTITY - the block heights. null when its pending block. parentHash : DATA , 32 Bytes - hash of the parent block. nonce : DATA , 8 Bytes - hash of the generated proof-of-work. null when its pending block. transactionsRoot : DATA , 32 Bytes - the hash of the transactions of the block. deferredStateRoot : DATA , 32 Bytes - the root of the final state trie of the block after deferred execution. deferredReceiptsRoot : DATA , 32 Bytes - the hash of the receipts of the block after deferred execution. miner : DATA , 20 Bytes - the address of the beneficiary to whom the mining rewards were given. difficulty : QUANTITY - integer of the difficulty for this block. size : QUANTITY - integer the size of this block in bytes. gasLimit : QUANTITY - the maximum gas allowed in this block. timestamp : QUANTITY - the unix timestamp for when the block was collated. transactions : Array - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. refereeHashes : Array - Array of referee hashes. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlockByHash\",\"params\":[\"0x5c641dd7fa7f0dbf486391bd1310f09b6f062ec221f410e5a1bb2c24739b3d94\", false],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"deferredReceiptsRoot\": \"0x602e2c03b2857ae2c9e84c822d1a5b32d0161271096c927b27ca56379cee79eb\", \"deferredStateRoot\": \"0x3a42c10a8dd6bebe914095967b7f5caef472a66ede3e1973118a54934f63d143\", \"difficulty\": \"0x4\", \"epochNumber\": \"0x20\", \"gasLimit\": \"0xb2d05e00\", \"hash\": \"0x5c641dd7fa7f0dbf486391bd1310f09b6f062ec221f410e5a1bb2c24739b3d94\", \"height\": \"0x1d\", \"miner\": \"0x0000000000000000000000000000000000000000\", \"nonce\": \"0x53447d364b6019b\", \"parentHash\": \"0xe64ffb49c8bde64d0fd2916ce9351e485741aac89719e89989fe8f8112801a40\", \"refereeHashes\": [ \"0x431eccfc94c4738b7f560f226a82ca58e9b81bb5aadd3d66acdcab1acc470300\", \"0xe9067a60c14bfc93bbaf78e874be2a25bd948bda3c56fff6ee321d045727ef1f\", \"0x630b40c28974a360840a10268a56be1ca203a45a726e6ca4e04abd4d7523b7cb\", \"0x6cff3a277fc0bf17c359568da27a62f8273753cbcbed6a80b994fc50c8b140b4\" ], \"size\": \"0x0\", \"timestamp\": \"0x0\", \"transactions\": [ \"0x0a39c1048ffccb59ec0df0cb5d17733cb5be219c066bf0035fb6a1e281bfdc77\", \"0xf114b5c01a3b84c8e2389c0d8dc9c1b3fdefe4ac238d224577855373897d4a3a\" ], \"transactionsRoot\": \"0xaed37b3d6c8b0336d42b4b798e1d1f73103de7473f0601736cb95adc3c4b4ea7\" }, \"id\": 1 } cfx_getBlockByEpochNumber \u00b6 Returns information about a block by epoch number. Parameters \u00b6 QUANTITY|TAG - the epoch number, or the string \"latest_mined\", \"latest_state\" or \"earliest\", see the default epoch parameter . Boolean - If true it returns the full transaction objects, if false only the hashes of the transactions. params: [ 'latest_mined', true ] Returns \u00b6 See cfx_getBlockByHash . Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlockByHash\",\"params\":[\"latest_mined\", false],\"id\":1}' Result see cfx_getBlockByHash . cfx_getBestBlockHash \u00b6 Returns the hash of best block. Parameters \u00b6 none Returns \u00b6 DATA , 32 Bytes - hash of the best block. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBestBlockHash\",\"params\":[],\"id\":1}' // Result { \"result\" : \"0x7d54c03f4fe971d5c45d95dddc770a0ec8d5bd27d57c049ce8adc469269e35a4\", \"id\" : 1, \"jsonrpc\" : \"2.0\" } cfx_epochNumber \u00b6 Returns the current epoch number the client is on. Parameters \u00b6 TAG - (optional, default: \"latest_mined\") String \"latest_mined\", \"latest_state\" or \"earliest\", see the default epoch parameter . Returns \u00b6 QUANTITY - integer of the current epoch number the client is on. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_epochNumber\",\"params\":[],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"id\" : 1, \"result\" : \"0x49\" } cfx_gasPrice \u00b6 Returns the current price per gas in Drip. Parameters \u00b6 none Returns \u00b6 QUANTITY - integer of the current gas price in Drip. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_gasPrice\",\"params\":[],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"id\" : 1, \"result\" : \"0x09184e72a000\" } cfx_getBlocksByEpoch \u00b6 Returns hashes of blocks located in some epoch. Parameters \u00b6 QUANTITY|TAG - the epoch number, or the string \"latest_mined\", \"latest_state\" or \"earliest\", see the default epoch parameter . Returns \u00b6 Array - Array of block hashes, sorted by execution(topological) order. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlocksByEpoch\",\"params\":[\"0x11\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": [ \"0x618e813ed93f1020bab13a1ab77e1550da6c89d9c69de837033512e91ac46bd0\", \"0x0f6ac81dcbc612e72e0019681bcec32254a34bd29a6bbab91e5e8dc37ecb64d5\", \"0xad3238c00456adfbf847d251b004c1e306fe637227bb1b9917d77bd5b207af68\", \"0x0f92c2e796be7b016d8b74c6c270fb1851e47fabaca3e464d407544286d6cd34\", \"0x5bcc2b8d2493797fcadf7b80228ef5b713eb9ff65f7cdd86562db629d0caf721\", \"0x7fcdc6fff506b19a2bd72cd3430310915f19a59b046759bb790ba4eeb95e9956\", \"0xf4f33ed08e1c625f4dde608eeb92991d77fff26122bab28a6b3a2037511dcc83\", \"0xa3762adc7f066d5cb62c683c2655be3bc3405ff1397f77d2e1dbeff2d8522e00\", \"0xba7588476a5ec7e0ade00f060180cadb7430fd1be48940414baac48c0d39556d\", \"0xe4dc4541d07118b598b2ec67bbdaa219eb1d649471fe7b5667a0001d83b1e9b6\", \"0x93a15564544c57d6cb68dbdf60133b318a94439e1f0a9ccb331b0f5a0aaf8049\" ], \"id\": 1 } cfx_getBalance \u00b6 Returns the balance of the account of given address. Parameters \u00b6 DATA , 20 Bytes - address to check for balance. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the default epoch parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ] Returns \u00b6 QUANTITY - integer of the current balance in Drip. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBalance\",\"params\":[\"0xc94770007dda54cF92009BFF0dE90c06F603a09f\", \"latest_state\"],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 } cfx_getTransactionCount \u00b6 Returns the number of transactions sent from an address. Parameters \u00b6 DATA , 20 Bytes - address. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the default epoch parameter params: [ '0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8', 'latest_state' // state at the latest executed epoch ] Returns \u00b6 QUANTITY - integer of the number of transactions send from this address. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionCount\",\"params\":[\"0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8\", 'latest_state'],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"result\" : \"0x1\", \"id\" : 1 } cfx_sendRawTransaction \u00b6 Creates new message call transaction or a contract creation for signed transactions. Parameters \u00b6 DATA , The signed transaction data. params: [ '0xf889808609184e72a00082271094000000000000000000000000000000000000000080a47f746573743200000000000000000000000000000000000000000000000000000060005701a08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215f' ] Returns \u00b6 DATA , 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_sendRawTransaction\",\"params\":[{see above}],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x83a610d4a8ebd20dde487f6d02c1d26f6ae8cb2bb4f0b74466a7597ce682077f\" }","title":"JSON-RPC API"},{"location":"json-rpc/#conflux-json-rpc-api","text":"The Conflux JSON-RPC API is a collection of interfaces which allow you to interact with a local or remote Conflux node, using an HTTP connection in JSON-RPC protocol. The following is an API reference documentation with examples.","title":"Conflux JSON-RPC API"},{"location":"json-rpc/#json-rpc","text":"JSON is a lightweight data-interchange format. It can represent numbers, strings, ordered sequences of values, and collections of name/value pairs. JSON-RPC is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over HTTP, or in many various message passing environments. It uses JSON (RFC 4627) as data format.","title":"JSON-RPC"},{"location":"json-rpc/#javascript-api","text":"There will be a JavaScript library comming soon for you to interact with a Conflux node from inside a JavaScript application, which gives a convenient interface for the RPC methods.","title":"JavaScript API"},{"location":"json-rpc/#json-rpc-endpoint-support","text":"Currently, Conflux has a Rust implementation that supports JSON-RPC 2.0 and HTTP.","title":"JSON-RPC endpoint &amp;&amp; support"},{"location":"json-rpc/#hex-value-encoding","text":"At present there are two key datatypes that are passed over JSON: unformatted byte arrays and quantities. Both are passed with a hex encoding, however with different requirements to formatting: When encoding QUANTITIES (integers, numbers): encode as hex, prefix with \"0x\", the most compact representation (slight exception: zero should be represented as \"0x0\"). Examples: 0x41 (65 in decimal) 0x400 (1024 in decimal) WRONG: 0x (should always have at least one digit - zero is \"0x0\") WRONG: 0x0400 (no leading zeroes allowed) WRONG: ff (must be prefixed 0x) When encoding UNFORMATTED DATA (byte arrays, account addresses, hashes, bytecode arrays): encode as hex, prefix with \"0x\", two hex digits per byte. Examples: 0x41 (size 1, \"A\") 0x004200 (size 3, \"\\0B\\0\") 0x (size 0, \"\") WRONG: 0xf0f0f (must be even number of digits) WRONG: 004200 (must be prefixed 0x)","title":"HEX value encoding"},{"location":"json-rpc/#the-default-epoch-parameter","text":"The following methods have a default epoch parameter: cfx_getTransactionCount cfx_getBalance cfx_getBlockByEpochNumber cfx_epochNumber cfx_getBlocksByEpoch When requests are made that act on the state of conflux, the default epoch parameter determines the height of the epoch. The following options are possible for the default epoch parameter: HEX String - an integer epoch number String \"earliest\" for the earliest epoch where the genesis block in String \"latest_mined\" - for the latest epoch where the latest mined block in String \"latest_state\" - for the latest epoch where the latest block with an executed state in","title":"The default epoch parameter"},{"location":"json-rpc/#curl-examples-explained","text":"The curl options below might return a response where the node complains about the content type, this is because the --data option sets the content type to application/x-www-form-urlencoded . If your node does complain, manually set the header by placing -H \"Content-Type: application/json\" at the start of the call. The examples also include the URL/IP & port combination which must be the last argument given to curl e.x. http://localhost:12345 Example for cfx_getbestblockhash curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBestBlockHash\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:12345","title":"Curl Examples Explained"},{"location":"json-rpc/#json-rpc-methods","text":"","title":"JSON-RPC methods"},{"location":"json-rpc/#cfx_gettransactionbyhash","text":"Returns the information about a transaction requested by transaction hash.","title":"cfx_getTransactionByHash"},{"location":"json-rpc/#parameters","text":"DATA, 32 Bytes - hash of a transaction params: [ '0x88df016429689c079f3b2f6ad39fa052532c56795b733da78a91ebe6a713944b', ]","title":"Parameters"},{"location":"json-rpc/#returns","text":"Object - A transaction object, or null when no transaction was found: blockHash : DATA , 32 Bytes - hash of the block where this transaction was in and got executed. null when its pending. data : DATA - the data send along with the transaction. from : DATA , 20 Bytes - address of the sender. gas : QUANTITY - gas provided by the sender. gasPrice : QUANTITY - gas price provided by the sender in Drip. hash : DATA , 32 Bytes - hash of the transaction. nonce : QUANTITY - the number of transactions made by the sender prior to this one. r : DATA , 32 Bytes - ECDSA signature r s : DATA , 32 Bytes - ECDSA signature s to : DATA , 20 Bytes - address of the receiver. null when its a contract creation transaction. transactionIndex : QUANTITY - integer of the transaction's index position in the block. null when its pending. v : QUANTITY - ECDSA recovery id value : QUANTITY - value transferred in Drip.","title":"Returns"},{"location":"json-rpc/#example","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionByHash\",\"params\":[\"0xc92e7a598f6fe4c091dd604d84b23c5af6f0338d9612c76a1fb06dfdaed548b2\"],\"id\":1}' // Result { \"id\" : 1, \"jsonrpc\" : \"2.0\", \"result\" : { \"s\" : \"0x7dde8fb74652930d390a6dcec61ffef014bed2a30ebab0e9ceedd487959f6964\", \"v\" : \"0x0\", \"gas\" : \"0x5208\", \"data\" : \"0x\", \"blockHash\" : \"0x63d88f4de98e3c324baa4eb146c2cf714d5ecd6554549bbf6a0fc3a17b166a47\", \"gasPrice\" : \"0x1\", \"to\" : \"0x2a2c1a99e1ae7416118e335ac1032902377ce850\", \"r\" : \"0x72f494f114324bda0b0abade293ef529fe22301ea7bf66fdcbf1b399c0189778\", \"transactionIndex\" : \"0x4a\", \"value\" : \"0x1\", \"nonce\" : \"0x2\", \"from\" : \"0x28ca21e860bd91851bfca4406e429f74f09e4be3\", \"hash\" : \"0xc92e7a598f6fe4c091dd604d84b23c5af6f0338d9612c76a1fb06dfdaed548b2\" } }","title":"Example"},{"location":"json-rpc/#cfx_getblockbyhash","text":"Returns information about a block by hash.","title":"cfx_getBlockByHash"},{"location":"json-rpc/#parameters_1","text":"DATA , 32 Bytes - Hash of a block. Boolean - If true it returns the full transaction objects, if false only the hashes of the transactions. params: [ '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331', true ]","title":"Parameters"},{"location":"json-rpc/#returns_1","text":"Object - A block object, or null when no block was found: hash : DATA , 32 Bytes - hash of the block. null when its pending block. epochNumber : QUANTITY - the current block epoch number in the client's view. null when it's not in best block's past set. height : QUANTITY - the block heights. null when its pending block. parentHash : DATA , 32 Bytes - hash of the parent block. nonce : DATA , 8 Bytes - hash of the generated proof-of-work. null when its pending block. transactionsRoot : DATA , 32 Bytes - the hash of the transactions of the block. deferredStateRoot : DATA , 32 Bytes - the root of the final state trie of the block after deferred execution. deferredReceiptsRoot : DATA , 32 Bytes - the hash of the receipts of the block after deferred execution. miner : DATA , 20 Bytes - the address of the beneficiary to whom the mining rewards were given. difficulty : QUANTITY - integer of the difficulty for this block. size : QUANTITY - integer the size of this block in bytes. gasLimit : QUANTITY - the maximum gas allowed in this block. timestamp : QUANTITY - the unix timestamp for when the block was collated. transactions : Array - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. refereeHashes : Array - Array of referee hashes.","title":"Returns"},{"location":"json-rpc/#example_1","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlockByHash\",\"params\":[\"0x5c641dd7fa7f0dbf486391bd1310f09b6f062ec221f410e5a1bb2c24739b3d94\", false],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"deferredReceiptsRoot\": \"0x602e2c03b2857ae2c9e84c822d1a5b32d0161271096c927b27ca56379cee79eb\", \"deferredStateRoot\": \"0x3a42c10a8dd6bebe914095967b7f5caef472a66ede3e1973118a54934f63d143\", \"difficulty\": \"0x4\", \"epochNumber\": \"0x20\", \"gasLimit\": \"0xb2d05e00\", \"hash\": \"0x5c641dd7fa7f0dbf486391bd1310f09b6f062ec221f410e5a1bb2c24739b3d94\", \"height\": \"0x1d\", \"miner\": \"0x0000000000000000000000000000000000000000\", \"nonce\": \"0x53447d364b6019b\", \"parentHash\": \"0xe64ffb49c8bde64d0fd2916ce9351e485741aac89719e89989fe8f8112801a40\", \"refereeHashes\": [ \"0x431eccfc94c4738b7f560f226a82ca58e9b81bb5aadd3d66acdcab1acc470300\", \"0xe9067a60c14bfc93bbaf78e874be2a25bd948bda3c56fff6ee321d045727ef1f\", \"0x630b40c28974a360840a10268a56be1ca203a45a726e6ca4e04abd4d7523b7cb\", \"0x6cff3a277fc0bf17c359568da27a62f8273753cbcbed6a80b994fc50c8b140b4\" ], \"size\": \"0x0\", \"timestamp\": \"0x0\", \"transactions\": [ \"0x0a39c1048ffccb59ec0df0cb5d17733cb5be219c066bf0035fb6a1e281bfdc77\", \"0xf114b5c01a3b84c8e2389c0d8dc9c1b3fdefe4ac238d224577855373897d4a3a\" ], \"transactionsRoot\": \"0xaed37b3d6c8b0336d42b4b798e1d1f73103de7473f0601736cb95adc3c4b4ea7\" }, \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getblockbyepochnumber","text":"Returns information about a block by epoch number.","title":"cfx_getBlockByEpochNumber"},{"location":"json-rpc/#parameters_2","text":"QUANTITY|TAG - the epoch number, or the string \"latest_mined\", \"latest_state\" or \"earliest\", see the default epoch parameter . Boolean - If true it returns the full transaction objects, if false only the hashes of the transactions. params: [ 'latest_mined', true ]","title":"Parameters"},{"location":"json-rpc/#returns_2","text":"See cfx_getBlockByHash .","title":"Returns"},{"location":"json-rpc/#example_2","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlockByHash\",\"params\":[\"latest_mined\", false],\"id\":1}' Result see cfx_getBlockByHash .","title":"Example"},{"location":"json-rpc/#cfx_getbestblockhash","text":"Returns the hash of best block.","title":"cfx_getBestBlockHash"},{"location":"json-rpc/#parameters_3","text":"none","title":"Parameters"},{"location":"json-rpc/#returns_3","text":"DATA , 32 Bytes - hash of the best block.","title":"Returns"},{"location":"json-rpc/#example_3","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBestBlockHash\",\"params\":[],\"id\":1}' // Result { \"result\" : \"0x7d54c03f4fe971d5c45d95dddc770a0ec8d5bd27d57c049ce8adc469269e35a4\", \"id\" : 1, \"jsonrpc\" : \"2.0\" }","title":"Example"},{"location":"json-rpc/#cfx_epochnumber","text":"Returns the current epoch number the client is on.","title":"cfx_epochNumber"},{"location":"json-rpc/#parameters_4","text":"TAG - (optional, default: \"latest_mined\") String \"latest_mined\", \"latest_state\" or \"earliest\", see the default epoch parameter .","title":"Parameters"},{"location":"json-rpc/#returns_4","text":"QUANTITY - integer of the current epoch number the client is on.","title":"Returns"},{"location":"json-rpc/#example_4","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_epochNumber\",\"params\":[],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"id\" : 1, \"result\" : \"0x49\" }","title":"Example"},{"location":"json-rpc/#cfx_gasprice","text":"Returns the current price per gas in Drip.","title":"cfx_gasPrice"},{"location":"json-rpc/#parameters_5","text":"none","title":"Parameters"},{"location":"json-rpc/#returns_5","text":"QUANTITY - integer of the current gas price in Drip.","title":"Returns"},{"location":"json-rpc/#example_5","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_gasPrice\",\"params\":[],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"id\" : 1, \"result\" : \"0x09184e72a000\" }","title":"Example"},{"location":"json-rpc/#cfx_getblocksbyepoch","text":"Returns hashes of blocks located in some epoch.","title":"cfx_getBlocksByEpoch"},{"location":"json-rpc/#parameters_6","text":"QUANTITY|TAG - the epoch number, or the string \"latest_mined\", \"latest_state\" or \"earliest\", see the default epoch parameter .","title":"Parameters"},{"location":"json-rpc/#returns_6","text":"Array - Array of block hashes, sorted by execution(topological) order.","title":"Returns"},{"location":"json-rpc/#example_6","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlocksByEpoch\",\"params\":[\"0x11\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": [ \"0x618e813ed93f1020bab13a1ab77e1550da6c89d9c69de837033512e91ac46bd0\", \"0x0f6ac81dcbc612e72e0019681bcec32254a34bd29a6bbab91e5e8dc37ecb64d5\", \"0xad3238c00456adfbf847d251b004c1e306fe637227bb1b9917d77bd5b207af68\", \"0x0f92c2e796be7b016d8b74c6c270fb1851e47fabaca3e464d407544286d6cd34\", \"0x5bcc2b8d2493797fcadf7b80228ef5b713eb9ff65f7cdd86562db629d0caf721\", \"0x7fcdc6fff506b19a2bd72cd3430310915f19a59b046759bb790ba4eeb95e9956\", \"0xf4f33ed08e1c625f4dde608eeb92991d77fff26122bab28a6b3a2037511dcc83\", \"0xa3762adc7f066d5cb62c683c2655be3bc3405ff1397f77d2e1dbeff2d8522e00\", \"0xba7588476a5ec7e0ade00f060180cadb7430fd1be48940414baac48c0d39556d\", \"0xe4dc4541d07118b598b2ec67bbdaa219eb1d649471fe7b5667a0001d83b1e9b6\", \"0x93a15564544c57d6cb68dbdf60133b318a94439e1f0a9ccb331b0f5a0aaf8049\" ], \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getbalance","text":"Returns the balance of the account of given address.","title":"cfx_getBalance"},{"location":"json-rpc/#parameters_7","text":"DATA , 20 Bytes - address to check for balance. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the default epoch parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_7","text":"QUANTITY - integer of the current balance in Drip.","title":"Returns"},{"location":"json-rpc/#example_7","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBalance\",\"params\":[\"0xc94770007dda54cF92009BFF0dE90c06F603a09f\", \"latest_state\"],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 }","title":"Example"},{"location":"json-rpc/#cfx_gettransactioncount","text":"Returns the number of transactions sent from an address.","title":"cfx_getTransactionCount"},{"location":"json-rpc/#parameters_8","text":"DATA , 20 Bytes - address. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the default epoch parameter params: [ '0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8', 'latest_state' // state at the latest executed epoch ]","title":"Parameters"},{"location":"json-rpc/#returns_8","text":"QUANTITY - integer of the number of transactions send from this address.","title":"Returns"},{"location":"json-rpc/#example_8","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionCount\",\"params\":[\"0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8\", 'latest_state'],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"result\" : \"0x1\", \"id\" : 1 }","title":"Example"},{"location":"json-rpc/#cfx_sendrawtransaction","text":"Creates new message call transaction or a contract creation for signed transactions.","title":"cfx_sendRawTransaction"},{"location":"json-rpc/#parameters_9","text":"DATA , The signed transaction data. params: [ '0xf889808609184e72a00082271094000000000000000000000000000000000000000080a47f746573743200000000000000000000000000000000000000000000000000000060005701a08a8bbf888cfa37bbf0bb965423625641fc956967b81d12e23709cead01446075a01ce999b56a8a88504be365442ea61239198e23d1fce7d00fcfc5cd3b44b7215f' ]","title":"Parameters"},{"location":"json-rpc/#returns_9","text":"DATA , 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available.","title":"Returns"},{"location":"json-rpc/#example_9","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_sendRawTransaction\",\"params\":[{see above}],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x83a610d4a8ebd20dde487f6d02c1d26f6ae8cb2bb4f0b74466a7597ce682077f\" }","title":"Example"},{"location":"key_management/","text":"In this document, we go through the process of using command-line interface toolkit to create and manage your key-pair, create and sign your transaction, and submit your transaction to Conflux. Get Key Management Toolkit \u00b6 You can download the key management toolkit of Conflux ( keymgr ) from here . Or you can directly build keymgr from Conflux source code with the following steps. $ git clone ssh://git@base.conflux-chain.org:2222/source/conflux-rust.git $ cd conflux-rust/key_manager/cli $ cargo build The binary of keymgr is then under the folder conflux-rust/key_manager/cli/target/ . Create Key Pair Using KeyMgr \u00b6 You can use keymgr to create your own secret/public key-pair. $ keymgr generate random A sample output is: secret: 074842cdfa28a02fd23f244126618bcb49588a5530e7135dcd8c86aa3fbf0103 public: 7827b388197a9b4c4c97aafff400b1d168439b0b6b2428dad9a8f8ec461789155a9318c7d0d38a2e696e41c99faa0e7f7ab55bc21814b6e7809936f1d51ee5b0 address: 71e177b579a4b1ad24382f4b559f479ca0099572 address is the 160-bit account Id derived from the public key. You can keep privately your secret key at anywhere that only you know. Generate, Sign, and Submit Token Transferring Transaction \u00b6 Conflux provides Javascript library CfxWeb to help user generate transactions in programmable way. The following is a sample code snippet. #!/usr/bin/env node var Tx = require('ethereumjs-tx'); var secretKey = Buffer.from('e331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109', 'hex') var rawTx = { nonce: '0x00', gasPrice: '0x09184e72a000', gasLimit: '0x2710', to: '0x0000000000000000000000000000000000000000', value: '0x00', data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057' } var tx = new Tx(rawTx); tx.sign(secretKey); console.log('0x' + serializedTx.toString('hex')); var Web3 = require('web3'); var web3 = new Web3(); web3.setProvider(new web3.providers.HttpProvider('http://localhost:12345')); let answer = web3.cfx.sendRawTransaction('0x' + serializedTx.toString('hex')); console.log(answer); To run the above code, you need to first install Node.js and CfxWeb.js.","title":"Key management"},{"location":"key_management/#get-key-management-toolkit","text":"You can download the key management toolkit of Conflux ( keymgr ) from here . Or you can directly build keymgr from Conflux source code with the following steps. $ git clone ssh://git@base.conflux-chain.org:2222/source/conflux-rust.git $ cd conflux-rust/key_manager/cli $ cargo build The binary of keymgr is then under the folder conflux-rust/key_manager/cli/target/ .","title":"Get Key Management Toolkit"},{"location":"key_management/#create-key-pair-using-keymgr","text":"You can use keymgr to create your own secret/public key-pair. $ keymgr generate random A sample output is: secret: 074842cdfa28a02fd23f244126618bcb49588a5530e7135dcd8c86aa3fbf0103 public: 7827b388197a9b4c4c97aafff400b1d168439b0b6b2428dad9a8f8ec461789155a9318c7d0d38a2e696e41c99faa0e7f7ab55bc21814b6e7809936f1d51ee5b0 address: 71e177b579a4b1ad24382f4b559f479ca0099572 address is the 160-bit account Id derived from the public key. You can keep privately your secret key at anywhere that only you know.","title":"Create Key Pair Using KeyMgr"},{"location":"key_management/#generate-sign-and-submit-token-transferring-transaction","text":"Conflux provides Javascript library CfxWeb to help user generate transactions in programmable way. The following is a sample code snippet. #!/usr/bin/env node var Tx = require('ethereumjs-tx'); var secretKey = Buffer.from('e331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109', 'hex') var rawTx = { nonce: '0x00', gasPrice: '0x09184e72a000', gasLimit: '0x2710', to: '0x0000000000000000000000000000000000000000', value: '0x00', data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057' } var tx = new Tx(rawTx); tx.sign(secretKey); console.log('0x' + serializedTx.toString('hex')); var Web3 = require('web3'); var web3 = new Web3(); web3.setProvider(new web3.providers.HttpProvider('http://localhost:12345')); let answer = web3.cfx.sendRawTransaction('0x' + serializedTx.toString('hex')); console.log(answer); To run the above code, you need to first install Node.js and CfxWeb.js.","title":"Generate, Sign, and Submit Token Transferring Transaction"},{"location":"overview/","text":"Overview \u00b6","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"sync/","text":"","title":"Sync"},{"location":"trans/","text":"","title":"Trans"}]}