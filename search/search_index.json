{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Conflux \u00b6 The Conflux Testnet is Live! We are excited to annouce the Conflux testnet release to provide developers and users the early access to our technology. Conflux is a next generation pow-based public blockchain system which can achieve throughput with thousands of transactions per second and transaction confirmation latency in minutes. The key that enables its such high performance is its novel consensus mechanism based on the Tree-Graph (TG) blockchain structure. In this testnet release, the main features include: The Tree-Graph based consensus mechanism The account state store with Merkle-Tree based authentication The Javascript and JsonRpc API for fullnode interaction Solidity compatible smart contract ConfluxScan - the block chain explorer A web-based Conflux wallet","title":"Welcome to Conflux"},{"location":"#welcome-to-conflux","text":"The Conflux Testnet is Live! We are excited to annouce the Conflux testnet release to provide developers and users the early access to our technology. Conflux is a next generation pow-based public blockchain system which can achieve throughput with thousands of transactions per second and transaction confirmation latency in minutes. The key that enables its such high performance is its novel consensus mechanism based on the Tree-Graph (TG) blockchain structure. In this testnet release, the main features include: The Tree-Graph based consensus mechanism The account state store with Merkle-Tree based authentication The Javascript and JsonRpc API for fullnode interaction Solidity compatible smart contract ConfluxScan - the block chain explorer A web-based Conflux wallet","title":"Welcome to Conflux"},{"location":"cli/","text":"Conflux CLI Sub-commands \u00b6 Conflux CLI sub-commands is a collection of command line interfaces which allows you to interact with a local or remote Conflux node. Manage Accounts \u00b6 account sub-command allows you to manage accounts at local machine. new \u00b6 Create a new account at local machine. Usage \u00b6 $ ./conflux.exe account new --help conflux.exe-account-new Create a new account (and its associated key) for the given --chain (default conflux). USAGE: conflux.exe account new [OPTIONS] FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --keys-iterations <NUM> Specify the number of iterations to use when deriving key from the password (bigger is more secure). [default: 10240] --password <FILE> Provide a file containing a password for unlocking an account. Leading and trailing whitespace is trimmed. Example \u00b6 ./conflux.exe account new list \u00b6 List all accounts at local machine. Usage \u00b6 $ ./conflux.exe account list --help conflux.exe-account-list List existing accounts of the given --chain (default conflux). USAGE: conflux.exe account list FLAGS: -h, --help Prints help information -V, --version Prints version information Example \u00b6 ./conflux.exe account list import \u00b6 Import accounts from JSON UTC keystore files. Usage \u00b6 $ ./conflux.exe account import --help conflux.exe-account-import Import accounts from JSON UTC keystore files to the specified --chain (default conflux) USAGE: conflux.exe account import --import-path <PATH>... FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --import-path <PATH>... A list of file paths to import. Example \u00b6 ./conflux.exe account import --import-path ./keystores Public APIs \u00b6 Public API allows you to interact with a local or remote Conflux node via HTTP connection in JSON-RPC protocol. All public APIs are under rpc sub-command, and access to the JSON-RPC API at local machine with default url option. OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] To access JSON-RPC API of remote Conflux node, please specify the correct --url option (e.g. http://10.1.5.6:12537). By default, JSON-RPC is enabled only for local access for security consideration. You can manually enable remote access by configuring jsonrpc_http_port in default.toml file. # jsonrpc_tcp_port=12536 jsonrpc_http_port=12537 # jsonrpc_local_tcp_port=12538 jsonrpc_local_http_port=12539 All available commands are as following: $ ./conflux.exe rpc --help conflux.exe-rpc RPC based subcommands to query blockchain information and send transactions USAGE: conflux.exe rpc [OPTIONS] <SUBCOMMAND> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] SUBCOMMANDS: balance Get balance of specified account best-block-hash Get the best block hash block-by-epoch Get block by epoch block-by-hash Get block by hash block-with-assumption Get block by hash with pivot chain assumption blocks Get blocks of specified epoch call Executes a new message call immediately without creating a transaction code Get bytecode of specified contract local Local subcommands (requires jsonrpc_local_http_port configured) epoch Get epoch number estimate-gas Executes a call request immediately without creating a transaction and returns the gas used help Prints this message or the help of the given subcommand(s) nonce Get nonce of specified account price Get recent mean gas price receipt Get receipt by transaction hash send Send a signed transaction and return its hash tx Get transaction by hash Get balance \u00b6 ./conflux.exe rpc balance --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a Get nonce \u00b6 ./conflux.exe rpc nonce --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a Get current epoch number \u00b6 ./conflux.exe rpc epoch Get block(s) \u00b6 Get Best block hash: ./conflux.exe rpc best-block-hash Get block by epoch: ./conflux.exe rpc block-by-epoch --epoch latest_state Get block by hash: ./conflux.exe rpc block-by-epoch --hash 0xf756b4...c0a6d1 Get blocks in epoch: ./conflux.exe rpc blocks --epoch latest_state Get transaction \u00b6 ./conflux.exe rpc tx --hash 0x718532fe76dbd8c4208c6c5a79588db35c0bf97e7d8a0faa5988ba66ad88b74c Get receipt \u00b6 ./conflux.exe rpc receipt --hash 0x718532fe76dbd8c4208c6c5a79588db35c0bf97e7d8a0faa5988ba66ad88b74c Send signed transaction \u00b6 Send a signed transaction which encoded in HEX format. Generally, this API is used for Java-Script API to send encoded transaction. To send a transaction with CLI, suggest to use private API send transaction . ./conflux.exe rpc send --raw-bytes 0x... Misc \u00b6 Get contract code: ./conflux.exe rpc code --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a Get recent mean gas price: ./conflux.exe rpc price Private APIs \u00b6 Private API allows you to interact with local Conflux node only via HTTP connection in JSON-RPC protocol. Private APIs are provided for user to manage the local Conflux node, and requires the jsonrpc_local_http_port configured in default.toml configuration file. In addition, private APIs also helps developers to debug, test, and monitor the runtime of Conflux node. All private APIs are under local sub-command, and access to the JSON-RPC API at local machine with default url option. $ ./conflux.exe rpc local --help conflux.exe-rpc-local Debug subcommands (requires jsonrpc_local_http_port configured) USAGE: conflux.exe rpc local [OPTIONS] <SUBCOMMAND> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] SUBCOMMANDS: consensus-graph-state Get the consensus graph state help Prints this message or the help of the given subcommand(s) net Network subcommands send Send a transaction and return its hash sync-phase Get the current synchronization phase test Test subcommands (used for test purpose only) txpool Transaction pool subcommands net \u00b6 net sub-command helps you to inspect the P2P network status. Examples \u00b6 List all connected P2P nodes: ./conflux.exe rpc local net session List a single P2P node: ./conflux.exe rpc local net session --id <node_id> Check network egress: ./conflux.exe rpc local net throttling txpool \u00b6 txpool sub-command helps you to inspect the transaction pool. Examples \u00b6 List transaction pool status: ./conflux.exe rpc local txpool status List transactions in details: ./conflux.exe rpc local txpool content List summary of transactions: ./conflux.exe rpc local txpool inspect Inspect a transaction in detail: ./conflux.exe rpc local txpool inspect-one --hash <tx_hash> sync-phase \u00b6 Get the synchronization phase of local conflux node. ./conflux.exe rpc local sync-phase Send transaction \u00b6 Send a transaction to local Conflux node. Usage \u00b6 $ ./conflux.exe rpc local send --help conflux.exe-rpc-local-send Send a transaction and return its hash USAGE: conflux.exe rpc local send [OPTIONS] --from <ADDRESS> --password <STRING> --value <HEX> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --data <HEX> Hash of the method signature and encoded parameters --from <ADDRESS> Transaction from address --gas <HEX> Gas provided for transaction execution [default: 0x5208] --gas-price <HEX> Transaction gas price [default: 0x2540BE400] --nonce <HEX> Transaction nonce --password <STRING> Used to decrypt private key of sender to sign transaction --to <ADDRESS> Transaction to address (empty to create contract) --url <url> URL of RPC server [default: http://localhost:12537] --value <HEX> value sent with this transaction Example \u00b6 Alice transfer 5 Drip (1 CFX = 10^18 Drip) to Bob. Note, the address of Alice must exist at local machine, otherwise please create account for alice at first. ./conflux.exe rpc local send --from <alice_address> --to <bob_address> --value 0x5 --password 123456 Alice create a contract with gas 3,000,000. You can use solc to compile contract to get the bytecodes. ./conflux.exe rpc local send --from <alice_address> --value 0x0 --gas 0x\u202d2DC6C0\u202c --data <HEX_contract_bytecodes> --password 123456","title":"CLI Sub-commands"},{"location":"cli/#conflux-cli-sub-commands","text":"Conflux CLI sub-commands is a collection of command line interfaces which allows you to interact with a local or remote Conflux node.","title":"Conflux CLI Sub-commands"},{"location":"cli/#manage-accounts","text":"account sub-command allows you to manage accounts at local machine.","title":"Manage Accounts"},{"location":"cli/#new","text":"Create a new account at local machine.","title":"new"},{"location":"cli/#usage","text":"$ ./conflux.exe account new --help conflux.exe-account-new Create a new account (and its associated key) for the given --chain (default conflux). USAGE: conflux.exe account new [OPTIONS] FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --keys-iterations <NUM> Specify the number of iterations to use when deriving key from the password (bigger is more secure). [default: 10240] --password <FILE> Provide a file containing a password for unlocking an account. Leading and trailing whitespace is trimmed.","title":"Usage"},{"location":"cli/#example","text":"./conflux.exe account new","title":"Example"},{"location":"cli/#list","text":"List all accounts at local machine.","title":"list"},{"location":"cli/#usage_1","text":"$ ./conflux.exe account list --help conflux.exe-account-list List existing accounts of the given --chain (default conflux). USAGE: conflux.exe account list FLAGS: -h, --help Prints help information -V, --version Prints version information","title":"Usage"},{"location":"cli/#example_1","text":"./conflux.exe account list","title":"Example"},{"location":"cli/#import","text":"Import accounts from JSON UTC keystore files.","title":"import"},{"location":"cli/#usage_2","text":"$ ./conflux.exe account import --help conflux.exe-account-import Import accounts from JSON UTC keystore files to the specified --chain (default conflux) USAGE: conflux.exe account import --import-path <PATH>... FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --import-path <PATH>... A list of file paths to import.","title":"Usage"},{"location":"cli/#example_2","text":"./conflux.exe account import --import-path ./keystores","title":"Example"},{"location":"cli/#public-apis","text":"Public API allows you to interact with a local or remote Conflux node via HTTP connection in JSON-RPC protocol. All public APIs are under rpc sub-command, and access to the JSON-RPC API at local machine with default url option. OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] To access JSON-RPC API of remote Conflux node, please specify the correct --url option (e.g. http://10.1.5.6:12537). By default, JSON-RPC is enabled only for local access for security consideration. You can manually enable remote access by configuring jsonrpc_http_port in default.toml file. # jsonrpc_tcp_port=12536 jsonrpc_http_port=12537 # jsonrpc_local_tcp_port=12538 jsonrpc_local_http_port=12539 All available commands are as following: $ ./conflux.exe rpc --help conflux.exe-rpc RPC based subcommands to query blockchain information and send transactions USAGE: conflux.exe rpc [OPTIONS] <SUBCOMMAND> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] SUBCOMMANDS: balance Get balance of specified account best-block-hash Get the best block hash block-by-epoch Get block by epoch block-by-hash Get block by hash block-with-assumption Get block by hash with pivot chain assumption blocks Get blocks of specified epoch call Executes a new message call immediately without creating a transaction code Get bytecode of specified contract local Local subcommands (requires jsonrpc_local_http_port configured) epoch Get epoch number estimate-gas Executes a call request immediately without creating a transaction and returns the gas used help Prints this message or the help of the given subcommand(s) nonce Get nonce of specified account price Get recent mean gas price receipt Get receipt by transaction hash send Send a signed transaction and return its hash tx Get transaction by hash","title":"Public APIs"},{"location":"cli/#get-balance","text":"./conflux.exe rpc balance --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a","title":"Get balance"},{"location":"cli/#get-nonce","text":"./conflux.exe rpc nonce --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a","title":"Get nonce"},{"location":"cli/#get-current-epoch-number","text":"./conflux.exe rpc epoch","title":"Get current epoch number"},{"location":"cli/#get-blocks","text":"Get Best block hash: ./conflux.exe rpc best-block-hash Get block by epoch: ./conflux.exe rpc block-by-epoch --epoch latest_state Get block by hash: ./conflux.exe rpc block-by-epoch --hash 0xf756b4...c0a6d1 Get blocks in epoch: ./conflux.exe rpc blocks --epoch latest_state","title":"Get block(s)"},{"location":"cli/#get-transaction","text":"./conflux.exe rpc tx --hash 0x718532fe76dbd8c4208c6c5a79588db35c0bf97e7d8a0faa5988ba66ad88b74c","title":"Get transaction"},{"location":"cli/#get-receipt","text":"./conflux.exe rpc receipt --hash 0x718532fe76dbd8c4208c6c5a79588db35c0bf97e7d8a0faa5988ba66ad88b74c","title":"Get receipt"},{"location":"cli/#send-signed-transaction","text":"Send a signed transaction which encoded in HEX format. Generally, this API is used for Java-Script API to send encoded transaction. To send a transaction with CLI, suggest to use private API send transaction . ./conflux.exe rpc send --raw-bytes 0x...","title":"Send signed transaction"},{"location":"cli/#misc","text":"Get contract code: ./conflux.exe rpc code --address 0xa70ddf9b9750c575db453eea6a041f4c8536785a Get recent mean gas price: ./conflux.exe rpc price","title":"Misc"},{"location":"cli/#private-apis","text":"Private API allows you to interact with local Conflux node only via HTTP connection in JSON-RPC protocol. Private APIs are provided for user to manage the local Conflux node, and requires the jsonrpc_local_http_port configured in default.toml configuration file. In addition, private APIs also helps developers to debug, test, and monitor the runtime of Conflux node. All private APIs are under local sub-command, and access to the JSON-RPC API at local machine with default url option. $ ./conflux.exe rpc local --help conflux.exe-rpc-local Debug subcommands (requires jsonrpc_local_http_port configured) USAGE: conflux.exe rpc local [OPTIONS] <SUBCOMMAND> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --url <url> URL of RPC server [default: http://localhost:12539] SUBCOMMANDS: consensus-graph-state Get the consensus graph state help Prints this message or the help of the given subcommand(s) net Network subcommands send Send a transaction and return its hash sync-phase Get the current synchronization phase test Test subcommands (used for test purpose only) txpool Transaction pool subcommands","title":"Private APIs"},{"location":"cli/#net","text":"net sub-command helps you to inspect the P2P network status.","title":"net"},{"location":"cli/#examples","text":"List all connected P2P nodes: ./conflux.exe rpc local net session List a single P2P node: ./conflux.exe rpc local net session --id <node_id> Check network egress: ./conflux.exe rpc local net throttling","title":"Examples"},{"location":"cli/#txpool","text":"txpool sub-command helps you to inspect the transaction pool.","title":"txpool"},{"location":"cli/#examples_1","text":"List transaction pool status: ./conflux.exe rpc local txpool status List transactions in details: ./conflux.exe rpc local txpool content List summary of transactions: ./conflux.exe rpc local txpool inspect Inspect a transaction in detail: ./conflux.exe rpc local txpool inspect-one --hash <tx_hash>","title":"Examples"},{"location":"cli/#sync-phase","text":"Get the synchronization phase of local conflux node. ./conflux.exe rpc local sync-phase","title":"sync-phase"},{"location":"cli/#send-transaction","text":"Send a transaction to local Conflux node.","title":"Send transaction"},{"location":"cli/#usage_3","text":"$ ./conflux.exe rpc local send --help conflux.exe-rpc-local-send Send a transaction and return its hash USAGE: conflux.exe rpc local send [OPTIONS] --from <ADDRESS> --password <STRING> --value <HEX> FLAGS: -h, --help Prints help information -V, --version Prints version information OPTIONS: --data <HEX> Hash of the method signature and encoded parameters --from <ADDRESS> Transaction from address --gas <HEX> Gas provided for transaction execution [default: 0x5208] --gas-price <HEX> Transaction gas price [default: 0x2540BE400] --nonce <HEX> Transaction nonce --password <STRING> Used to decrypt private key of sender to sign transaction --to <ADDRESS> Transaction to address (empty to create contract) --url <url> URL of RPC server [default: http://localhost:12537] --value <HEX> value sent with this transaction","title":"Usage"},{"location":"cli/#example_3","text":"Alice transfer 5 Drip (1 CFX = 10^18 Drip) to Bob. Note, the address of Alice must exist at local machine, otherwise please create account for alice at first. ./conflux.exe rpc local send --from <alice_address> --to <bob_address> --value 0x5 --password 123456 Alice create a contract with gas 3,000,000. You can use solc to compile contract to get the bytecodes. ./conflux.exe rpc local send --from <alice_address> --value 0x0 --gas 0x\u202d2DC6C0\u202c --data <HEX_contract_bytecodes> --password 123456","title":"Example"},{"location":"consensus/","text":"The Conflux Consensus Layer Design and Implementation \u00b6 The Conflux consensus layer processes all incoming blocks received from the synchronization layer, produces the total order of blocks based on the Conflux GHAST consensus algorithm, and invokes the underlying transaction execution engine to run transactions in the determined order. It provides the information necessary to assist block generator to prepare the block skeleton of new blocks. It also notifies the transaction pool about processed transactions so that the pool can make better transaction selection decisions. This document is to provide a high-level overview for readers who want to understand the rust implementation of the Conflux consensus layer (in directory core/src/consensus). For more implementation details, see inlined comments in the code. For more information about the Conflux consensus algorithm, see Conflux Protocol Specification and Conflux paper (https://arxiv.org/abs/1805.03870). Design Goals \u00b6 The consensus layer has the following design goals. Process new blocks in the background following the consensus algorithm consistently. We want to minimize the memory usage of each block in the consensus graph. Even with the checkpoint mechanism, the graph will contain 300K-500K blocks in the normal case and more than 1M blocks when facing liveness attacks. This may stress the memory. We want to process each block fast. Because full/archive nodes have to process every block from the original genesis when they catch up with the network from scratch, fast block process is important to keep the catch up period short. Robust against potential attacks. Malicious attackers may generate bad blocks at arbitrary positions in the TreeGraph. Structures and Components \u00b6 ConsensusGraph \u00b6 ConsensusGraph (core/src/consensus/mod.rs) is the main struct of the consensus layer. The synchronization layer constructs ConsensusGraph with a BlockDataManager which stores all block metadata information on disk. ConsensusGraph::on_new_block() is the key function to send new blocks to the ConsensusGraph struct to process. It also provides a set of public functions to query the status of blocks/transactions. This should be the main interface with which other components interact. ConsensusGraphInner \u00b6 ConsensusGraphInner (core/src/consensus/consensus_inner/mod.rs) is the inner structure of ConsensusGraph . ConsensusGraph::on_new_block() acquires the write lock of the inner struct at the start of the function. The rest are query functions that only acquire read locks. The internal structure of ConsensusGraphInner is fairly complicated. Generally speaking, it maintains two kinds of information. The first kind of information is the state of the whole TreeGraph, i.e., the current pivot chain , timer chain , difficulty , etc.. The second kind of information is the state of each block (i.e., ConsensusGraphNode struct for each block). Each block corresponds to a ConsensusGraphNode struct for its information. When it first enters ConsensusGraphInner , it will be inserted into ConsensusGraphInner::arena : Slab<ConsensusGraphNode> . The index in the slab will become the arena index of the block in ConsensusGraphInner . We use the arena index to represent a block internally instead of H256 because it is much cheaper. We will refer back to the fields in ConsensusGraphInner and ConsensusGraphNode when we talk about algorithm mechanism and their implementations. ConsensusNewBlockHandler \u00b6 ConsensusNewBlockHandler (core/src/consensus/consensus_inner/consensus_new_block_handler.rs) contains a set of routines for processing a new block. In theory, this code could be part of ConsensusGraphInner because it mostly manipulates the inner struct. However, these routines are all subroutine of the on_new_block() and the consensus_inner/mod.rs is already very complicated. We therefore decided to put them into a separate file. ConsensusExecutor \u00b6 ConsensusExecutor (core/src/consensus/consensus_inner/consensus_executor.rs) is the interface struct for the standalone transaction execution thread. ConsensusExecutor::enqueue_epoch() allows other threads to send an execution task to execute the epoch of a given pivot chain block asynchronously. Once the computation finishes, the resulting state root will be stored into BlockDataManager . Other threads can call ConsensusExecutor::wait_for_result() to wait for the execution of an epoch if desired. In the current implementation, ConsensusExecutor also contains the routines for the calculation for block rewards, including get_reward_execution_info() and its subroutines. ConfirmationMeter \u00b6 ConfirmationMeter (core/src/consensus/consensus_inner/confirmation_meter.rs) conservatively calculates the confirmation risk of each pivot chain block. Its result will be useful for the storage layer to determine when it is safe to discard old snapshots. It can also be used to serve RPC queries about block confirmation if we decide to provide such RPC. AnticoneCache and PastsetCache \u00b6 AnticoneCache (core/src/consensus/anticone_cache.rs) and PastsetCache (core/src/consensus/pastset_cache.rs) are two structs that implement customized caches for data structures in ConsensusGraphInner . In the implementation of the inner struct, we need to calculate and store the anticone set and the past set of each block. However, it is not possible to store all of these sets in memory. We therefore implement cache style data structures to store sets for recently inserted/accessed blocks. If an anticone/past set is not found in the cache, we will recalculate the set in the current inner struct implementation. Important Algorithmic Mechanisms \u00b6 There are several important algorithmic mechanisms in the Conflux Consensus Layer. Here we will talk about them from the implementation aspect. See XXX for the algorithmic reasoning behind them. Pivot Chain and Total Order \u00b6 The basic idea of the Conflux consensus algorithm is to first make everyone agree on a pivot chain. It then expands the total order from the pivot chain to cover all blocks with a topological sort. As long as the pivot chain does not change/reorg, the total order of blocks will stay the same, so does the derived order of transactions. Comparing with Bitcoin/Ethereum, the consensus in Conflux has two key differences: almost every block will go into the total order, not just the agreed pivot chain. The transaction validity and the block validity are independent . For example, a transaction is invalid if it was included before or it cannot carry out due to insufficient balance. Such invalid transactions will become noop during the execution. However, unlike Bitcoin and Ethereum blocks containing such transactions will not become invalid . In ConsensusGraphInner , the arena index of the current pivot chain blocks are stored in order in the pivot_chain[] vector. To maintain it, we calculate the lowest common ancestor (LCA) between the newly inserted block and the current best block following the GHAST rule. If the fork corresponding to the newly inserted block for the LCA ended up to be heavier, we will update the pivot_chain[] from the forked point. Timer Chain \u00b6 Blocks whose PoW quality is timer_chain_difficulty_ratio times higher than the target difficulty are timer blocks . The is_timer field of the block will be set to True. The consensus algorithm then finds the longest timer block chain (more accurately, with greatest accumulated difficulty) similar to the Bitcoin consensus algorithm of finding the longest chain. The arena index of this longest timer chain will be stored into timer_chain[] . The rationale of the timer chain is to provide a coarse-grained measurement of time that cannot be influenced by a malicious attacker. Because timer blocks are rare and generated slowly (if timer_chain_difficulty_ratio is properly high), a malicious attacker cannot prevent the growth of the timer chain unless it has the majority of the computation power. Therefore how many timer chain blocks appear in the past set of a block is a good indication about the latest possible generation time of the block. We compute this value for each block and store it in timer_chain_height field of the block. Weight Maintenance with Link-Cut Tree \u00b6 To effectively maintain the pivot chain, we need to query the total weight of a subtree. Conflux uses a Link-Cut Tree data structure to maintain the subtree weights in O(log n). The Link-Cut Tree can also calculate the LCA of any two nodes in the TreeGraph in O(log n). The weight_tree field in ConsensusGraphInner is the link-cut tree that stores the subtree weight of every node. Note that the implementation of the Link-Cut Tree is in the utils/link-cut-tree directory. Adaptive Weight \u00b6 If the TreeGraph is under a liveness attack, it may fail to converge under one block for a while. To handle this situation, the GHAST algorithm idea is to start to generate adaptive blocks, i.e., blocks whose weights are redistributed significantly so that there will be many zero weight blocks with a rare set of very heavy blocks. Specifically, if the PoW quality of an adaptive block is adaptive_heavy_block_ratio times of the target difficulty, the block will have a weight of adaptive_heavy_block_ratio ; otherwise, the block will have a weight of zero. This effectively slows down the confirmation temporarily but will ensure the consensus progress. Because adaptive weight is a mechanism to defend against rare liveness attacks, it should not be turned on during the normal scenario. A new block is adaptive only if: 1) one of its ancestor blocks is still not the dominant subtree comparing to its siblings, and 2) a significantly long period of time has passed between the generation of that ancestor block and the new block (i.e., the difference of timer_chain_height is sufficiently large). ConsensusGraphInner::adaptive_weight() and its subroutines implement the algorithm to determine whether a block is adaptive or not. Note that the implementation uses another link-cut-tree adaptive_tree as a helper. Please see the inlined comments for the implementation details. Partial Invalid \u00b6 Note that the past set of a new block denotes all the blocks that the generator of the new block observes at the generation time. Therefore, from the past set of a new block, other full nodes could determine whether it chooses the correct parent block and whether it should be adaptive or not. The Conflux consensus algorithm defines those blocks who choose incorrect parents or fill in incorrect adaptive status as partial invalid blocks . For a partial invalid block, the partial_invalid field will be set to True. The algorithm requires the partial invalid blocks being treated differently from the normal blocks in three ways: All honest nodes will not reference directly or indirectly partial invalid blocks until a significant period of time. This time period is measured with the timer_chain_height and the difference has to be more than timer_chain_beta . Yes, it means that if another otherwise perfectly fine block referencing the partial invalid block, both of these two blocks will not be referenced for a while. Partial invalid blocks will have no block reward. They are extremely unlikely to get any reward anyway because of their large anticone set due to the first rule. Partial invalid blocks are excluded from the timer chain consideration. To implement the first rule, the on_new_block() routine in ConsensusNewBlockHandler is separated into two subroutine preactivate_block() and activate_block() . preactivate_block() compute and determine whether a block is partial invalid or not, while activate_block() fully integrate a block into the consensus graph inner data structures. For every new block, the field active_cnt tracks how many inactive blocks it references. A block is inactive if it references directly or indirectly a partial invalid block. activate_block() will be called on a block only when active_cnt of the block becomes zero. The field activated denotes whether a block is active or not. For partially invalid blocks, their activation will be delayed till the current timer chain height of the ledger is timer_chain_beta higher than the invalid block. Newly generated blocks will not reference any inactive blocks, i.e., these inactive blocks are treated as if they were not in the TreeGraph. Anticone, Past View, and Ledger View \u00b6 In order to check the partial invalid status of each block, we need to operate under the past view of the block to determine its correct parent and its adaptivity. This is different from the current state of the TreeGraph or we call it the ledger view , i.e., all blocks in the anticone and the future set of the block are excluded. Because we process blocks in topological order, the future set of a new block is empty. We therefore need to eliminate all anticone blocks only. compute_and_update_anticone() in ConsensusNewBlockHandler computes the anticone set of a new block. Note that because the anticone set may be very large, we have two implementation level optimizations. First, we represent the anticone set as a set of barrier nodes in the TreeGraph, i.e., a set of subtrees where each block in the subtrees is in the anticone set. Second, we will maintain the anticone set of the recently accessed/inserted blocks only. When checking whether a block is valid in its past view or not (e.g., in adaptive_weight() and in check_correct_parent() ), we first cut all barrier subtrees from the link-cut weight trees accordingly to get the state of the past view. After the computation, we restore these anticone subtrees. Check Correct Parent \u00b6 To check whether a new block chooses a correct parent block or not, we first compute the set of blocks inside the epoch of the new block assuming that the new block is on the pivot chain. We store this set to the field blockset_in_own_view_of_epoch . We then iterate over every candidate block in this set to make sure that the chosen parent block is better than it. Specifically, we find out the two fork blocks of the candidate block and the parent block from their LCA and make sure that the fork of the parent is heavier. This logic is implemented in check_correct_parent() in ConsensusNewBlockHandler . Note that blockset_in_own_view_of_epoch may become too large to hold consistently in memory as well. Especially if a malicious attacker tries to generate invalid blocks to blow up this set. The current implementation will only periodically clear the set and only keep the sets for pivot chain blocks. Note that for pivot chain blocks, this set will also be used during the transaction execution. Fallback Brute Force Methods \u00b6 There are situations where the anticone barrier set is too large if a malicious attacker tries to launch a performance attack on Conflux. This will make the default strategy worse than O(n) because there is a factor of O(log n) for each block in the barrier set when we do the link-cut tree chopping. To this end, we implemented a brute force routine compute_subtree_weights() to compute the subtree weights of each block in a past view for O(n). We also implement check_correct_parent_brutal() and adaptive_weight_impl_brutal() to use the brute-force computed subtree weight to do the checking instead. Force Confirmation \u00b6 The Conflux consensus algorithm will force confirm a block if 1) there are timer_chain_beta consecutive timer chain blocks under the subtree of the block and 2) afterward there are at least timer_chain_beta timer chain blocks following (not required in the subtree though). Force confirmation means that new blocks should follow this block as their ancestor no matter what, ignoring subtree weights. Though extremely unlikely a force confirmed block will have lesser weights than its siblings. The force confirmation mechanism is to enable checkpoint, which we will describe later. It is based on the rationale that: Reverting a timer_chain_beta length timer chain is impossible. Therefore force confirmed block will always move along the pivot chain, not drifting between its siblings. We compute the accumulative LCA of the last timer_chain_beta timer chain blocks and store it at the timer_chain_accumulative_lca[] field. This vector is timer_chain_beta shorter than timer_chain[] because the force confirm needs at least timer_chain_beta timer chain block trailing, so their LCAs do not matter. check_correct_parent() and adaptive_weight() and their subroutines also respect this force confirm point during their checking. Specifically, any fork before the force confirm height is ignored. Note that this force confirm rule is also defined based on past view of each block. With the computed anticone information, compute_timer_chain_tuple() in ConsensusGraphInner computes the timer chain related information of each block under its past view. The results of this function include the difference of the timer_chain[] , timer_chain_accumulative_lca[] , and timer_chain_height between the ledger view and the past view. We can use the diff and the current ledger view values to get the past view values. Era \u00b6 In order to implement the checkpoint mechanism, the Conflux consensus algorithm split the graph into eras. Every era contains era_epoch_count epochs. For example, if the era_epoch_count is 50000, then there is a new era every 50000 epochs. The pivot chain block at the height 50000 will be the genesis of a new era. At the era boundary, there are several differences from the normal case. A block will enter the total order for execution only if 1) it is under the subtree of the previous era genesis and 2) it is inside the past set of the next era genesis in the pivot chain. Anticone penalty calculation for the block reward does not go across the era boundary. Checkpoint \u00b6 Inside ConsensusGraphInner , there are two key height pointers, the current checkpoint era genesis block height ( cur_era_genesis_height ) and the current stable era genesis block height ( cur_era_stable_height ). These two height pointers will always point to some era genesis (being a multiple of era_epoch_count ). Initially, both of these two pointers will point to the true genesis (height 0). A new era genesis block becomes stable (i.e., cur_era_stable_height moves) if the block is force confirmed in the current TreeGraph. A stable era genesis block becomes a new checkpoint (i.e., cur_era_genesis_height moves) if: The block is force confirmed in the past view of the stable era genesis block . In the anticone of this block, there is no timer chain block. should_move_stable_height() and should_form_checkpoint_at() in ConsensusNewBlockHandler are invoked after every newly inserted block to test the above two conditions. Generally speaking, the stable era genesis block will never be reverted off the pivot chain. Any block in the past set of the checkpoint block is no longer required for the future computation of the consensus layer. Therefore, after a new checkpoint is formed, make_checkpoint_at() in ConsensusNewBlockHandler is called to clean up those blocks that are not in the future set of the new checkpoint. Note that the checkpoint mechanism also changes how we handle a new block. For a new block: If the new block is outside the subtree of the current checkpoint, we only need to insert a stub into our data structure (because a block under the subtree may be indirectly referenced via this stub block). We do not need to care about such a block because it is not going to change the timer chain and it is not going to be executed. If the past set of the new block does not contain the stable era genesis block, we do not need to check the partial invalid status of this block. This is because this block will not change the timer chain (recall our assumption that the timer chain will not reorg for more than timer_chain_beta blocks) and future blocks can reference this block directly (since the timer chain difference is already more than timer_chain_beta ). Deferred Execution \u00b6 Because the TreeGraph pivot chain may oscillate temporarily, we defer the transaction execution for DEFERRED_STATE_EPOCH_COUNT epochs (default 5). After a pivot chain update, activate_block() routine will enqueue the execution task of the new pivot chain except for the last five epochs. It calls enqueue_epoch() in ConsensusExecutor to enqueue each task. Block Reward Calculation \u00b6 Because there is no explicit coinbase transaction in Conflux, all block rewards are computed implicitly during the transaction execution. In Conflux, the block reward is determined by the base reward and the penalty ratio based on the total weight of its anticone blocks divided by its epoch pivot block's target difficulty. This anticone set only considers blocks appearing no later than the next REWARD_EPOCH_COUNT epochs. Specifically, if there is a new era then the anticone set will not count across the era boundary as well. get_pivot_reward_index() in ConsensusExecutor counts this reward anticone threshold. get_reward_execution_info_from_index() in ConsensusExecutor and its subroutines compute this anticone set given the threshold point in the pivot chain. Blaming Mechanism \u00b6 It is infeasible to validate the filled state root of a block because we would need to execute all transactions in a different order in the past view of that block. Instead, we will only ask full nodes to validate the state root results on the current pivot chain. It then fills a blame number to indicate how many levels ancestors from the parent who do not have correct state root. When this number is greater than zero, the filled deferred state root becomes a Merkel H256 vector that contains the corrected state roots of the ancestors along with the correct one. get_blame_and_deferred_state_for_generation() in ConsensusGraph computes the blame information for the block generation. first_trusted_header_starting_from() in ConsensusGraph is a useful helper function to compute the first trustworthy header based on the subtree blame information. Multi-Thread Design \u00b6 The consensus layer has one thread dedicated to processing new blocks from the synchronization layer and one thread dedicated to executing transactions. It of course also has a set of interface APIs that RPC threads and synchronization threads may call. Consensus Worker \u00b6 Consensus Worker is a thread created by the synchronization layer. During the normal running phase, every new block will be sent to a channel connecting the synchronization thread and the consensus worker thread. The consensus work thread consumes each block one by one and invokes consensus::on_new_block() to process it. Note that the synchronization layer ensures the new block to be header-ready when it is delivered to Consensus Worker , i.e., all of its ancestor/past blocks are already delivered to the consensus layer before itself. This enables the consensus layer to always deal with a well-defined direct acyclic graph without holes. One advantage of having a single thread to be dedicated to the consensus protocol is that it simplifies the protocol implementation a lot. Because the details of the consensus protocol are complicated and the implementation involves many sophisticated data structure manipulations, the single thread design makes sure that we do not need to worry about deadlocks or races. Upon the entrance of consensus::on_new_block() , the thread acquires the write lock of the inner of the consensus struct (i.e., ConsensusGraphInner). During the normal phase, this thread should be the only one modifying the inner struct of the consensus layer. Consensus Execution Worker \u00b6 Consensus Execution Worker is a thread created at the start of the consensus layer. It is dedicated to transaction execution. There is a channel connecting Consensus Worker with Consensus Execution Worker . Once the consensus protocol determines the order of the pivot chain, it will send an ExecutionTask for each epoch in the pivot chain to the channel. These tasks will be picked up by the Consensus Execution Worker thread one by one. The thread loads the previous state before the executed epoch from the storage layer as the input, runs all transactions in the executed epoch (see ConsensusExecutor::process_epoch_transactions() ), and produces the result state as the output. The rationale of separating the transaction execution from the consensus protocol implementation is for performance. With our blaming mechanism , the execution result state is completely separated from the consensus protocol implementation. The deferred execution mechanism gives us extra room to pipeline the consensus protocol and the transaction execution. It is therefore not wise to block the Consensus Worker thread to wait for the execution results from coming back. Key Assumptions, Invariants, and Rules \u00b6 If you want to write code to interact with the Conflux consensus layer, it is very important to understand the following assumptions and rules. The consensus layer assumes that the passed BlockDataManager is in a consistent state. It means that the BlockDataManager contains the correct current checkpoint/stable height. Blocks before the checkpoint and the stable height are properly checked during previous execution and they are persisted into the BlockDataManager properly. The consensus layer does not check the results it fetches from the block data manager. If it is inconsistent, the consensus layer will execute incorrectly or crash! Besides the subroutines of on_new_block() , no one should hold the write lock of the inner struct ! Right now the only exception for this rule is assemble_new_block_impl() because of computing the adaptive field and this is not good we plan to change it. Acquiring the write lock of the inner struct is very likely to cause deadlock given the complexity of the Consensus layer and its dependency with many other components. Always try to avoid this!","title":"The Conflux Consensus Layer Design and Implementation"},{"location":"consensus/#the-conflux-consensus-layer-design-and-implementation","text":"The Conflux consensus layer processes all incoming blocks received from the synchronization layer, produces the total order of blocks based on the Conflux GHAST consensus algorithm, and invokes the underlying transaction execution engine to run transactions in the determined order. It provides the information necessary to assist block generator to prepare the block skeleton of new blocks. It also notifies the transaction pool about processed transactions so that the pool can make better transaction selection decisions. This document is to provide a high-level overview for readers who want to understand the rust implementation of the Conflux consensus layer (in directory core/src/consensus). For more implementation details, see inlined comments in the code. For more information about the Conflux consensus algorithm, see Conflux Protocol Specification and Conflux paper (https://arxiv.org/abs/1805.03870).","title":"The Conflux Consensus Layer Design and Implementation"},{"location":"consensus/#design-goals","text":"The consensus layer has the following design goals. Process new blocks in the background following the consensus algorithm consistently. We want to minimize the memory usage of each block in the consensus graph. Even with the checkpoint mechanism, the graph will contain 300K-500K blocks in the normal case and more than 1M blocks when facing liveness attacks. This may stress the memory. We want to process each block fast. Because full/archive nodes have to process every block from the original genesis when they catch up with the network from scratch, fast block process is important to keep the catch up period short. Robust against potential attacks. Malicious attackers may generate bad blocks at arbitrary positions in the TreeGraph.","title":"Design Goals"},{"location":"consensus/#structures-and-components","text":"","title":"Structures and Components"},{"location":"consensus/#consensusgraph","text":"ConsensusGraph (core/src/consensus/mod.rs) is the main struct of the consensus layer. The synchronization layer constructs ConsensusGraph with a BlockDataManager which stores all block metadata information on disk. ConsensusGraph::on_new_block() is the key function to send new blocks to the ConsensusGraph struct to process. It also provides a set of public functions to query the status of blocks/transactions. This should be the main interface with which other components interact.","title":"ConsensusGraph"},{"location":"consensus/#consensusgraphinner","text":"ConsensusGraphInner (core/src/consensus/consensus_inner/mod.rs) is the inner structure of ConsensusGraph . ConsensusGraph::on_new_block() acquires the write lock of the inner struct at the start of the function. The rest are query functions that only acquire read locks. The internal structure of ConsensusGraphInner is fairly complicated. Generally speaking, it maintains two kinds of information. The first kind of information is the state of the whole TreeGraph, i.e., the current pivot chain , timer chain , difficulty , etc.. The second kind of information is the state of each block (i.e., ConsensusGraphNode struct for each block). Each block corresponds to a ConsensusGraphNode struct for its information. When it first enters ConsensusGraphInner , it will be inserted into ConsensusGraphInner::arena : Slab<ConsensusGraphNode> . The index in the slab will become the arena index of the block in ConsensusGraphInner . We use the arena index to represent a block internally instead of H256 because it is much cheaper. We will refer back to the fields in ConsensusGraphInner and ConsensusGraphNode when we talk about algorithm mechanism and their implementations.","title":"ConsensusGraphInner"},{"location":"consensus/#consensusnewblockhandler","text":"ConsensusNewBlockHandler (core/src/consensus/consensus_inner/consensus_new_block_handler.rs) contains a set of routines for processing a new block. In theory, this code could be part of ConsensusGraphInner because it mostly manipulates the inner struct. However, these routines are all subroutine of the on_new_block() and the consensus_inner/mod.rs is already very complicated. We therefore decided to put them into a separate file.","title":"ConsensusNewBlockHandler"},{"location":"consensus/#consensusexecutor","text":"ConsensusExecutor (core/src/consensus/consensus_inner/consensus_executor.rs) is the interface struct for the standalone transaction execution thread. ConsensusExecutor::enqueue_epoch() allows other threads to send an execution task to execute the epoch of a given pivot chain block asynchronously. Once the computation finishes, the resulting state root will be stored into BlockDataManager . Other threads can call ConsensusExecutor::wait_for_result() to wait for the execution of an epoch if desired. In the current implementation, ConsensusExecutor also contains the routines for the calculation for block rewards, including get_reward_execution_info() and its subroutines.","title":"ConsensusExecutor"},{"location":"consensus/#confirmationmeter","text":"ConfirmationMeter (core/src/consensus/consensus_inner/confirmation_meter.rs) conservatively calculates the confirmation risk of each pivot chain block. Its result will be useful for the storage layer to determine when it is safe to discard old snapshots. It can also be used to serve RPC queries about block confirmation if we decide to provide such RPC.","title":"ConfirmationMeter"},{"location":"consensus/#anticonecache-and-pastsetcache","text":"AnticoneCache (core/src/consensus/anticone_cache.rs) and PastsetCache (core/src/consensus/pastset_cache.rs) are two structs that implement customized caches for data structures in ConsensusGraphInner . In the implementation of the inner struct, we need to calculate and store the anticone set and the past set of each block. However, it is not possible to store all of these sets in memory. We therefore implement cache style data structures to store sets for recently inserted/accessed blocks. If an anticone/past set is not found in the cache, we will recalculate the set in the current inner struct implementation.","title":"AnticoneCache and PastsetCache"},{"location":"consensus/#important-algorithmic-mechanisms","text":"There are several important algorithmic mechanisms in the Conflux Consensus Layer. Here we will talk about them from the implementation aspect. See XXX for the algorithmic reasoning behind them.","title":"Important Algorithmic Mechanisms"},{"location":"consensus/#pivot-chain-and-total-order","text":"The basic idea of the Conflux consensus algorithm is to first make everyone agree on a pivot chain. It then expands the total order from the pivot chain to cover all blocks with a topological sort. As long as the pivot chain does not change/reorg, the total order of blocks will stay the same, so does the derived order of transactions. Comparing with Bitcoin/Ethereum, the consensus in Conflux has two key differences: almost every block will go into the total order, not just the agreed pivot chain. The transaction validity and the block validity are independent . For example, a transaction is invalid if it was included before or it cannot carry out due to insufficient balance. Such invalid transactions will become noop during the execution. However, unlike Bitcoin and Ethereum blocks containing such transactions will not become invalid . In ConsensusGraphInner , the arena index of the current pivot chain blocks are stored in order in the pivot_chain[] vector. To maintain it, we calculate the lowest common ancestor (LCA) between the newly inserted block and the current best block following the GHAST rule. If the fork corresponding to the newly inserted block for the LCA ended up to be heavier, we will update the pivot_chain[] from the forked point.","title":"Pivot Chain and Total Order"},{"location":"consensus/#timer-chain","text":"Blocks whose PoW quality is timer_chain_difficulty_ratio times higher than the target difficulty are timer blocks . The is_timer field of the block will be set to True. The consensus algorithm then finds the longest timer block chain (more accurately, with greatest accumulated difficulty) similar to the Bitcoin consensus algorithm of finding the longest chain. The arena index of this longest timer chain will be stored into timer_chain[] . The rationale of the timer chain is to provide a coarse-grained measurement of time that cannot be influenced by a malicious attacker. Because timer blocks are rare and generated slowly (if timer_chain_difficulty_ratio is properly high), a malicious attacker cannot prevent the growth of the timer chain unless it has the majority of the computation power. Therefore how many timer chain blocks appear in the past set of a block is a good indication about the latest possible generation time of the block. We compute this value for each block and store it in timer_chain_height field of the block.","title":"Timer Chain"},{"location":"consensus/#weight-maintenance-with-link-cut-tree","text":"To effectively maintain the pivot chain, we need to query the total weight of a subtree. Conflux uses a Link-Cut Tree data structure to maintain the subtree weights in O(log n). The Link-Cut Tree can also calculate the LCA of any two nodes in the TreeGraph in O(log n). The weight_tree field in ConsensusGraphInner is the link-cut tree that stores the subtree weight of every node. Note that the implementation of the Link-Cut Tree is in the utils/link-cut-tree directory.","title":"Weight Maintenance with Link-Cut Tree"},{"location":"consensus/#adaptive-weight","text":"If the TreeGraph is under a liveness attack, it may fail to converge under one block for a while. To handle this situation, the GHAST algorithm idea is to start to generate adaptive blocks, i.e., blocks whose weights are redistributed significantly so that there will be many zero weight blocks with a rare set of very heavy blocks. Specifically, if the PoW quality of an adaptive block is adaptive_heavy_block_ratio times of the target difficulty, the block will have a weight of adaptive_heavy_block_ratio ; otherwise, the block will have a weight of zero. This effectively slows down the confirmation temporarily but will ensure the consensus progress. Because adaptive weight is a mechanism to defend against rare liveness attacks, it should not be turned on during the normal scenario. A new block is adaptive only if: 1) one of its ancestor blocks is still not the dominant subtree comparing to its siblings, and 2) a significantly long period of time has passed between the generation of that ancestor block and the new block (i.e., the difference of timer_chain_height is sufficiently large). ConsensusGraphInner::adaptive_weight() and its subroutines implement the algorithm to determine whether a block is adaptive or not. Note that the implementation uses another link-cut-tree adaptive_tree as a helper. Please see the inlined comments for the implementation details.","title":"Adaptive Weight"},{"location":"consensus/#partial-invalid","text":"Note that the past set of a new block denotes all the blocks that the generator of the new block observes at the generation time. Therefore, from the past set of a new block, other full nodes could determine whether it chooses the correct parent block and whether it should be adaptive or not. The Conflux consensus algorithm defines those blocks who choose incorrect parents or fill in incorrect adaptive status as partial invalid blocks . For a partial invalid block, the partial_invalid field will be set to True. The algorithm requires the partial invalid blocks being treated differently from the normal blocks in three ways: All honest nodes will not reference directly or indirectly partial invalid blocks until a significant period of time. This time period is measured with the timer_chain_height and the difference has to be more than timer_chain_beta . Yes, it means that if another otherwise perfectly fine block referencing the partial invalid block, both of these two blocks will not be referenced for a while. Partial invalid blocks will have no block reward. They are extremely unlikely to get any reward anyway because of their large anticone set due to the first rule. Partial invalid blocks are excluded from the timer chain consideration. To implement the first rule, the on_new_block() routine in ConsensusNewBlockHandler is separated into two subroutine preactivate_block() and activate_block() . preactivate_block() compute and determine whether a block is partial invalid or not, while activate_block() fully integrate a block into the consensus graph inner data structures. For every new block, the field active_cnt tracks how many inactive blocks it references. A block is inactive if it references directly or indirectly a partial invalid block. activate_block() will be called on a block only when active_cnt of the block becomes zero. The field activated denotes whether a block is active or not. For partially invalid blocks, their activation will be delayed till the current timer chain height of the ledger is timer_chain_beta higher than the invalid block. Newly generated blocks will not reference any inactive blocks, i.e., these inactive blocks are treated as if they were not in the TreeGraph.","title":"Partial Invalid"},{"location":"consensus/#anticone-past-view-and-ledger-view","text":"In order to check the partial invalid status of each block, we need to operate under the past view of the block to determine its correct parent and its adaptivity. This is different from the current state of the TreeGraph or we call it the ledger view , i.e., all blocks in the anticone and the future set of the block are excluded. Because we process blocks in topological order, the future set of a new block is empty. We therefore need to eliminate all anticone blocks only. compute_and_update_anticone() in ConsensusNewBlockHandler computes the anticone set of a new block. Note that because the anticone set may be very large, we have two implementation level optimizations. First, we represent the anticone set as a set of barrier nodes in the TreeGraph, i.e., a set of subtrees where each block in the subtrees is in the anticone set. Second, we will maintain the anticone set of the recently accessed/inserted blocks only. When checking whether a block is valid in its past view or not (e.g., in adaptive_weight() and in check_correct_parent() ), we first cut all barrier subtrees from the link-cut weight trees accordingly to get the state of the past view. After the computation, we restore these anticone subtrees.","title":"Anticone, Past View, and Ledger View"},{"location":"consensus/#check-correct-parent","text":"To check whether a new block chooses a correct parent block or not, we first compute the set of blocks inside the epoch of the new block assuming that the new block is on the pivot chain. We store this set to the field blockset_in_own_view_of_epoch . We then iterate over every candidate block in this set to make sure that the chosen parent block is better than it. Specifically, we find out the two fork blocks of the candidate block and the parent block from their LCA and make sure that the fork of the parent is heavier. This logic is implemented in check_correct_parent() in ConsensusNewBlockHandler . Note that blockset_in_own_view_of_epoch may become too large to hold consistently in memory as well. Especially if a malicious attacker tries to generate invalid blocks to blow up this set. The current implementation will only periodically clear the set and only keep the sets for pivot chain blocks. Note that for pivot chain blocks, this set will also be used during the transaction execution.","title":"Check Correct Parent"},{"location":"consensus/#fallback-brute-force-methods","text":"There are situations where the anticone barrier set is too large if a malicious attacker tries to launch a performance attack on Conflux. This will make the default strategy worse than O(n) because there is a factor of O(log n) for each block in the barrier set when we do the link-cut tree chopping. To this end, we implemented a brute force routine compute_subtree_weights() to compute the subtree weights of each block in a past view for O(n). We also implement check_correct_parent_brutal() and adaptive_weight_impl_brutal() to use the brute-force computed subtree weight to do the checking instead.","title":"Fallback Brute Force Methods"},{"location":"consensus/#force-confirmation","text":"The Conflux consensus algorithm will force confirm a block if 1) there are timer_chain_beta consecutive timer chain blocks under the subtree of the block and 2) afterward there are at least timer_chain_beta timer chain blocks following (not required in the subtree though). Force confirmation means that new blocks should follow this block as their ancestor no matter what, ignoring subtree weights. Though extremely unlikely a force confirmed block will have lesser weights than its siblings. The force confirmation mechanism is to enable checkpoint, which we will describe later. It is based on the rationale that: Reverting a timer_chain_beta length timer chain is impossible. Therefore force confirmed block will always move along the pivot chain, not drifting between its siblings. We compute the accumulative LCA of the last timer_chain_beta timer chain blocks and store it at the timer_chain_accumulative_lca[] field. This vector is timer_chain_beta shorter than timer_chain[] because the force confirm needs at least timer_chain_beta timer chain block trailing, so their LCAs do not matter. check_correct_parent() and adaptive_weight() and their subroutines also respect this force confirm point during their checking. Specifically, any fork before the force confirm height is ignored. Note that this force confirm rule is also defined based on past view of each block. With the computed anticone information, compute_timer_chain_tuple() in ConsensusGraphInner computes the timer chain related information of each block under its past view. The results of this function include the difference of the timer_chain[] , timer_chain_accumulative_lca[] , and timer_chain_height between the ledger view and the past view. We can use the diff and the current ledger view values to get the past view values.","title":"Force Confirmation"},{"location":"consensus/#era","text":"In order to implement the checkpoint mechanism, the Conflux consensus algorithm split the graph into eras. Every era contains era_epoch_count epochs. For example, if the era_epoch_count is 50000, then there is a new era every 50000 epochs. The pivot chain block at the height 50000 will be the genesis of a new era. At the era boundary, there are several differences from the normal case. A block will enter the total order for execution only if 1) it is under the subtree of the previous era genesis and 2) it is inside the past set of the next era genesis in the pivot chain. Anticone penalty calculation for the block reward does not go across the era boundary.","title":"Era"},{"location":"consensus/#checkpoint","text":"Inside ConsensusGraphInner , there are two key height pointers, the current checkpoint era genesis block height ( cur_era_genesis_height ) and the current stable era genesis block height ( cur_era_stable_height ). These two height pointers will always point to some era genesis (being a multiple of era_epoch_count ). Initially, both of these two pointers will point to the true genesis (height 0). A new era genesis block becomes stable (i.e., cur_era_stable_height moves) if the block is force confirmed in the current TreeGraph. A stable era genesis block becomes a new checkpoint (i.e., cur_era_genesis_height moves) if: The block is force confirmed in the past view of the stable era genesis block . In the anticone of this block, there is no timer chain block. should_move_stable_height() and should_form_checkpoint_at() in ConsensusNewBlockHandler are invoked after every newly inserted block to test the above two conditions. Generally speaking, the stable era genesis block will never be reverted off the pivot chain. Any block in the past set of the checkpoint block is no longer required for the future computation of the consensus layer. Therefore, after a new checkpoint is formed, make_checkpoint_at() in ConsensusNewBlockHandler is called to clean up those blocks that are not in the future set of the new checkpoint. Note that the checkpoint mechanism also changes how we handle a new block. For a new block: If the new block is outside the subtree of the current checkpoint, we only need to insert a stub into our data structure (because a block under the subtree may be indirectly referenced via this stub block). We do not need to care about such a block because it is not going to change the timer chain and it is not going to be executed. If the past set of the new block does not contain the stable era genesis block, we do not need to check the partial invalid status of this block. This is because this block will not change the timer chain (recall our assumption that the timer chain will not reorg for more than timer_chain_beta blocks) and future blocks can reference this block directly (since the timer chain difference is already more than timer_chain_beta ).","title":"Checkpoint"},{"location":"consensus/#deferred-execution","text":"Because the TreeGraph pivot chain may oscillate temporarily, we defer the transaction execution for DEFERRED_STATE_EPOCH_COUNT epochs (default 5). After a pivot chain update, activate_block() routine will enqueue the execution task of the new pivot chain except for the last five epochs. It calls enqueue_epoch() in ConsensusExecutor to enqueue each task.","title":"Deferred Execution"},{"location":"consensus/#block-reward-calculation","text":"Because there is no explicit coinbase transaction in Conflux, all block rewards are computed implicitly during the transaction execution. In Conflux, the block reward is determined by the base reward and the penalty ratio based on the total weight of its anticone blocks divided by its epoch pivot block's target difficulty. This anticone set only considers blocks appearing no later than the next REWARD_EPOCH_COUNT epochs. Specifically, if there is a new era then the anticone set will not count across the era boundary as well. get_pivot_reward_index() in ConsensusExecutor counts this reward anticone threshold. get_reward_execution_info_from_index() in ConsensusExecutor and its subroutines compute this anticone set given the threshold point in the pivot chain.","title":"Block Reward Calculation"},{"location":"consensus/#blaming-mechanism","text":"It is infeasible to validate the filled state root of a block because we would need to execute all transactions in a different order in the past view of that block. Instead, we will only ask full nodes to validate the state root results on the current pivot chain. It then fills a blame number to indicate how many levels ancestors from the parent who do not have correct state root. When this number is greater than zero, the filled deferred state root becomes a Merkel H256 vector that contains the corrected state roots of the ancestors along with the correct one. get_blame_and_deferred_state_for_generation() in ConsensusGraph computes the blame information for the block generation. first_trusted_header_starting_from() in ConsensusGraph is a useful helper function to compute the first trustworthy header based on the subtree blame information.","title":"Blaming Mechanism"},{"location":"consensus/#multi-thread-design","text":"The consensus layer has one thread dedicated to processing new blocks from the synchronization layer and one thread dedicated to executing transactions. It of course also has a set of interface APIs that RPC threads and synchronization threads may call.","title":"Multi-Thread Design"},{"location":"consensus/#consensus-worker","text":"Consensus Worker is a thread created by the synchronization layer. During the normal running phase, every new block will be sent to a channel connecting the synchronization thread and the consensus worker thread. The consensus work thread consumes each block one by one and invokes consensus::on_new_block() to process it. Note that the synchronization layer ensures the new block to be header-ready when it is delivered to Consensus Worker , i.e., all of its ancestor/past blocks are already delivered to the consensus layer before itself. This enables the consensus layer to always deal with a well-defined direct acyclic graph without holes. One advantage of having a single thread to be dedicated to the consensus protocol is that it simplifies the protocol implementation a lot. Because the details of the consensus protocol are complicated and the implementation involves many sophisticated data structure manipulations, the single thread design makes sure that we do not need to worry about deadlocks or races. Upon the entrance of consensus::on_new_block() , the thread acquires the write lock of the inner of the consensus struct (i.e., ConsensusGraphInner). During the normal phase, this thread should be the only one modifying the inner struct of the consensus layer.","title":"Consensus Worker"},{"location":"consensus/#consensus-execution-worker","text":"Consensus Execution Worker is a thread created at the start of the consensus layer. It is dedicated to transaction execution. There is a channel connecting Consensus Worker with Consensus Execution Worker . Once the consensus protocol determines the order of the pivot chain, it will send an ExecutionTask for each epoch in the pivot chain to the channel. These tasks will be picked up by the Consensus Execution Worker thread one by one. The thread loads the previous state before the executed epoch from the storage layer as the input, runs all transactions in the executed epoch (see ConsensusExecutor::process_epoch_transactions() ), and produces the result state as the output. The rationale of separating the transaction execution from the consensus protocol implementation is for performance. With our blaming mechanism , the execution result state is completely separated from the consensus protocol implementation. The deferred execution mechanism gives us extra room to pipeline the consensus protocol and the transaction execution. It is therefore not wise to block the Consensus Worker thread to wait for the execution results from coming back.","title":"Consensus Execution Worker"},{"location":"consensus/#key-assumptions-invariants-and-rules","text":"If you want to write code to interact with the Conflux consensus layer, it is very important to understand the following assumptions and rules. The consensus layer assumes that the passed BlockDataManager is in a consistent state. It means that the BlockDataManager contains the correct current checkpoint/stable height. Blocks before the checkpoint and the stable height are properly checked during previous execution and they are persisted into the BlockDataManager properly. The consensus layer does not check the results it fetches from the block data manager. If it is inconsistent, the consensus layer will execute incorrectly or crash! Besides the subroutines of on_new_block() , no one should hold the write lock of the inner struct ! Right now the only exception for this rule is assemble_new_block_impl() because of computing the adaptive field and this is not good we plan to change it. Acquiring the write lock of the inner struct is very likely to cause deadlock given the complexity of the Consensus layer and its dependency with many other components. Always try to avoid this!","title":"Key Assumptions, Invariants, and Rules"},{"location":"design/","text":"Conflux Design Document \u00b6 In this document, we describe the architecture and organization of Conflux software stack and its design rationale. The following figure shows the overview of the Conflux full node stack. It consists of several key components. Peer-to-Peer Layer Synchronization Graph Consensus Graph Storage Layer Transaction Pool Block Generator Generally speaking, the peer-to-peer layer takes charge of disseminating blocks and transactions among the nodes in the entire network where each node maintains several inbound/outbound connections to its peers. Each node also maintains an in-memory synchronization graph data structure. When a new block is received from a peer or generated locally, the block will be first inserted into the synchronization graph where it goes through some basic validation which does not require graph-wise information. At the time when a block enters the synchronization graph, its past-set blocks may not already entered. The synchronization graph monitors the block and puts it into the consensus graph once all its past-set blocks enters the synchronization graph. When a block enters the consensus graph, its past-set blocks should all already entered this graph. Then the consensus algorithm will be conducted based on this newly arrived block to adjust the total order of blocks accordingly. The consensus graph component executes the newly arrived block and updates the account states in the storage layer. Each node maintains a transaction pool that holds the to-be-packed transactions and relays the transactions to its peers that may need them. The block generator component drives the mining efforts, picks transactions from the pool, and packs them into the newly generated block. This document is organized as in the following sections. Consensus Mechanism Block Synchronization Process Transaction Relay","title":"Design & Implementation"},{"location":"design/#conflux-design-document","text":"In this document, we describe the architecture and organization of Conflux software stack and its design rationale. The following figure shows the overview of the Conflux full node stack. It consists of several key components. Peer-to-Peer Layer Synchronization Graph Consensus Graph Storage Layer Transaction Pool Block Generator Generally speaking, the peer-to-peer layer takes charge of disseminating blocks and transactions among the nodes in the entire network where each node maintains several inbound/outbound connections to its peers. Each node also maintains an in-memory synchronization graph data structure. When a new block is received from a peer or generated locally, the block will be first inserted into the synchronization graph where it goes through some basic validation which does not require graph-wise information. At the time when a block enters the synchronization graph, its past-set blocks may not already entered. The synchronization graph monitors the block and puts it into the consensus graph once all its past-set blocks enters the synchronization graph. When a block enters the consensus graph, its past-set blocks should all already entered this graph. Then the consensus algorithm will be conducted based on this newly arrived block to adjust the total order of blocks accordingly. The consensus graph component executes the newly arrived block and updates the account states in the storage layer. Each node maintains a transaction pool that holds the to-be-packed transactions and relays the transactions to its peers that may need them. The block generator component drives the mining efforts, picks transactions from the pool, and packs them into the newly generated block. This document is organized as in the following sections. Consensus Mechanism Block Synchronization Process Transaction Relay","title":"Conflux Design Document"},{"location":"get_started/","text":"Here we walk through how to quickly setup conflux full node to join the testnet and how to use Conflux wallet to manage your account, transfer Conflux token, and deploy smart contract. Running Conflux Full Node \u00b6 First, please build the binary as instructed in Installation . To start Conflux manually, you need to edit the default configuration file run/default.toml : Set public_address according to your public IP. The port should be 32323 by default. Set mining_author to the account address to receive mining reward. Conflux team has maintained some full nodes for the test net, and they have been provided as bootnodes . If you want to use other nodes to bootstrap your new node, you should edit this entry. Then you can run the following commands: $ cd run $ ../target/release/conflux --config default.toml It will start a full node and begin syncing the Conflux testnet blockchain. Note that two new directories ( blockchain_db and net_config ) will be created in the current working directory ( run ) to keep the persistent data. Please do not remove them unless data are corrupt or you want to start a fresh new node. To restart a node, just run the same command line in the same directory. Configuring Conflux Full Node \u00b6 Conflux can be configured using either the CLI options or a config file. Should the CLI flags and the config file disagree about a setting, the CLI takes precedence. The config file follows the format of TOML . The path of the configuration file can be set with the CLI option --config path/to/conflux.toml . A default configuration file default.toml with every configuration explained has been provided in the directory run , and you can start customizing your configuration from there. You can list all CLI options by running $ ./conflux --help . The vast majority of CLI options map to a setting in the TOML file, for example --public-address 127.0.0.1:32323 can be set by creating a config file: public_address=\"127.0.0.1:32323\" If you are going to set up a node and let it join the Conflux mainnet(testnet), you need to set the public_address appropriately. It should be set as the IP address of your node which can be accessed publicly from Internet. If your node is covered under a public gateway, you can get its public address by searching \"ip\" in Baidu . If you want to let your node participate the mining process, you need to enable it by setting start_mining as \"true\" and mining_author as the account address that receives the mining reward. Running Test \u00b6 We have both unit tests written in Rust and integration tests written in python. After you make some modifications to the code, you can run these tests to see if the system still runs correctly. First, you need to install the dependencies as instructed in Install Test Dependencies . Then you can run the tests as follows Linux: $ ./dev-support/test.sh This will automatically run the unit tests in our Rust code and the python tests. Others: To run unit tests in Rust: $ cargo test --release --all To run python integration tests: $ ./tests/test_all.py Using Conflux Web Wallet \u00b6 You can access Conflux web wallet and create a new wallet by clicking \"New Wallet\" button that provides you a seed phrase (used to restore your wallet if you close it) and a password (used to unlock your wallet if you lock it when you leave your computer). Once a wallet is created, you can then manage your account addresses, send transactions, and deploy smart contract. In order to issue on-chain operations, you will need Conflux tokens. You can periodically (1 Conflux token per hour) get Conflux tokens from a faucet account. A pop-up box will appear to inform you to get the tokens. For developers to build smart contract, you can use remix to write and compile your contract to generate bytecode which you can then copy-paste to \"Contract\" page of the wallet that is triggered by action \"Contract\".","title":"Getting Started"},{"location":"get_started/#running-conflux-full-node","text":"First, please build the binary as instructed in Installation . To start Conflux manually, you need to edit the default configuration file run/default.toml : Set public_address according to your public IP. The port should be 32323 by default. Set mining_author to the account address to receive mining reward. Conflux team has maintained some full nodes for the test net, and they have been provided as bootnodes . If you want to use other nodes to bootstrap your new node, you should edit this entry. Then you can run the following commands: $ cd run $ ../target/release/conflux --config default.toml It will start a full node and begin syncing the Conflux testnet blockchain. Note that two new directories ( blockchain_db and net_config ) will be created in the current working directory ( run ) to keep the persistent data. Please do not remove them unless data are corrupt or you want to start a fresh new node. To restart a node, just run the same command line in the same directory.","title":"Running Conflux Full Node"},{"location":"get_started/#configuring-conflux-full-node","text":"Conflux can be configured using either the CLI options or a config file. Should the CLI flags and the config file disagree about a setting, the CLI takes precedence. The config file follows the format of TOML . The path of the configuration file can be set with the CLI option --config path/to/conflux.toml . A default configuration file default.toml with every configuration explained has been provided in the directory run , and you can start customizing your configuration from there. You can list all CLI options by running $ ./conflux --help . The vast majority of CLI options map to a setting in the TOML file, for example --public-address 127.0.0.1:32323 can be set by creating a config file: public_address=\"127.0.0.1:32323\" If you are going to set up a node and let it join the Conflux mainnet(testnet), you need to set the public_address appropriately. It should be set as the IP address of your node which can be accessed publicly from Internet. If your node is covered under a public gateway, you can get its public address by searching \"ip\" in Baidu . If you want to let your node participate the mining process, you need to enable it by setting start_mining as \"true\" and mining_author as the account address that receives the mining reward.","title":"Configuring Conflux Full Node"},{"location":"get_started/#running-test","text":"We have both unit tests written in Rust and integration tests written in python. After you make some modifications to the code, you can run these tests to see if the system still runs correctly. First, you need to install the dependencies as instructed in Install Test Dependencies . Then you can run the tests as follows Linux: $ ./dev-support/test.sh This will automatically run the unit tests in our Rust code and the python tests. Others: To run unit tests in Rust: $ cargo test --release --all To run python integration tests: $ ./tests/test_all.py","title":"Running Test"},{"location":"get_started/#using-conflux-web-wallet","text":"You can access Conflux web wallet and create a new wallet by clicking \"New Wallet\" button that provides you a seed phrase (used to restore your wallet if you close it) and a password (used to unlock your wallet if you lock it when you leave your computer). Once a wallet is created, you can then manage your account addresses, send transactions, and deploy smart contract. In order to issue on-chain operations, you will need Conflux tokens. You can periodically (1 Conflux token per hour) get Conflux tokens from a faucet account. A pop-up box will appear to inform you to get the tokens. For developers to build smart contract, you can use remix to write and compile your contract to generate bytecode which you can then copy-paste to \"Contract\" page of the wallet that is triggered by action \"Contract\".","title":"Using Conflux Web Wallet"},{"location":"install/","text":"Here is a step by step guide on how to build Conflux from the source code and get a node running. Install Build Dependencies \u00b6 Conflux requires Rust 1.42.0 to build, clang , and sqlite to build. We recommend installing Rust through rustup . If you don't already have rustup or clang , you can install them like this: Linux: $ curl https://sh.rustup.rs -sSf | sh $ rustup install 1.42.0 clang and sqlite can be installed with: Ubuntu: $ sudo apt-get install clang libsqlite3-dev CentOS / RHEL: $ sudo yum install clang sqlite-devel OSX: $ curl https://sh.rustup.rs -sSf | sh $ rustup install 1.42.0 You might need to install brew if you need to use it to install clang : $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" clang comes with Xcode command line tools, and can also be installed with homebrew: $ brew install llvm Windows: Make sure you have Visual Studio 2015 with C++ support installed. Next, download and run the rustup installer from https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe, start \"VS2015 x64 Native Tools Command Prompt\", and use the following command to install and set up the msvc toolchain: $ rustup default stable-x86_64-pc-windows-msvc clang can be installed with LLVM. Pre-built binaries can be downloaded from Download LLVM . Make sure to add LLVM to the system PATH as instructed. Make sure that these binaries are in your PATH (the instruction will be shown after installing rustup ). After that, you should be able to build Conflux from source. Build from Source Code \u00b6 After installing the dependencies mentioned above, now you can clone our repository and start building the executable binary: # download Conflux code $ git clone https://github.com/Conflux-Chain/conflux-rust $ cd conflux-rust $ git checkout v0.1.7 # build in release mode $ cargo build --release This produces an executable in the ./target/release subdirectory. You may encounter dependency issues in Ubuntu. If so, you will want to install libssl-dev and cmake pacakges with the following command: | $ sudo apt-get install pkg-config libssl-dev cmake Note, when compiling a crate and you receive errors, it's in most cases your outdated version of Rust, or some of your crates have to be recompiled. Cleaning the repository will most likely solve the issue if you are on the latest stable version of Rust, try: $ cargo clean && cargo update To start running a Conflux full node, you can follow the instructions at Running Conflux Full Node . Install Test Dependencies \u00b6 We have a test framework written in Python3 (version>=3.6). Required packages can be installed by running $ ./dev-support/dep_pip3.sh Solidity compiler solc is also required, and be installed as follows: Ubuntu sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc OSX brew update brew upgrade brew tap ethereum/ethereum brew install solidity Others You can follow the detailed instructions at Installing the Solidity Compiler . Note that latest solidity compiler may be incompatible with Conflux and may cause the integration test to fail. If you encounter such problem, please install solidity compiler version 0.5.2. To run tests, you can build the source code first and follow the instructions at Running Test .","title":"Installation"},{"location":"install/#install-build-dependencies","text":"Conflux requires Rust 1.42.0 to build, clang , and sqlite to build. We recommend installing Rust through rustup . If you don't already have rustup or clang , you can install them like this: Linux: $ curl https://sh.rustup.rs -sSf | sh $ rustup install 1.42.0 clang and sqlite can be installed with: Ubuntu: $ sudo apt-get install clang libsqlite3-dev CentOS / RHEL: $ sudo yum install clang sqlite-devel OSX: $ curl https://sh.rustup.rs -sSf | sh $ rustup install 1.42.0 You might need to install brew if you need to use it to install clang : $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" clang comes with Xcode command line tools, and can also be installed with homebrew: $ brew install llvm Windows: Make sure you have Visual Studio 2015 with C++ support installed. Next, download and run the rustup installer from https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe, start \"VS2015 x64 Native Tools Command Prompt\", and use the following command to install and set up the msvc toolchain: $ rustup default stable-x86_64-pc-windows-msvc clang can be installed with LLVM. Pre-built binaries can be downloaded from Download LLVM . Make sure to add LLVM to the system PATH as instructed. Make sure that these binaries are in your PATH (the instruction will be shown after installing rustup ). After that, you should be able to build Conflux from source.","title":"Install Build Dependencies"},{"location":"install/#build-from-source-code","text":"After installing the dependencies mentioned above, now you can clone our repository and start building the executable binary: # download Conflux code $ git clone https://github.com/Conflux-Chain/conflux-rust $ cd conflux-rust $ git checkout v0.1.7 # build in release mode $ cargo build --release This produces an executable in the ./target/release subdirectory. You may encounter dependency issues in Ubuntu. If so, you will want to install libssl-dev and cmake pacakges with the following command: | $ sudo apt-get install pkg-config libssl-dev cmake Note, when compiling a crate and you receive errors, it's in most cases your outdated version of Rust, or some of your crates have to be recompiled. Cleaning the repository will most likely solve the issue if you are on the latest stable version of Rust, try: $ cargo clean && cargo update To start running a Conflux full node, you can follow the instructions at Running Conflux Full Node .","title":"Build from Source Code"},{"location":"install/#install-test-dependencies","text":"We have a test framework written in Python3 (version>=3.6). Required packages can be installed by running $ ./dev-support/dep_pip3.sh Solidity compiler solc is also required, and be installed as follows: Ubuntu sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc OSX brew update brew upgrade brew tap ethereum/ethereum brew install solidity Others You can follow the detailed instructions at Installing the Solidity Compiler . Note that latest solidity compiler may be incompatible with Conflux and may cause the integration test to fail. If you encounter such problem, please install solidity compiler version 0.5.2. To run tests, you can build the source code first and follow the instructions at Running Test .","title":"Install Test Dependencies"},{"location":"javascript-api/","text":"Getting Started with ConfluxWeb \u00b6 The conflux-web library is a collection of modules which contain specific functionality for the conflux ecosystem. The conflux-web-cfx is for the conflux blockchain and smart contracts. The conflux-web-utils contains useful helper functions for Dapp developers. Adding conflux-web First you need to get conflux-web into your project. This can be done using the following methods: npm: npm install conflux-web After that you need to create a confluxWeb instance and set a provider. Normally you should connect to a remote/local node. const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); That\u2019s it! now you can use the confluxWeb object. Using Promises All of functions use asynchronous HTTP requests and return promises by default: const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); confluxWeb.cfx.getEpochNumber().then(console.log); A note on big numbers You will always get a BigNumber object for number values as JavaScript is not able to handle big numbers correctly. Look at the following examples: \"101010100324325345346456456456456456456\" // \"101010100324325345346456456456456456456\" 101010100324325345346456456456456456456 // 1.0101010032432535e+38 ConfluxWeb depends on the BN.js library for big numbers, See the BN.js documentation for details. ConfluxWeb by Example \u00b6 Hash Time Locked Contract \u00b6 Here we brought you a ConfluxWeb example. You can learn how to develop a Hash Time Locked Contract (HTLC) with ConfluxWeb API. ConfluxWeb API Reference \u00b6 ConfluxWeb \u00b6 ConfluxWeb.providers \u00b6 Class attribute object Example \u00b6 > ConfluxWeb.providers { HttpProvider: [Function: HttpProvider$1], WebsocketProvider: [Function: WebsocketProvider$1], IpcProvider: [Function: IpcProvider$1] } ConfluxWeb.modules \u00b6 Class attribute object Example \u00b6 > ConfluxWeb.modules { Cfx: [Function: Cfx], Net: [Function: Net] } ConfluxWeb.utils \u00b6 Class attribute Object attribute Property of ConfluxWeb class and instance of ConfluxWeb, See confluxWeb.utils for more. object Example \u00b6 > ConfluxWeb.utils {...} > confluxWeb.utils {...} ConfluxWeb.version \u00b6 Object attribute current version string Example \u00b6 > confluxWeb.version 0.1.21-alpha.0 ConfluxWeb.currentProvider \u00b6 Object attribute current provider instance object Example \u00b6 > confluxWeb.currentProvider; HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... } ConfluxWeb.setProvider \u00b6 Will change the provider for its module. NOTE: When called on the umbrella package cfx it will also set the provider for all sub modules confluxWeb.cfx, etc. function setProvider(provider) Parameters \u00b6 Name Type Required Default Description provider object true A valid provider. Return \u00b6 boolean Example \u00b6 > const ConfluxWeb = require('conflux-web'); > const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); > confluxWeb.currentProvider HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... } > confluxWeb.setProvider(new ConfluxWeb.providers.HttpProvider('http://localhost:12537')); true > confluxWeb.currentProvider HttpProvider { host: 'http://localhost:12537' ... } > confluxWeb.setProvider('http://localhost:12537'); // same as above true > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.setProvider('http://localhost:12537') // change all provider > confluxWeb.currentProvider.host \"http://localhost:12537\" > confluxWeb.cfx.currentProvider.host \"http://localhost:12537\" ConfluxWeb.cfx.Contract \u00b6 ConfluxWeb.cfx.Contract.abiModel \u00b6 abi object Object Example \u00b6 > contract.abiModel AbiModel { abi: { methods: { count: [AbiItemModel], '0x06661abd': [AbiItemModel], 'count()': [AbiItemModel], inc: [AbiItemModel], '0x812600df': [AbiItemModel], 'inc(uint256)': [AbiItemModel], contractConstructor: [AbiItemModel] }, events: {} } } ConfluxWeb.cfx.Contract.address \u00b6 The address used for this contract instance. All transactions generated by confluxWeb from this contract will contain this address as the \"to\". string Example \u00b6 > contract.address; // What you set when new contract. \"0xf02dbcf0eff48e174ca59f1975a7b0042c4d02b7\" ConfluxWeb.cfx.Contract.defaultGas \u00b6 The default maximum gas provided for a transaction (gasLimit). number ConfluxWeb.cfx.Contract.defaultGasPrice \u00b6 The default gas price in drip to use for transactions. number ConfluxWeb.cfx.Contract.methods \u00b6 Creates a transaction object for that method, which then can be called, send, estimated. The methods of this smart contract are available through: The name: myContract.methods.myMethod(123) The name with parameters: myContract.methods 'myMethod(uint256)' The signature: myContract.methods '0x58cf5f10' This allows calling functions with same name but different parameters from the JavaScript contract object. Proxy Example \u00b6 > contract.address; \"0x079352147ce2de227af6fa963f603a35aed8e601\" > await contract.methods.count().call(); BigNumber { _hex: '0xfe' } > await contract.methods.inc(1).call(); // call will get function return value BigNumber { _hex: '0xff' } > await contract.methods.count().call(); // can not change data in block chain by `call` BigNumber { _hex: '0xfe' } > await contract.methods.inc(1).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 100 }); // send a transaction \"0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a\" > await confluxWeb.cfx.getTransactionReceipt('0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a'); { status: true, ... } > await contract.methods.count().call(); // change data in block chain by `send` BigNumber { _hex: '0xff' } ConfluxWeb.cfx.Contract.constructor \u00b6 Creates a new contract instance with all its methods and events defined in its json interface abi object. function constructor(abi,address,options) Parameters \u00b6 Name Type Required Default Description abi object|array true The abi json interface of the contract. address string false The address where the contract is deployed. If undefined, you should deploy contract by data. options object false options.data string false The byte code of the contract. Used when the contract gets deployed. options.from string false The address transactions should be made from. options.gasPrice string false The gas price in drip to use for transactions. options.gas number false The maximum gas provided for a transaction (gasLimit). Return \u00b6 void Example \u00b6 > confluxWeb.cfx.accounts.wallet.add('0xa816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY > const contract = new confluxWeb.cfx.Contract( [ { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"name\": \"inc\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" } ], ); ConfluxWeb.cfx.Contract.deploy \u00b6 function deploy(options) Parameters \u00b6 Name Type Required Default Description options object true options.data string false contract data options.arguments array false contract constructor parameters Return \u00b6 Object Example \u00b6 > await contract.deploy({arguments: [254]}).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 819 }); // deploy contract by `send` \"0x6d1b5d68540faac893e5d5dcfed7fc253a2fd6936634f917c82856a0b19c3838\" > await confluxWeb.cfx.getTransactionReceipt('0xd1d5b66b0d3d215f042f3e4907a3bf0acf5984972527fbca45eb67286835260d'); { status: true, contractCreated: '0x079352147ce2de227af6fa963f603a35aed8e601', ... } > contract.address = '0x079352147ce2de227af6fa963f603a35aed8e601'; // after deploy, you should add address to contract ConfluxWeb.cfx.Contract.clone \u00b6 Clones the current contract instance. function clone() Parameters \u00b6 void Return \u00b6 Object The new contract instance. Example \u00b6 > const clone = contract.clone() > contract.defaultGas === clone.defaultGas; true > contract.defaultGasPrice === clone.defaultGasPrice; true > contract.address === clone.address; // only address difference, and clone one address to be undefined false ConfluxWeb.cfx \u00b6 ConfluxWeb.cfx.defaultAccount \u00b6 This default address is used as the default \"from\" property. 20 Bytes: Any Conflux address. You should have the private key for that address in your node or keystore. string|undefined Example \u00b6 > confluxWeb.cfx.defaultAccount undefined > confluxWeb.cfx.defaultAccount = '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b'; > confluxWeb.cfx.defaultAccount \"0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b\" ConfluxWeb.cfx.defaultEpoch \u00b6 When requests are made that act on the state of conflux, the default epoch parameter determines the height of the epoch. The following options are possible for the default epoch parameter: number : An integer epoch number. \"earliest\" : The earliest epoch where the genesis block in. \"latest_state\" : The latest epoch where the latest block with an executed state in. (default) \"latest_mined\" : The latest epoch where the latest mined block in. number|string Example \u00b6 > confluxWeb.cfx.defaultEpoch; // Default is \"latest_state\" \"latest_state\" ConfluxWeb.cfx.currentProvider \u00b6 Will return the current provider, otherwise null object|null Example \u00b6 > confluxWeb.cfx.currentProvider HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... } ConfluxWeb.cfx.setProvider \u00b6 Will change the provider for its module. function setProvider(cfxProvider) Parameters \u00b6 Name Type Required Default Description cfxProvider object true A valid provider. Return \u00b6 boolean Example \u00b6 > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.setProvider('http://localhost:12537') // change module provider > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://localhost:12537\" ConfluxWeb.cfx.getGasPrice \u00b6 Returns the current gas price oracle. The gas price is determined by the last few blocks median gas price. async function getGasPrice() Parameters \u00b6 void Return \u00b6 Promise.<string> Number string of the current gas price in drip. Example \u00b6 > await confluxWeb.cfx.getGasPrice() \"0\" ConfluxWeb.cfx.getEpochNumber \u00b6 Returns the current epoch number the client is on. async function getEpochNumber() Parameters \u00b6 void Return \u00b6 Promise.<number> Example \u00b6 > await confluxWeb.cfx.getEpochNumber(); 990902 ConfluxWeb.cfx.getBalance \u00b6 Get the balance of an address at a given epoch. async function getBalance(address,defaultEpoch) Parameters \u00b6 Name Type Required Default Description address string true The address to get the balance of. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch. Return \u00b6 Promise.<string> The current balance for the given address in drip. Example \u00b6 > await confluxWeb.cfx.getBalance(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\"); \"685539999999937000\" > await confluxWeb.cfx.getBalance(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\", \"earliest\"); \"0\" ConfluxWeb.cfx.getCode \u00b6 Get the code at a specific address. async function getCode(address,defaultEpoch) Parameters \u00b6 Name Type Required Default Description address string true The address to get the code from. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch. Return \u00b6 Promise.<string> The data at given address Example \u00b6 > await confluxWeb.cfx.getCode(\"0x079352147ce2de227af6fa963f603a35aed8e601\"); \"0x6080604052348015600f57600080fd5b506004361060325760003560e01c806306661abd146037578063812600df146053575b600080fd5b603d6092565b6040518082815260200191505060405180910390f35b607c60048036036020811015606757600080fd5b81019080803590602001909291905050506098565b6040518082815260200191505060405180910390f35b60005481565b60008160008082825401925050819055905091905056fea265627a7a723158203aa4346abf52089d9be8806b8bf35dff408bd9f68f668e528bc8e2e20d74b29064736f6c634300050b0032\" ConfluxWeb.cfx.getBlock \u00b6 Returns a block matching the block number or block hash. async function getBlock(blockHashOrEpochNumber,returnTransactionObjects) Parameters \u00b6 Name Type Required Default Description blockHashOrEpochNumber string|number true The block hash or epoch. returnTransactionObjects boolean false false If true, the returned block will contain all transactions as objects, if false it will only contains the transaction hashes. Return \u00b6 Promise.<object> The block object string miner: The address of the beneficiary to whom the mining rewards were given. string|null hash: Hash of the block. null when its pending block. string parentHash: Hash of the parent block. string[] refereeHashes: Array of referee hashes. number|null epochNumber: The current block epoch number in the client's view. null when it's not in best block's past set. boolean stable: If the block stable or not string nonce: Hash of the generated proof-of-work. null when its pending block. number gasLimit: The maximum gas allowed in this block. string difficulty: Integer string of the difficulty for this block. number height: The block heights. null when its pending block. number size: Integer the size of this block in bytes. number blame: 0 if there's nothing to blame; k if the block is blaming on the state info of its k-th ancestor. boolean adaptive: If the block's weight adaptive or not. number timestamp: The unix timestamp for when the block was collated. string transactionsRoot: The hash of the transactions of the block. string[] transactions: Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. string deferredLogsBloomHash: The hash of the deferred block's log bloom filter string deferredReceiptsRoot: The hash of the receipts of the block after deferred execution. string deferredStateRoot: The root of the final state trie of the block after deferred execution. object deferredStateRootWithAux: Information of deferred state root Example \u00b6 > await confluxWeb.cfx.getBlock(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\"); { \"miner\": \"0x0000000000000000000000000000000000000015\", \"hash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"parentHash\": \"0xa378c9e283c08eac0e2ac51a8c19e61717af812a157eb914d35b171ed20920b9\", \"refereeHashes\": [], \"epochNumber\": 925836, \"stable\": true, \"nonce\": \"0xaaa4a571ad424ec\", \"gasLimit\": 3000000000, \"difficulty\": \"21351313\", \"height\": 925836, \"size\": 384, \"blame\": 0, \"adaptive\": false, \"timestamp\": 1570608173, \"transactionsRoot\": \"0xbe7a9e531d55ed950a217272afa035f57f6c512ca249bae19e214cf2b470562e\" \"transactions\": [ \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\" ], \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xc4ec82320df3b5ce48e22d33cc82f665a274dc920796a3e206be44682b7812a2\", \"deferredStateRootWithAux\": { \"auxInfo\": { \"intermediateDeltaEpochId\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"previousSnapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"stateRoot\": { \"deltaRoot\": \"0xbc71c52f0dae840fd8815de081a2774927077714a5fe7c342b0e5e81f7bcd38e\", \"intermediateDeltaRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"snapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" } }, } > await confluxWeb.cfx.getBlock(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", true); { \"adaptive\": false, \"blame\": 0, \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xc4ec82320df3b5ce48e22d33cc82f665a274dc920796a3e206be44682b7812a2\", \"deferredStateRootWithAux\": { \"auxInfo\": { \"intermediateDeltaEpochId\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"previousSnapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"stateRoot\": { \"deltaRoot\": \"0xbc71c52f0dae840fd8815de081a2774927077714a5fe7c342b0e5e81f7bcd38e\", \"intermediateDeltaRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"snapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" } }, \"difficulty\": \"21351313\", \"epochNumber\": 925836, \"gasLimit\": 3000000000, \"hash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"height\": 925836, \"miner\": \"0x0000000000000000000000000000000000000015\", \"nonce\": \"0xaaa4a571ad424ec\", \"parentHash\": \"0xa378c9e283c08eac0e2ac51a8c19e61717af812a157eb914d35b171ed20920b9\", \"refereeHashes\": [], \"size\": 384, \"stable\": true, \"timestamp\": 1570608173, \"transactions\": [ { \"blockHash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"contractCreated\": null, \"data\": \"0x\", \"from\": \"0xA70ddf9B9750c575Db453Eea6A041f4C8536785A\", \"gas\": 21000, \"gasPrice\": \"819\", \"hash\": \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\", \"nonce\": 921, \"r\": \"0x985743d5d627e8f93e243bfd71e401f7bf5c7b098afeb910952df789312cc7b1\", \"s\": \"0xaaf07bc11d56516f90697fb0f1b8140ec9b252c66e8f3172799e2829d457775\", \"status\": \"0x0\", \"to\": \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\", \"transactionIndex\": 0, \"v\": 1, \"value\": \"1000000000000000000\" } ], \"transactionsRoot\": \"0xbe7a9e531d55ed950a217272afa035f57f6c512ca249bae19e214cf2b470562e\" } ConfluxWeb.cfx.getTransaction \u00b6 Returns a transaction matching the given transaction hash. async function getTransaction(transactionHash) Parameters \u00b6 Name Type Required Default Description transactionHash string true The transaction hash. Return \u00b6 Promise.<object> The transaction object string blockHash: Hash of the block where this transaction was in and got executed. null when its pending. number transactionIndex: Integer of the transactions index position in the block. string hash: Hash of the transaction. number nonce: The number of transactions made by the sender prior to this one. string from: Address of the sender. string to: Address of the receiver. null when its a contract creation transaction. string value: Value transferred in Drip. string data: The data send along with the transaction. number gas: Gas provided by the sender. number gasPrice: Gas price provided by the sender in Drip. string status: '0x0' successful execution; '0x1' exception happened but nonce still increased; '0x2' exception happened and nonce didn't increase. string|null contractCreated: The contract address created, if the transaction was a contract creation, otherwise null. string r: ECDSA signature r string s: ECDSA signature s string v: ECDSA recovery id Example \u00b6 > await confluxWeb.cfx.getTransaction(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\"); { \"blockHash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"transactionIndex\": 0, \"hash\": \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\", \"nonce\": 921, \"from\": \"0xA70ddf9B9750c575Db453Eea6A041f4C8536785A\", \"to\": \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\", \"value\": \"1000000000000000000\" \"data\": \"0x\", \"gas\": 21000, \"gasPrice\": \"819\", \"status\": \"0x0\", \"contractCreated\": null, \"r\": \"0x985743d5d627e8f93e243bfd71e401f7bf5c7b098afeb910952df789312cc7b1\", \"s\": \"0xaaf07bc11d56516f90697fb0f1b8140ec9b252c66e8f3172799e2829d457775\", \"v\": 1, } ConfluxWeb.cfx.getTransactionCount \u00b6 Get the numbers of transactions sent from this address. async function getTransactionCount(address,defaultEpoch) Parameters \u00b6 Name Type Required Default Description address string true The address to get the numbers of transactions from. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch. Return \u00b6 Promise.<number> The number of transactions sent from the given address. Example \u00b6 > await confluxWeb.cfx.getTransactionCount(\"0xa70ddf9b9750c575db453eea6a041f4c8536785a\"); 974 > await confluxWeb.cfx.getTransactionCount(\"0xa70ddf9b9750c575db453eea6a041f4c8536785a\", 'earliest'); 0 ConfluxWeb.cfx.sendSignedTransaction \u00b6 Sends an already signed transaction, generated for example using confluxWeb.cfx.accounts.signTransaction async function sendSignedTransaction(signedTransactionData) Parameters \u00b6 Name Type Required Default Description signedTransactionData string true Signed transaction data in HEX format Return \u00b6 Promise.<string> Transaction hash Example \u00b6 > const ConfluxTx = require('confluxjs-transaction'); > const tx = new ConfluxTx({ nonce: '0x03', gasPrice: '0x01', gasLimit: '0x5208', // 21000 to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', // ADDRESS_TO value: '0x01', }); > tx.sign(Buffer.from('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393', 'hex')); // KEY_FROM > await confluxWeb.cfx.sendSignedTransaction('0x' + tx.serialize().toString('hex')); 0x200b930e95b3c8c54978499c6407ef71fc96a83eced88640fae59b75e1d16ef4 ConfluxWeb.cfx.signTransaction \u00b6 Signs a transaction. This account needs to be unlocked. async function signTransaction(rawTx) Parameters \u00b6 Name Type Required Default Description rawTx object true rawTx.from number true An address or index of a local wallet in confluxWeb.cfx.accounts.wallet. rawTx.to string false The destination address of the message, left undefined for a contract-creation transaction. rawTx.value number|string|BN|BigNumber false The value transferred for the transaction in drip, also the endowment if it\u2019s a contract-creation transaction. rawTx.gas number false To-Be-Determined The amount of gas to use for the transaction (unused gas is refunded). rawTx.gasPrice number|string|BN|BigNumber false confluxWeb.cfx.gasPrice The price of gas for this transaction in drip. rawTx.data string false Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code. rawTx.nonce number false Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce. Return \u00b6 Promise.<object> The RLP encoded transaction. The raw property can be used to send the transaction using confluxWeb.cfx.sendSignedTransaction. string rawTransaction: Raw transaction string string messageHash: Hash of transaction for calculating signature string r: ECDSA signature r string s: ECDSA signature s string v: ECDSA recovery id Example \u00b6 > confluxWeb.cfx.accounts.wallet.add('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY_FROM > await confluxWeb.cfx.signTransaction({ from: 0, // index nonce: 0, // make nonce appropriate gasPrice: 10, gas: 21000, value: new BN('300000000000000000'), // 300000000000000000 drip === 0.3 cfx token to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', // ADDRESS_TO data: '', }); { \"messageHash\": \"53aec3cdccb8ab438303ece4559fc4464a118416828d8c7c0427f5debcd8feae\", \"r\": \"0x1feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2\", \"s\": \"0x0451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67\", \"v\": \"0x01\", \"rawTransaction\": \"0xf867800a825208941ead8630345121d19ee3604128e5dc54b36e8ea6880429d069189e00008001a01feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2a00451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67\" } ConfluxWeb.cfx.call \u00b6 Executes a message call transaction, which is directly executed in the VM of the node, but never mined into the blockchain. async function call(callObject,defaultEpoch) Parameters \u00b6 Name Type Required Default Description callObject object true A transaction object, with the difference that for calls the from property is optional as well. defaultEpoch string|number false conflux.cfx.defaultEpoch Return \u00b6 Promise.<string> The returned data of the call, e.g. A smart contract functions return value. Example \u00b6 > await confluxWeb.cfx.call({ to: \"0x11f4d0a3c12e86b4b5f39b213f7e19d048276dae\", // contract address data: \"0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\" }) 0x000000000000000000000000000000000000000000000000000000000000000a ConfluxWeb.cfx.estimateGas \u00b6 Executes a message call or transaction and returns the amount of the gas used. async function estimateGas(callObject) Parameters \u00b6 Name Type Required Default Description callObject object true A transaction object, with the difference that for calls the from property is optional as well. Return \u00b6 Promise.<number> - the used gas for the simulated call/transaction. Example \u00b6 > await confluxWeb.cfx.estimateGas({ to: \"0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe\", data: \"0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\" }) 0x0000000000000000000000000000000000000000000000000000000000000015 ConfluxWeb.cfx.getTransactionReceipt \u00b6 Returns the receipt of a transaction by transaction hash. NOTE: The receipt is not available for pending transactions and returns null. async function getTransactionReceipt(txHash) Parameters \u00b6 Name Type Required Default Description txHash string true The transaction hash. Return \u00b6 Promise.<object> A transaction receipt object, or null when no receipt was found. boolean status: true if the transaction was successful; false , if the EVM reverted the transaction. number outcomeStatus: 1 status true ; 0 status false . string stateRoot: The state root of transaction execution. number epochNumber: Epoch number where this transaction was in. string blockHash: Hash of the block where this transaction was in. string transactionHash: Hash of the transaction. number index: Integer of the transactions index position in the block. string from: Address of the sender. string to: Address of the receiver. null when its a contract creation transaction. string|null contractCreated: The contract address created, if the transaction was a contract creation, otherwise null. number gasUsed: The amount of gas used by this specific transaction alone. [object] logs: Array of log objects, which this transaction generated. [string] logs[].address: The address of the contract executing at the point of the LOG operation. [string] logs[].topics: The topics associated with the LOG operation. [string] logs[].data: The data associated with the LOG operation. string logsBloom: Example \u00b6 > await confluxWeb.cfx.getTransactionReceipt('0x689258ba9fe2c25bcdc43ebb5c9018d1b56d25b1c87de1b371a19f5548c16dc1'); { status: true, outcomeStatus: 0, stateRoot: '0x75df853d267b40a98f6fe1103a510822bc1582894e8a9e95eb9ff0697545e4d2', epochNumber: 1017673, blockHash: '0xdefb3add0256b12c80f6e4fddde81da9c93ec88861cbee14051379f79624f911', transactionHash: '0x689258ba9fe2c25bcdc43ebb5c9018d1b56d25b1c87de1b371a19f5548c16dc1', index: 0, from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', contractCreated: null, gasUsed: 21000, logs: [], logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', } ConfluxWeb.cfx.getPastLogs \u00b6 Gets past logs, matching the given options. async function getPastLogs(options) Parameters \u00b6 Name Type Required Default Description options object true options.fromEpoch string false The number of the earliest block options.toEpoch string false The number of the latest block options.address string|Array[string] true An address or a list of addresses to only get logs from particular account(s). options.topics array true An array of values which must each appear in the log entries. The order is important, if you want to leave topics out use null, e.g. [null, '0x12...']. You can also pass an array for each topic with options for that topic e.g. [null, ['option1', 'option2']] Return \u00b6 Promise.<Array.<object>> Array of log objects. Example \u00b6 > await confluxWeb.cfx.getPastLogs({ fromEpoch: '0x0', toEpoch: 'latest_mined', address: '0x169a10a431130B2F4853294A4a966803668af385' }); [ { \"address\": \"0x169a10a431130B2F4853294A4a966803668af385\", \"blockHash\": \"0x9f18cbbbc432d678b94ee6446e9305abf8f02deb0b03877cc0c71c0a71c08faf\", \"epochNumber\": \"0x0\", \"data\": \"0x\", \"logIndex\": 0, \"removed\": false, \"topics\": [ \"0x44d6d25963f097ad14f29f06854a01f575648a1ef82f30e562ccd3889717e339\", \"0x000000000000000000000000c24a31039a4dfc9ee9039bd9241a0c7848b92ae1\" ], \"transactionHash\": \"0xb777fc8ee9c5b5f6eb2b1c7d73106f07eb1692b9db08d9f65affafb82641559f\", \"transactionIndex\": 0, \"transactionLogIndex\": \"0x0\", \"type\": \"mined\", \"id\": \"log_0x5157483fef4019b6a231963496322bbf123b2559f73eef47f60dd5d1b1364fe4\" }, ... ] ConfluxWeb.cfx.account \u00b6 ConfluxWeb.cfx.account.create \u00b6 Generates an account object with private key and public key. NOTE: compare to eth latest, we don\u2019t have sign methods in the return account object function create(entropy) Parameters \u00b6 Name Type Required Default Description entropy string false A random string to increase entropy. If given it should be at least 32 characters. If none is given a random string will be generated using randomHex. Return \u00b6 object The account object. Example \u00b6 > confluxWeb.cfx.accounts.create(); Account { address: '0xbaE14daA250D6BCE69E695217AE8B3ce1dfF7AAe', privateKey: '0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399', ... } ConfluxWeb.cfx.account.privateKeyToAccount \u00b6 Creates an account object from a private key. NOTE: compare to eth latest, we don\u2019t have sign methods in the return account object function privateKeyToAccount(privateKey) Parameters \u00b6 Name Type Required Default Description privateKey string true The private key to convert. Return \u00b6 object The account object. Example \u00b6 > confluxWeb.cfx.accounts.privateKeyToAccount('0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399'); Account { address: '0xbaE14daA250D6BCE69E695217AE8B3ce1dfF7AAe', privateKey: '0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399', ... } ConfluxWeb.cfx.account.recoverTransaction \u00b6 Recovers the Conflux address which was used to sign the given RLP encoded transaction. function recoverTransaction(rawTransaction) Parameters \u00b6 Name Type Required Default Description rawTransaction string true The RLP encoded transaction. Return \u00b6 string The Conflux address used to sign this transaction. Example \u00b6 > confluxWeb.cfx.accounts.recoverTransaction('0xf867800a825208941ead8630345121d19ee3604128e5dc54b36e8ea6880429d069189e00008001a01feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2a00451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67'); \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\" ConfluxWeb.cfx.account.hashMessage \u00b6 function hashMessage(message) Parameters \u00b6 Name Type Required Default Description message string true A message to hash, if its HEX it will be UTF8 decoded before. Return \u00b6 string The hashed message Example \u00b6 > confluxWeb.cfx.accounts.hashMessage(\"Hello World\"); \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\" > confluxWeb.cfx.accounts.hashMessage(confluxWeb.cfx.utf8ToHex(\"Hello World\")); // the below results in the same hash \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\" ConfluxWeb.cfx.account.sign \u00b6 Signs arbitrary data. This data is before UTF-8 HEX decoded and enveloped as follows: \"\\x19Ethereum Signed Message:\\n\" + message.length + message function sign(data,privateKey) Parameters \u00b6 Name Type Required Default Description data string true The data to sign. privateKey string true The private key to sign with. Return \u00b6 object Example \u00b6 > confluxWeb.cfx.accounts.sign('Hello World', 'a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); { \"message\": \"Hello World\", \"messageHash\": \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\", \"v\": \"0x1b\", \"r\": \"0x14e05a1ff41165dc420414e96acd7710a49ff05eecbd2caf520ac8d2e37426b0\", \"s\": \"0x4236443a89cd5a5d14559bc5c115988b704d40dea7e39ed087ae80cd7822f99c\", \"signature\": \"0x14e05a1ff41165dc420414e96acd7710a49ff05eecbd2caf520ac8d2e37426b04236443a89cd5a5d14559bc5c115988b704d40dea7e39ed087ae80cd7822f99c1b\" } ConfluxWeb.cfx.account.recover \u00b6 Recovers the Conflux address which was used to sign the given data. confluxWeb.cfx.accounts.recover(message, signature [, preFixed]); confluxWeb.cfx.accounts.recover(message, v, r, s [, preFixed]); confluxWeb.cfx.accounts.recover(signatureObject); function recover(message,signature,r,s,v,preFixed,signatureObject) Parameters \u00b6 Name Type Required Default Description message string true signature string true The raw RLP encoded signature, OR parameter 2-4 as v, r, s values. r string true First 32 bytes of the signature s string true Next 32 bytes of the signature v string true Recovery value preFixed boolean false false If the last parameter is true, the given message will NOT automatically be prefixed with \"\\x19Ethereum Signed Message:\\n\" + message.length + message, and assumed to be already prefixed. signatureObject object true signatureObject.messageHash string true The hash of the given message already prefixed with \"\\x19Ethereum Signed Message:\\n\" + message.length + message. signatureObject.r string true same as r signatureObject.s string true same as s signatureObject.v string true same as v Return \u00b6 string The Conflux address used to sign this data. Example \u00b6 > confluxWeb.cfx.accounts.recover({ messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655', v: '0x1', r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029' }) \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" > confluxWeb.cfx.accounts.recover('Some data', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a02901'); // message, signature \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" > confluxWeb.cfx.accounts.recover('Some data', '0x01', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029'); // message, v, r, s \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" ConfluxWeb.cfx.account.wallet \u00b6 ConfluxWeb.cfx.account.wallet.create \u00b6 Generates one or more accounts in the wallet. If wallets already exist they will not be overridden. function create(numberOfAccounts,entropy) Parameters \u00b6 Name Type Required Default Description numberOfAccounts number true Number of accounts to create. Leave empty to create an empty wallet. entropy string false A string with random characters as additional entropy when generating accounts. If given it should be at least 32 characters. Return \u00b6 object The wallet object Example \u00b6 > confluxWeb.cfx.accounts.wallet.create(2); Wallet { ... accounts: { '0': Account { address: '0x52B2a035bbC4263D46a327376195e86dbaAF0b42', privateKey: '0x9887b79bd08ac7ee5897a24c50ee366450edd706cd8cec637cbb91234638d6bb', accounts: [Accounts] }, '1': Account { address: '0x52B2a035bbC4263D46a327376195e86dbaAF0b42', privateKey: '0x9887b79bd08ac7ee5897a24c50ee366450edd706cd8cec637cbb91234638d6bb', accounts: [Accounts] }, }, ... } ConfluxWeb.cfx.account.wallet.add \u00b6 Adds an account using a private key or account object to the wallet. function add(account) Parameters \u00b6 Name Type Required Default Description account string|object true A private key or account object created with confluxWeb.cfx.accounts.create(). Return \u00b6 object The added account Example \u00b6 > confluxWeb.cfx.accounts.wallet.add('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); Account { address: '0x4060E99f892E052dF9F59126D3F1eF2240A5df97', privateKey: 'a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393', ... } ConfluxWeb.cfx.account.wallet.remove \u00b6 Removes an account from the wallet. function remove(address) Parameters \u00b6 Name Type Required Default Description address string|number true The account address, or index in the wallet. Return \u00b6 boolean true if the wallet was removed. false if it couldn\u2019t be found. Example \u00b6 > confluxWeb.cfx.accounts.wallet.remove('0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b'); true > confluxWeb.cfx.accounts.wallet.remove(0); true ConfluxWeb.cfx.account.wallet.clear \u00b6 Securely empties the wallet and removes all its accounts. function clear() Parameters \u00b6 void Return \u00b6 Object The wallet object. Example \u00b6 > confluxWeb.cfx.accounts.wallet.clear(); Wallet { accounts: {}, accountsIndex: 0 ... } ConfluxWeb.cfx.Contract.methods \u00b6 ConfluxWeb.cfx.Contract.methods.encodeABI \u00b6 Encodes the ABI for this method. This can be used to send a transaction, call a method, or pass it into another smart contracts method as arguments. NOTE: contract instance create code see Contract.constructor function encodeABI() Parameters \u00b6 void Return \u00b6 string The encoded ABI byte code to send via a transaction or call. Example \u00b6 > await contract.methods.inc(1).encodeABI(); \"0x812600df0000000000000000000000000000000000000000000000000000000000000001\" > await contract.methods.count().encodeABI(); \"0x06661abd\" ConfluxWeb.cfx.Contract.methods.estimateGas \u00b6 Will call estimate the gas a method execution will take when executed in the EVM without sending any transaction. The estimation can differ from the actual gas used when later sending a transaction, as the state of the smart contract can be different at that time. NOTE: contract instance create code see Contract.constructor async function estimateGas() Parameters \u00b6 void Return \u00b6 Promise.<number> Example \u00b6 > await contract.methods.inc(1).estimateGas(); 26928 > await contract.methods.count().estimateGas(); 21655 ConfluxWeb.cfx.Contract.methods.call \u00b6 Will call a \u201cconstant\u201d method and execute its smart contract method in the EVM without sending any transaction. Note calling can not alter the smart contract state. NOTE: contract instance create code see Contract.constructor async function call() Parameters \u00b6 void Return \u00b6 Promise contract method return value Example \u00b6 > await contract.methods.inc(1).call(); BigNumber { _hex: '0xff' } > await contract.methods.count().call(); BigNumber { _hex: '0xfe' } ConfluxWeb.cfx.Contract.methods.send \u00b6 Will send a transaction to the smart contract and execute its method. Note this can alter the smart contract state. NOTE: contract instance create code see Contract.constructor async function send(options) Parameters \u00b6 Name Type Required Default Description options object true options.from string true The address the transaction should be sent from. options.gasPrice string false contract.defaultGasPrice The gas price in wei to use for this transaction. options.gas number false contract.defaultGas The maximum gas provided for this transaction (gas limit). options.value number|string|BN|BigNumber false The value transferred for the transaction in drip. Return \u00b6 Promise.<string> Transaction hash. Example \u00b6 > await contract.methods.inc(1).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 819 }); \"0xb01101228cbd8619ab1f8f017530ff945b655472be211eb828b31bc7c97b9d5c\" ConfluxWeb.utils \u00b6 ConfluxWeb.utils.randomHex \u00b6 The randomHex library to generate cryptographically strong pseudo-random HEX strings from a given byte size. function randomHex(bytesSize) Parameters \u00b6 Name Type Required Default Description bytesSize number true given byte size Return \u00b6 string The generated random HEX string. Example \u00b6 > confluxWeb.utils.randomHex(32) 0xd3185018552117d2c4b5277307c455b4746267b27ea133abd288c0b136c3865c > confluxWeb.utils.randomHex(4) 0x472ace2a > confluxWeb.utils.randomHex(2) 0x52ed > confluxWeb.utils.randomHex(1) 0x3b > confluxWeb.utils.randomHex(0) 0x ConfluxWeb.utils.isBN \u00b6 Checks if a given value is a BN.js instance. function isBN(bn) Parameters \u00b6 Name Type Required Default Description bn BN true An BN.js instance Return \u00b6 boolean Example \u00b6 > const bn = new BN(10) > confluxWeb.utils.isBN(bn) true ConfluxWeb.utils.sha3 \u00b6 Will calculate the sha3 of the input. function sha3(str) Parameters \u00b6 Name Type Required Default Description str string true A string to hash Return \u00b6 string the result hash. Example \u00b6 > confluxWeb.utils.sha3('234'); \"0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79\" > confluxWeb.utils.keccak256('234'); // alias \"0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79\" ConfluxWeb.utils.soliditySha3 \u00b6 Will calculate the sha3 of given input parameters in the same way solidity would. This means arguments will be ABI converted and tightly packed before being hashed. function soliditySha3(args) Parameters \u00b6 Name Type Required Default Description ...args Array.<(string|number|object|BN)> false Return \u00b6 void Example \u00b6 > confluxWeb.utils.soliditySha3('234564535', '0xfff23243', true, -10); \"0x3e27a893dc40ef8a7f0841d96639de2f58a132be5ae466d40087a2cfa83b7179\" > confluxWeb.utils.soliditySha3('Hello!%'); // auto detects: string \"0x661136a4267dba9ccdf6bfddb7c00e714de936674c4bdb065a531cf1cb15c7fc\" > confluxWeb.utils.soliditySha3('234'); // auto detects: uint256 \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3(0xea); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3(new BN('234')); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3({type: 'uint256', value: '234'}); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3({t: 'uint', v: new BN('234')}); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3('0x407D73d8a49eeb85D32Cf465507dd71d507100c1'); \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'bytes', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // same result as above \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'address', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // same as above, but will do a checksum check, if its multi case \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'bytes32', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // different result as above \"0x3c69a194aaf415ba5d6afca734660d0a3d45acdc05d54cd1ca89a8988e7625b4\" > confluxWeb.utils.soliditySha3({t: 'string', v: 'Hello!%'}, {t: 'int8', v:-23}, {t: 'address', v: '0x85F43D8a49eeB85d32Cf465507DD71d507100C1d'}); \"0xa13b31627c1ed7aaded5aecec71baf02fe123797fffd45e662eac8e06fbe4955\" ConfluxWeb.utils.isHex \u00b6 Checks if a given string is a HEX string. function isHex(hex) Parameters \u00b6 Name Type Required Default Description hex string true The given HEX string. Return \u00b6 boolean Example \u00b6 > confluxWeb.utils.isHex('0xc1912'); true > confluxWeb.utils.isHex(0xc1912); true > confluxWeb.utils.isHex('c1912'); true > confluxWeb.utils.isHex(345); // this is tricky, as 345 can be a a HEX representation or a number, be careful when not having a 0x in front! true > confluxWeb.utils.isHex('0xZ1912'); false > confluxWeb.utils.isHex('Hello'); false ConfluxWeb.utils.isHexStrict \u00b6 Checks if a given string is a HEX string. Difference to isHex() is that it expects HEX to be prefixed with 0x. function isHexStrict(hex) Parameters \u00b6 Name Type Required Default Description hex string true The given HEX string. Return \u00b6 boolean Example \u00b6 > confluxWeb.utils.isHexStrict('0xc1912'); true > confluxWeb.utils.isHexStrict(0xc1912); false > confluxWeb.utils.isHexStrict('c1912'); false > confluxWeb.utils.isHexStrict(345); // this is tricky, as 345 can be a a HEX representation or a number, be careful when not having a 0x in front! false > confluxWeb.utils.isHexStrict('0xZ1912'); false > confluxWeb.utils.isHex('Hello'); false ConfluxWeb.utils.isAddress \u00b6 Checks if a given string is a valid Conflux address. It will also check the checksum, if the address has upper and lowercase letters. function isAddress(address) Parameters \u00b6 Name Type Required Default Description address string true An address string. Return \u00b6 string The checksum address. Example \u00b6 > confluxWeb.utils.isAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d'); true > confluxWeb.utils.isAddress('c1912fee45d61c87cc5ea59dae31190fffff232d'); true > confluxWeb.utils.isAddress('0XC1912FEE45D61C87CC5EA59DAE31190FFFFF232D'); // as all is uppercase, no checksum will be checked true > confluxWeb.utils.isAddress('0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); true > confluxWeb.utils.isAddress('0xC1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); // wrong checksum false ConfluxWeb.utils.toChecksumAddress \u00b6 Will convert an upper or lowercase Conflux address to a checksum address. function toChecksumAddress(address) Parameters \u00b6 Name Type Required Default Description address string true An address string. Return \u00b6 void Example \u00b6 > confluxWeb.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff2323'); \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\" > confluxWeb.utils.toChecksumAddress('0XC1912FEE45D61C87CC5EA59DAE31190FFFFF232D'); // same as above \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\" ConfluxWeb.utils.checkAddressChecksum \u00b6 Checks the checksum of a given address. Will also return false on non-checksum addresses. function checkAddressChecksum(address) Parameters \u00b6 Name Type Required Default Description address string true An address string. Return \u00b6 boolean true when the checksum of the address is valid, false if its not a checksum address, or the checksum is invalid. Example \u00b6 > confluxWeb.utils.checkAddressChecksum('0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); true ConfluxWeb.utils.toHex \u00b6 Will auto convert any given value to HEX. Number strings will interpreted as numbers. Text strings will be interpreted as UTF-8 strings. function toHex(value) Parameters \u00b6 Name Type Required Default Description value string|number|BN|BigNumber true The input to convert to HEX. Return \u00b6 string The resulting HEX string. Example \u00b6 > confluxWeb.utils.toHex('234'); \"0xea\" > confluxWeb.utils.toHex(234); \"0xea\" > confluxWeb.utils.toHex(new BN('234')); \"0xea\" > confluxWeb.utils.toHex(new BigNumber('234')); \"0xea\" > confluxWeb.utils.toHex('I have 100\u20ac'); \"0x49206861766520313030e282ac\" ConfluxWeb.utils.toBN \u00b6 Will safely convert any given value (including BigNumber.js instances) into a BN.js instance, for handling big numbers in JavaScript. NOTE: For just the BN.js class use utils.BN function toBN(num) Parameters \u00b6 Name Type Required Default Description num number|string true Number to convert to a big number. Return \u00b6 BN The BN.js instance. Example \u00b6 > confluxWeb.utils.toBN(1234).toString(); \"1234\" > confluxWeb.utils.toBN('1234').add(confluxWeb.utils.toBN('1')).toString(); \"1235\" > confluxWeb.utils.toBN('0xea').toString(); \"234\" ConfluxWeb.utils.hexToNumber \u00b6 Returns the number representation of a given HEX value. NOTE: This is not useful for big numbers, rather use utils.toBN instead. function hexToNumber(hex) Parameters \u00b6 Name Type Required Default Description hex string true A string to hash. Return \u00b6 number Example \u00b6 > confluxWeb.utils.hexToNumber('0xea'); 234 ConfluxWeb.utils.hexToNumberString \u00b6 Returns the number representation of a given HEX value as a string. function hexToNumberString(hex) Parameters \u00b6 Name Type Required Default Description hex string true A string to hash Return \u00b6 string The number as a string Example \u00b6 > confluxWeb.utils.hexToNumberString('0xea'); \"234\" ConfluxWeb.utils.numberToHex \u00b6 Returns the HEX representation of a given number value. function numberToHex(num) Parameters \u00b6 Name Type Required Default Description num number|string|BN|BigNumber true A number as string or number. Return \u00b6 string The HEX value of the given number. Example \u00b6 > confluxWeb.utils.numberToHex('234'); '0xea' ConfluxWeb.utils.hexToUtf8 \u00b6 Returns the UTF-8 string representation of a given HEX value. function hexToUtf8(hex) Parameters \u00b6 Name Type Required Default Description hex string true A HEX string to convert to a UTF-8 string. Return \u00b6 string The UTF-8 string. Example \u00b6 > confluxWeb.utils.hexToUtf8('0x49206861766520313030e282ac'); \"I have 100\u20ac\" ConfluxWeb.utils.hexToAscii \u00b6 Returns the ASCII string representation of a given HEX value. function hexToAscii(hex) Parameters \u00b6 Name Type Required Default Description hex string true A HEX string to convert to a ASCII string. Return \u00b6 string The ASCII string. Example \u00b6 > confluxWeb.utils.hexToAscii('0x4920686176652031303021'); \"I have 100!\" ConfluxWeb.utils.utf8ToHex \u00b6 Returns the HEX representation of a given UTF-8 string. function utf8ToHex(str) Parameters \u00b6 Name Type Required Default Description str string true A UTF-8 string to convert to a HEX string. Return \u00b6 string The HEX string Example \u00b6 > confluxWeb.utils.utf8ToHex('I have 100\u20ac'); \"0x49206861766520313030e282ac\" ConfluxWeb.utils.asciiToHex \u00b6 Returns the HEX representation of a given ASCII string. NOTE: it behaves differently from 1.2.1 function asciiToHex(str) Parameters \u00b6 Name Type Required Default Description str string true A ASCII string to convert to a HEX string. Return \u00b6 string The HEX string Example \u00b6 > confluxWeb.utils.asciiToHex('I have 100!'); \"0x4920686176652031303021\" ConfluxWeb.utils.hexToBytes \u00b6 Returns a byte array from the given HEX string. NOTE: it behaves differently from 1.2.1 function hexToBytes(hex) Parameters \u00b6 Name Type Required Default Description hex string true A HEX to convert. Return \u00b6 array The byte array. Example \u00b6 > confluxWeb.utils.hexToBytes('0x000000ea'); [ 0, 0, 0, 234 ] > confluxWeb.utils.hexToBytes(0x000000ea); [ 234 ] ConfluxWeb.utils.bytesToHex \u00b6 Returns a HEX string from a byte array. function bytesToHex(byteArray) Parameters \u00b6 Name Type Required Default Description byteArray array true A byte array to convert. Return \u00b6 string The HEX string Example \u00b6 > confluxWeb.utils.bytesToHex([ 72, 101, 108, 108, 111, 33, 36 ]); \"0x48656c6c6f2124\" ConfluxWeb.utils.toDrip \u00b6 Converts any cfx value value into drip. NOTE: \"drip\" are the smallest conflux unit, and you should always make calculations in drip and convert only for display reasons. NOTE: can not pass a Number, only string or BN are acceptable function toDrip(str,unit) Parameters \u00b6 Name Type Required Default Description str string|BN true The value unit string false \"cfx\" The cfx to convert from. Possible units are ['cfx', 'gdrip', 'drip'] Return \u00b6 string|BN If a number, or string is given it returns a number string, otherwise a BN.js instance. Example \u00b6 > confluxWeb.utils.toDrip('1'); \"1000000000000000000\" > confluxWeb.utils.toDrip('1', 'cfx'); \"1000000000000000000\" > confluxWeb.utils.toDrip('1', 'gdrip'); \"1000000000\" > confluxWeb.utils.toDrip('1', 'drip'); \"1\" ConfluxWeb.utils.fromDrip \u00b6 Converts any drip value into a cfx value. NOTE: \"drip\" are the smallest conflux unit, and you should always make calculations in drip and convert only for display reasons. NOTE: can not pass a Number, only string or BN are acceptable function fromDrip(str,unit) Parameters \u00b6 Name Type Required Default Description str string|BN true The value in drip unit string false \"cfx\" The cfx to convert to. Possible units are ['cfx', 'gdrip', 'drip'] Return \u00b6 string|BN If a number, or string is given it returns a number string, otherwise a BN.js instance. Example \u00b6 > confluxWeb.utils.fromDrip('1'); \"0.000000000000000001\" > confluxWeb.utils.fromDrip('1', 'cfx'); \"0.000000000000000001\" > confluxWeb.utils.fromDrip('1', 'gdrip'); \"0.000000001\" > confluxWeb.utils.fromDrip('1', 'gdrip'); \"1\" ConfluxWeb.utils.padLeft \u00b6 Adds a padding on the left of a string, Useful for adding paddings to HEX strings. function padLeft(value,characterAmount,sign) Parameters \u00b6 Name Type Required Default Description value string true The string to add padding on the left. characterAmount number true The number of characters the total string should have. sign string false \"0\" The character sign to use. Return \u00b6 string The padded string. Example \u00b6 > confluxWeb.utils.padLeft('0x3456ff', 20); \"0x000000000000003456ff\" > confluxWeb.utils.padLeft(0x3456ff, 20); \"0x000000000000003456ff\" > confluxWeb.utils.padLeft('Hello', 20, 'x'); \"xxxxxxxxxxxxxxxHello\" ConfluxWeb.utils.padRight \u00b6 Adds a padding on the right of a string, Useful for adding paddings to HEX strings. function padRight(value,characterAmount,sign) Parameters \u00b6 Name Type Required Default Description value string true The string to add padding on the right. characterAmount number true The number of characters the total string should have. sign string false \"0\" The character sign to use. Return \u00b6 string The padded string. Example \u00b6 > confluxWeb.utils.padRight('0x3456ff', 20); \"0x3456ff00000000000000\" > confluxWeb.utils.padRight(0x3456ff, 20); \"0x3456ff00000000000000\" > confluxWeb.utils.padRight('Hello', 20, 'x'); \"Helloxxxxxxxxxxxxxxx\" ConfluxWeb.utils.toTwosComplement \u00b6 Converts a negative numer into a two\u2019s complement. function toTwosComplement(value) Parameters \u00b6 Name Type Required Default Description value number|string|BigNumber true The number to convert. Return \u00b6 string The converted hex string. Example \u00b6 > confluxWeb.utils.toTwosComplement('-1'); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" > confluxWeb.utils.toTwosComplement(-1); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" > confluxWeb.utils.toTwosComplement('0x1'); \"0x0000000000000000000000000000000000000000000000000000000000000001\" > confluxWeb.utils.toTwosComplement(-15); \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1\" > confluxWeb.utils.toTwosComplement('-0x1'); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"","title":"JavaScript API"},{"location":"javascript-api/#getting-started-with-confluxweb","text":"The conflux-web library is a collection of modules which contain specific functionality for the conflux ecosystem. The conflux-web-cfx is for the conflux blockchain and smart contracts. The conflux-web-utils contains useful helper functions for Dapp developers. Adding conflux-web First you need to get conflux-web into your project. This can be done using the following methods: npm: npm install conflux-web After that you need to create a confluxWeb instance and set a provider. Normally you should connect to a remote/local node. const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); That\u2019s it! now you can use the confluxWeb object. Using Promises All of functions use asynchronous HTTP requests and return promises by default: const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); confluxWeb.cfx.getEpochNumber().then(console.log); A note on big numbers You will always get a BigNumber object for number values as JavaScript is not able to handle big numbers correctly. Look at the following examples: \"101010100324325345346456456456456456456\" // \"101010100324325345346456456456456456456\" 101010100324325345346456456456456456456 // 1.0101010032432535e+38 ConfluxWeb depends on the BN.js library for big numbers, See the BN.js documentation for details.","title":"Getting Started with ConfluxWeb"},{"location":"javascript-api/#confluxweb-by-example","text":"","title":"ConfluxWeb by Example"},{"location":"javascript-api/#hash-time-locked-contract","text":"Here we brought you a ConfluxWeb example. You can learn how to develop a Hash Time Locked Contract (HTLC) with ConfluxWeb API.","title":"Hash Time Locked Contract"},{"location":"javascript-api/#confluxweb-api-reference","text":"","title":"ConfluxWeb API Reference"},{"location":"javascript-api/#confluxweb","text":"","title":"ConfluxWeb"},{"location":"javascript-api/#confluxwebproviders","text":"Class attribute object","title":"ConfluxWeb.providers"},{"location":"javascript-api/#example","text":"> ConfluxWeb.providers { HttpProvider: [Function: HttpProvider$1], WebsocketProvider: [Function: WebsocketProvider$1], IpcProvider: [Function: IpcProvider$1] }","title":"Example"},{"location":"javascript-api/#confluxwebmodules","text":"Class attribute object","title":"ConfluxWeb.modules"},{"location":"javascript-api/#example_1","text":"> ConfluxWeb.modules { Cfx: [Function: Cfx], Net: [Function: Net] }","title":"Example"},{"location":"javascript-api/#confluxwebutils","text":"Class attribute Object attribute Property of ConfluxWeb class and instance of ConfluxWeb, See confluxWeb.utils for more. object","title":"ConfluxWeb.utils"},{"location":"javascript-api/#example_2","text":"> ConfluxWeb.utils {...} > confluxWeb.utils {...}","title":"Example"},{"location":"javascript-api/#confluxwebversion","text":"Object attribute current version string","title":"ConfluxWeb.version"},{"location":"javascript-api/#example_3","text":"> confluxWeb.version 0.1.21-alpha.0","title":"Example"},{"location":"javascript-api/#confluxwebcurrentprovider","text":"Object attribute current provider instance object","title":"ConfluxWeb.currentProvider"},{"location":"javascript-api/#example_4","text":"> confluxWeb.currentProvider; HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... }","title":"Example"},{"location":"javascript-api/#confluxwebsetprovider","text":"Will change the provider for its module. NOTE: When called on the umbrella package cfx it will also set the provider for all sub modules confluxWeb.cfx, etc. function setProvider(provider)","title":"ConfluxWeb.setProvider"},{"location":"javascript-api/#parameters","text":"Name Type Required Default Description provider object true A valid provider.","title":"Parameters"},{"location":"javascript-api/#return","text":"boolean","title":"Return"},{"location":"javascript-api/#example_5","text":"> const ConfluxWeb = require('conflux-web'); > const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); > confluxWeb.currentProvider HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... } > confluxWeb.setProvider(new ConfluxWeb.providers.HttpProvider('http://localhost:12537')); true > confluxWeb.currentProvider HttpProvider { host: 'http://localhost:12537' ... } > confluxWeb.setProvider('http://localhost:12537'); // same as above true > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.setProvider('http://localhost:12537') // change all provider > confluxWeb.currentProvider.host \"http://localhost:12537\" > confluxWeb.cfx.currentProvider.host \"http://localhost:12537\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontract","text":"","title":"ConfluxWeb.cfx.Contract"},{"location":"javascript-api/#confluxwebcfxcontractabimodel","text":"abi object Object","title":"ConfluxWeb.cfx.Contract.abiModel"},{"location":"javascript-api/#example_6","text":"> contract.abiModel AbiModel { abi: { methods: { count: [AbiItemModel], '0x06661abd': [AbiItemModel], 'count()': [AbiItemModel], inc: [AbiItemModel], '0x812600df': [AbiItemModel], 'inc(uint256)': [AbiItemModel], contractConstructor: [AbiItemModel] }, events: {} } }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractaddress","text":"The address used for this contract instance. All transactions generated by confluxWeb from this contract will contain this address as the \"to\". string","title":"ConfluxWeb.cfx.Contract.address"},{"location":"javascript-api/#example_7","text":"> contract.address; // What you set when new contract. \"0xf02dbcf0eff48e174ca59f1975a7b0042c4d02b7\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractdefaultgas","text":"The default maximum gas provided for a transaction (gasLimit). number","title":"ConfluxWeb.cfx.Contract.defaultGas"},{"location":"javascript-api/#confluxwebcfxcontractdefaultgasprice","text":"The default gas price in drip to use for transactions. number","title":"ConfluxWeb.cfx.Contract.defaultGasPrice"},{"location":"javascript-api/#confluxwebcfxcontractmethods","text":"Creates a transaction object for that method, which then can be called, send, estimated. The methods of this smart contract are available through: The name: myContract.methods.myMethod(123) The name with parameters: myContract.methods 'myMethod(uint256)' The signature: myContract.methods '0x58cf5f10' This allows calling functions with same name but different parameters from the JavaScript contract object. Proxy","title":"ConfluxWeb.cfx.Contract.methods"},{"location":"javascript-api/#example_8","text":"> contract.address; \"0x079352147ce2de227af6fa963f603a35aed8e601\" > await contract.methods.count().call(); BigNumber { _hex: '0xfe' } > await contract.methods.inc(1).call(); // call will get function return value BigNumber { _hex: '0xff' } > await contract.methods.count().call(); // can not change data in block chain by `call` BigNumber { _hex: '0xfe' } > await contract.methods.inc(1).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 100 }); // send a transaction \"0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a\" > await confluxWeb.cfx.getTransactionReceipt('0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a'); { status: true, ... } > await contract.methods.count().call(); // change data in block chain by `send` BigNumber { _hex: '0xff' }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractconstructor","text":"Creates a new contract instance with all its methods and events defined in its json interface abi object. function constructor(abi,address,options)","title":"ConfluxWeb.cfx.Contract.constructor"},{"location":"javascript-api/#parameters_1","text":"Name Type Required Default Description abi object|array true The abi json interface of the contract. address string false The address where the contract is deployed. If undefined, you should deploy contract by data. options object false options.data string false The byte code of the contract. Used when the contract gets deployed. options.from string false The address transactions should be made from. options.gasPrice string false The gas price in drip to use for transactions. options.gas number false The maximum gas provided for a transaction (gasLimit).","title":"Parameters"},{"location":"javascript-api/#return_1","text":"void","title":"Return"},{"location":"javascript-api/#example_9","text":"> confluxWeb.cfx.accounts.wallet.add('0xa816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY > const contract = new confluxWeb.cfx.Contract( [ { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"name\": \"inc\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" } ], );","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractdeploy","text":"function deploy(options)","title":"ConfluxWeb.cfx.Contract.deploy"},{"location":"javascript-api/#parameters_2","text":"Name Type Required Default Description options object true options.data string false contract data options.arguments array false contract constructor parameters","title":"Parameters"},{"location":"javascript-api/#return_2","text":"Object","title":"Return"},{"location":"javascript-api/#example_10","text":"> await contract.deploy({arguments: [254]}).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 819 }); // deploy contract by `send` \"0x6d1b5d68540faac893e5d5dcfed7fc253a2fd6936634f917c82856a0b19c3838\" > await confluxWeb.cfx.getTransactionReceipt('0xd1d5b66b0d3d215f042f3e4907a3bf0acf5984972527fbca45eb67286835260d'); { status: true, contractCreated: '0x079352147ce2de227af6fa963f603a35aed8e601', ... } > contract.address = '0x079352147ce2de227af6fa963f603a35aed8e601'; // after deploy, you should add address to contract","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractclone","text":"Clones the current contract instance. function clone()","title":"ConfluxWeb.cfx.Contract.clone"},{"location":"javascript-api/#parameters_3","text":"void","title":"Parameters"},{"location":"javascript-api/#return_3","text":"Object The new contract instance.","title":"Return"},{"location":"javascript-api/#example_11","text":"> const clone = contract.clone() > contract.defaultGas === clone.defaultGas; true > contract.defaultGasPrice === clone.defaultGasPrice; true > contract.address === clone.address; // only address difference, and clone one address to be undefined false","title":"Example"},{"location":"javascript-api/#confluxwebcfx","text":"","title":"ConfluxWeb.cfx"},{"location":"javascript-api/#confluxwebcfxdefaultaccount","text":"This default address is used as the default \"from\" property. 20 Bytes: Any Conflux address. You should have the private key for that address in your node or keystore. string|undefined","title":"ConfluxWeb.cfx.defaultAccount"},{"location":"javascript-api/#example_12","text":"> confluxWeb.cfx.defaultAccount undefined > confluxWeb.cfx.defaultAccount = '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b'; > confluxWeb.cfx.defaultAccount \"0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxdefaultepoch","text":"When requests are made that act on the state of conflux, the default epoch parameter determines the height of the epoch. The following options are possible for the default epoch parameter: number : An integer epoch number. \"earliest\" : The earliest epoch where the genesis block in. \"latest_state\" : The latest epoch where the latest block with an executed state in. (default) \"latest_mined\" : The latest epoch where the latest mined block in. number|string","title":"ConfluxWeb.cfx.defaultEpoch"},{"location":"javascript-api/#example_13","text":"> confluxWeb.cfx.defaultEpoch; // Default is \"latest_state\" \"latest_state\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxcurrentprovider","text":"Will return the current provider, otherwise null object|null","title":"ConfluxWeb.cfx.currentProvider"},{"location":"javascript-api/#example_14","text":"> confluxWeb.cfx.currentProvider HttpProvider { host: 'http://testnet-jsonrpc.conflux-chain.org:12537', ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxsetprovider","text":"Will change the provider for its module. function setProvider(cfxProvider)","title":"ConfluxWeb.cfx.setProvider"},{"location":"javascript-api/#parameters_4","text":"Name Type Required Default Description cfxProvider object true A valid provider.","title":"Parameters"},{"location":"javascript-api/#return_4","text":"boolean","title":"Return"},{"location":"javascript-api/#example_15","text":"> confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.setProvider('http://localhost:12537') // change module provider > confluxWeb.currentProvider.host \"http://testnet-jsonrpc.conflux-chain.org:12537\" > confluxWeb.cfx.currentProvider.host \"http://localhost:12537\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetgasprice","text":"Returns the current gas price oracle. The gas price is determined by the last few blocks median gas price. async function getGasPrice()","title":"ConfluxWeb.cfx.getGasPrice"},{"location":"javascript-api/#parameters_5","text":"void","title":"Parameters"},{"location":"javascript-api/#return_5","text":"Promise.<string> Number string of the current gas price in drip.","title":"Return"},{"location":"javascript-api/#example_16","text":"> await confluxWeb.cfx.getGasPrice() \"0\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetepochnumber","text":"Returns the current epoch number the client is on. async function getEpochNumber()","title":"ConfluxWeb.cfx.getEpochNumber"},{"location":"javascript-api/#parameters_6","text":"void","title":"Parameters"},{"location":"javascript-api/#return_6","text":"Promise.<number>","title":"Return"},{"location":"javascript-api/#example_17","text":"> await confluxWeb.cfx.getEpochNumber(); 990902","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetbalance","text":"Get the balance of an address at a given epoch. async function getBalance(address,defaultEpoch)","title":"ConfluxWeb.cfx.getBalance"},{"location":"javascript-api/#parameters_7","text":"Name Type Required Default Description address string true The address to get the balance of. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch.","title":"Parameters"},{"location":"javascript-api/#return_7","text":"Promise.<string> The current balance for the given address in drip.","title":"Return"},{"location":"javascript-api/#example_18","text":"> await confluxWeb.cfx.getBalance(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\"); \"685539999999937000\" > await confluxWeb.cfx.getBalance(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\", \"earliest\"); \"0\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetcode","text":"Get the code at a specific address. async function getCode(address,defaultEpoch)","title":"ConfluxWeb.cfx.getCode"},{"location":"javascript-api/#parameters_8","text":"Name Type Required Default Description address string true The address to get the code from. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch.","title":"Parameters"},{"location":"javascript-api/#return_8","text":"Promise.<string> The data at given address","title":"Return"},{"location":"javascript-api/#example_19","text":"> await confluxWeb.cfx.getCode(\"0x079352147ce2de227af6fa963f603a35aed8e601\"); \"0x6080604052348015600f57600080fd5b506004361060325760003560e01c806306661abd146037578063812600df146053575b600080fd5b603d6092565b6040518082815260200191505060405180910390f35b607c60048036036020811015606757600080fd5b81019080803590602001909291905050506098565b6040518082815260200191505060405180910390f35b60005481565b60008160008082825401925050819055905091905056fea265627a7a723158203aa4346abf52089d9be8806b8bf35dff408bd9f68f668e528bc8e2e20d74b29064736f6c634300050b0032\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetblock","text":"Returns a block matching the block number or block hash. async function getBlock(blockHashOrEpochNumber,returnTransactionObjects)","title":"ConfluxWeb.cfx.getBlock"},{"location":"javascript-api/#parameters_9","text":"Name Type Required Default Description blockHashOrEpochNumber string|number true The block hash or epoch. returnTransactionObjects boolean false false If true, the returned block will contain all transactions as objects, if false it will only contains the transaction hashes.","title":"Parameters"},{"location":"javascript-api/#return_9","text":"Promise.<object> The block object string miner: The address of the beneficiary to whom the mining rewards were given. string|null hash: Hash of the block. null when its pending block. string parentHash: Hash of the parent block. string[] refereeHashes: Array of referee hashes. number|null epochNumber: The current block epoch number in the client's view. null when it's not in best block's past set. boolean stable: If the block stable or not string nonce: Hash of the generated proof-of-work. null when its pending block. number gasLimit: The maximum gas allowed in this block. string difficulty: Integer string of the difficulty for this block. number height: The block heights. null when its pending block. number size: Integer the size of this block in bytes. number blame: 0 if there's nothing to blame; k if the block is blaming on the state info of its k-th ancestor. boolean adaptive: If the block's weight adaptive or not. number timestamp: The unix timestamp for when the block was collated. string transactionsRoot: The hash of the transactions of the block. string[] transactions: Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. string deferredLogsBloomHash: The hash of the deferred block's log bloom filter string deferredReceiptsRoot: The hash of the receipts of the block after deferred execution. string deferredStateRoot: The root of the final state trie of the block after deferred execution. object deferredStateRootWithAux: Information of deferred state root","title":"Return"},{"location":"javascript-api/#example_20","text":"> await confluxWeb.cfx.getBlock(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\"); { \"miner\": \"0x0000000000000000000000000000000000000015\", \"hash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"parentHash\": \"0xa378c9e283c08eac0e2ac51a8c19e61717af812a157eb914d35b171ed20920b9\", \"refereeHashes\": [], \"epochNumber\": 925836, \"stable\": true, \"nonce\": \"0xaaa4a571ad424ec\", \"gasLimit\": 3000000000, \"difficulty\": \"21351313\", \"height\": 925836, \"size\": 384, \"blame\": 0, \"adaptive\": false, \"timestamp\": 1570608173, \"transactionsRoot\": \"0xbe7a9e531d55ed950a217272afa035f57f6c512ca249bae19e214cf2b470562e\" \"transactions\": [ \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\" ], \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xc4ec82320df3b5ce48e22d33cc82f665a274dc920796a3e206be44682b7812a2\", \"deferredStateRootWithAux\": { \"auxInfo\": { \"intermediateDeltaEpochId\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"previousSnapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"stateRoot\": { \"deltaRoot\": \"0xbc71c52f0dae840fd8815de081a2774927077714a5fe7c342b0e5e81f7bcd38e\", \"intermediateDeltaRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"snapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" } }, } > await confluxWeb.cfx.getBlock(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", true); { \"adaptive\": false, \"blame\": 0, \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xc4ec82320df3b5ce48e22d33cc82f665a274dc920796a3e206be44682b7812a2\", \"deferredStateRootWithAux\": { \"auxInfo\": { \"intermediateDeltaEpochId\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"previousSnapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"stateRoot\": { \"deltaRoot\": \"0xbc71c52f0dae840fd8815de081a2774927077714a5fe7c342b0e5e81f7bcd38e\", \"intermediateDeltaRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"snapshotRoot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" } }, \"difficulty\": \"21351313\", \"epochNumber\": 925836, \"gasLimit\": 3000000000, \"hash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"height\": 925836, \"miner\": \"0x0000000000000000000000000000000000000015\", \"nonce\": \"0xaaa4a571ad424ec\", \"parentHash\": \"0xa378c9e283c08eac0e2ac51a8c19e61717af812a157eb914d35b171ed20920b9\", \"refereeHashes\": [], \"size\": 384, \"stable\": true, \"timestamp\": 1570608173, \"transactions\": [ { \"blockHash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"contractCreated\": null, \"data\": \"0x\", \"from\": \"0xA70ddf9B9750c575Db453Eea6A041f4C8536785A\", \"gas\": 21000, \"gasPrice\": \"819\", \"hash\": \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\", \"nonce\": 921, \"r\": \"0x985743d5d627e8f93e243bfd71e401f7bf5c7b098afeb910952df789312cc7b1\", \"s\": \"0xaaf07bc11d56516f90697fb0f1b8140ec9b252c66e8f3172799e2829d457775\", \"status\": \"0x0\", \"to\": \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\", \"transactionIndex\": 0, \"v\": 1, \"value\": \"1000000000000000000\" } ], \"transactionsRoot\": \"0xbe7a9e531d55ed950a217272afa035f57f6c512ca249bae19e214cf2b470562e\" }","title":"Example"},{"location":"javascript-api/#confluxwebcfxgettransaction","text":"Returns a transaction matching the given transaction hash. async function getTransaction(transactionHash)","title":"ConfluxWeb.cfx.getTransaction"},{"location":"javascript-api/#parameters_10","text":"Name Type Required Default Description transactionHash string true The transaction hash.","title":"Parameters"},{"location":"javascript-api/#return_10","text":"Promise.<object> The transaction object string blockHash: Hash of the block where this transaction was in and got executed. null when its pending. number transactionIndex: Integer of the transactions index position in the block. string hash: Hash of the transaction. number nonce: The number of transactions made by the sender prior to this one. string from: Address of the sender. string to: Address of the receiver. null when its a contract creation transaction. string value: Value transferred in Drip. string data: The data send along with the transaction. number gas: Gas provided by the sender. number gasPrice: Gas price provided by the sender in Drip. string status: '0x0' successful execution; '0x1' exception happened but nonce still increased; '0x2' exception happened and nonce didn't increase. string|null contractCreated: The contract address created, if the transaction was a contract creation, otherwise null. string r: ECDSA signature r string s: ECDSA signature s string v: ECDSA recovery id","title":"Return"},{"location":"javascript-api/#example_21","text":"> await confluxWeb.cfx.getTransaction(\"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\"); { \"blockHash\": \"0xdf19947ee92cae1de92fd05d949c654afa4afb77ce42024533d5b47cb861575a\", \"transactionIndex\": 0, \"hash\": \"0x3910617de2a689f79bccd3d36866f4afd9ca93732c8e7be280a84190db701190\", \"nonce\": 921, \"from\": \"0xA70ddf9B9750c575Db453Eea6A041f4C8536785A\", \"to\": \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\", \"value\": \"1000000000000000000\" \"data\": \"0x\", \"gas\": 21000, \"gasPrice\": \"819\", \"status\": \"0x0\", \"contractCreated\": null, \"r\": \"0x985743d5d627e8f93e243bfd71e401f7bf5c7b098afeb910952df789312cc7b1\", \"s\": \"0xaaf07bc11d56516f90697fb0f1b8140ec9b252c66e8f3172799e2829d457775\", \"v\": 1, }","title":"Example"},{"location":"javascript-api/#confluxwebcfxgettransactioncount","text":"Get the numbers of transactions sent from this address. async function getTransactionCount(address,defaultEpoch)","title":"ConfluxWeb.cfx.getTransactionCount"},{"location":"javascript-api/#parameters_11","text":"Name Type Required Default Description address string true The address to get the numbers of transactions from. defaultEpoch number|string false confluxWeb.cfx.defaultEpoch If you pass this parameter it will not use the default epoch.","title":"Parameters"},{"location":"javascript-api/#return_11","text":"Promise.<number> The number of transactions sent from the given address.","title":"Return"},{"location":"javascript-api/#example_22","text":"> await confluxWeb.cfx.getTransactionCount(\"0xa70ddf9b9750c575db453eea6a041f4c8536785a\"); 974 > await confluxWeb.cfx.getTransactionCount(\"0xa70ddf9b9750c575db453eea6a041f4c8536785a\", 'earliest'); 0","title":"Example"},{"location":"javascript-api/#confluxwebcfxsendsignedtransaction","text":"Sends an already signed transaction, generated for example using confluxWeb.cfx.accounts.signTransaction async function sendSignedTransaction(signedTransactionData)","title":"ConfluxWeb.cfx.sendSignedTransaction"},{"location":"javascript-api/#parameters_12","text":"Name Type Required Default Description signedTransactionData string true Signed transaction data in HEX format","title":"Parameters"},{"location":"javascript-api/#return_12","text":"Promise.<string> Transaction hash","title":"Return"},{"location":"javascript-api/#example_23","text":"> const ConfluxTx = require('confluxjs-transaction'); > const tx = new ConfluxTx({ nonce: '0x03', gasPrice: '0x01', gasLimit: '0x5208', // 21000 to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', // ADDRESS_TO value: '0x01', }); > tx.sign(Buffer.from('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393', 'hex')); // KEY_FROM > await confluxWeb.cfx.sendSignedTransaction('0x' + tx.serialize().toString('hex')); 0x200b930e95b3c8c54978499c6407ef71fc96a83eced88640fae59b75e1d16ef4","title":"Example"},{"location":"javascript-api/#confluxwebcfxsigntransaction","text":"Signs a transaction. This account needs to be unlocked. async function signTransaction(rawTx)","title":"ConfluxWeb.cfx.signTransaction"},{"location":"javascript-api/#parameters_13","text":"Name Type Required Default Description rawTx object true rawTx.from number true An address or index of a local wallet in confluxWeb.cfx.accounts.wallet. rawTx.to string false The destination address of the message, left undefined for a contract-creation transaction. rawTx.value number|string|BN|BigNumber false The value transferred for the transaction in drip, also the endowment if it\u2019s a contract-creation transaction. rawTx.gas number false To-Be-Determined The amount of gas to use for the transaction (unused gas is refunded). rawTx.gasPrice number|string|BN|BigNumber false confluxWeb.cfx.gasPrice The price of gas for this transaction in drip. rawTx.data string false Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code. rawTx.nonce number false Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.","title":"Parameters"},{"location":"javascript-api/#return_13","text":"Promise.<object> The RLP encoded transaction. The raw property can be used to send the transaction using confluxWeb.cfx.sendSignedTransaction. string rawTransaction: Raw transaction string string messageHash: Hash of transaction for calculating signature string r: ECDSA signature r string s: ECDSA signature s string v: ECDSA recovery id","title":"Return"},{"location":"javascript-api/#example_24","text":"> confluxWeb.cfx.accounts.wallet.add('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY_FROM > await confluxWeb.cfx.signTransaction({ from: 0, // index nonce: 0, // make nonce appropriate gasPrice: 10, gas: 21000, value: new BN('300000000000000000'), // 300000000000000000 drip === 0.3 cfx token to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', // ADDRESS_TO data: '', }); { \"messageHash\": \"53aec3cdccb8ab438303ece4559fc4464a118416828d8c7c0427f5debcd8feae\", \"r\": \"0x1feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2\", \"s\": \"0x0451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67\", \"v\": \"0x01\", \"rawTransaction\": \"0xf867800a825208941ead8630345121d19ee3604128e5dc54b36e8ea6880429d069189e00008001a01feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2a00451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67\" }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcall","text":"Executes a message call transaction, which is directly executed in the VM of the node, but never mined into the blockchain. async function call(callObject,defaultEpoch)","title":"ConfluxWeb.cfx.call"},{"location":"javascript-api/#parameters_14","text":"Name Type Required Default Description callObject object true A transaction object, with the difference that for calls the from property is optional as well. defaultEpoch string|number false conflux.cfx.defaultEpoch","title":"Parameters"},{"location":"javascript-api/#return_14","text":"Promise.<string> The returned data of the call, e.g. A smart contract functions return value.","title":"Return"},{"location":"javascript-api/#example_25","text":"> await confluxWeb.cfx.call({ to: \"0x11f4d0a3c12e86b4b5f39b213f7e19d048276dae\", // contract address data: \"0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\" }) 0x000000000000000000000000000000000000000000000000000000000000000a","title":"Example"},{"location":"javascript-api/#confluxwebcfxestimategas","text":"Executes a message call or transaction and returns the amount of the gas used. async function estimateGas(callObject)","title":"ConfluxWeb.cfx.estimateGas"},{"location":"javascript-api/#parameters_15","text":"Name Type Required Default Description callObject object true A transaction object, with the difference that for calls the from property is optional as well.","title":"Parameters"},{"location":"javascript-api/#return_15","text":"Promise.<number> - the used gas for the simulated call/transaction.","title":"Return"},{"location":"javascript-api/#example_26","text":"> await confluxWeb.cfx.estimateGas({ to: \"0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe\", data: \"0xc6888fa10000000000000000000000000000000000000000000000000000000000000003\" }) 0x0000000000000000000000000000000000000000000000000000000000000015","title":"Example"},{"location":"javascript-api/#confluxwebcfxgettransactionreceipt","text":"Returns the receipt of a transaction by transaction hash. NOTE: The receipt is not available for pending transactions and returns null. async function getTransactionReceipt(txHash)","title":"ConfluxWeb.cfx.getTransactionReceipt"},{"location":"javascript-api/#parameters_16","text":"Name Type Required Default Description txHash string true The transaction hash.","title":"Parameters"},{"location":"javascript-api/#return_16","text":"Promise.<object> A transaction receipt object, or null when no receipt was found. boolean status: true if the transaction was successful; false , if the EVM reverted the transaction. number outcomeStatus: 1 status true ; 0 status false . string stateRoot: The state root of transaction execution. number epochNumber: Epoch number where this transaction was in. string blockHash: Hash of the block where this transaction was in. string transactionHash: Hash of the transaction. number index: Integer of the transactions index position in the block. string from: Address of the sender. string to: Address of the receiver. null when its a contract creation transaction. string|null contractCreated: The contract address created, if the transaction was a contract creation, otherwise null. number gasUsed: The amount of gas used by this specific transaction alone. [object] logs: Array of log objects, which this transaction generated. [string] logs[].address: The address of the contract executing at the point of the LOG operation. [string] logs[].topics: The topics associated with the LOG operation. [string] logs[].data: The data associated with the LOG operation. string logsBloom:","title":"Return"},{"location":"javascript-api/#example_27","text":"> await confluxWeb.cfx.getTransactionReceipt('0x689258ba9fe2c25bcdc43ebb5c9018d1b56d25b1c87de1b371a19f5548c16dc1'); { status: true, outcomeStatus: 0, stateRoot: '0x75df853d267b40a98f6fe1103a510822bc1582894e8a9e95eb9ff0697545e4d2', epochNumber: 1017673, blockHash: '0xdefb3add0256b12c80f6e4fddde81da9c93ec88861cbee14051379f79624f911', transactionHash: '0x689258ba9fe2c25bcdc43ebb5c9018d1b56d25b1c87de1b371a19f5548c16dc1', index: 0, from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', to: '0x1ead8630345121d19ee3604128e5dc54b36e8ea6', contractCreated: null, gasUsed: 21000, logs: [], logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', }","title":"Example"},{"location":"javascript-api/#confluxwebcfxgetpastlogs","text":"Gets past logs, matching the given options. async function getPastLogs(options)","title":"ConfluxWeb.cfx.getPastLogs"},{"location":"javascript-api/#parameters_17","text":"Name Type Required Default Description options object true options.fromEpoch string false The number of the earliest block options.toEpoch string false The number of the latest block options.address string|Array[string] true An address or a list of addresses to only get logs from particular account(s). options.topics array true An array of values which must each appear in the log entries. The order is important, if you want to leave topics out use null, e.g. [null, '0x12...']. You can also pass an array for each topic with options for that topic e.g. [null, ['option1', 'option2']]","title":"Parameters"},{"location":"javascript-api/#return_17","text":"Promise.<Array.<object>> Array of log objects.","title":"Return"},{"location":"javascript-api/#example_28","text":"> await confluxWeb.cfx.getPastLogs({ fromEpoch: '0x0', toEpoch: 'latest_mined', address: '0x169a10a431130B2F4853294A4a966803668af385' }); [ { \"address\": \"0x169a10a431130B2F4853294A4a966803668af385\", \"blockHash\": \"0x9f18cbbbc432d678b94ee6446e9305abf8f02deb0b03877cc0c71c0a71c08faf\", \"epochNumber\": \"0x0\", \"data\": \"0x\", \"logIndex\": 0, \"removed\": false, \"topics\": [ \"0x44d6d25963f097ad14f29f06854a01f575648a1ef82f30e562ccd3889717e339\", \"0x000000000000000000000000c24a31039a4dfc9ee9039bd9241a0c7848b92ae1\" ], \"transactionHash\": \"0xb777fc8ee9c5b5f6eb2b1c7d73106f07eb1692b9db08d9f65affafb82641559f\", \"transactionIndex\": 0, \"transactionLogIndex\": \"0x0\", \"type\": \"mined\", \"id\": \"log_0x5157483fef4019b6a231963496322bbf123b2559f73eef47f60dd5d1b1364fe4\" }, ... ]","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccount","text":"","title":"ConfluxWeb.cfx.account"},{"location":"javascript-api/#confluxwebcfxaccountcreate","text":"Generates an account object with private key and public key. NOTE: compare to eth latest, we don\u2019t have sign methods in the return account object function create(entropy)","title":"ConfluxWeb.cfx.account.create"},{"location":"javascript-api/#parameters_18","text":"Name Type Required Default Description entropy string false A random string to increase entropy. If given it should be at least 32 characters. If none is given a random string will be generated using randomHex.","title":"Parameters"},{"location":"javascript-api/#return_18","text":"object The account object.","title":"Return"},{"location":"javascript-api/#example_29","text":"> confluxWeb.cfx.accounts.create(); Account { address: '0xbaE14daA250D6BCE69E695217AE8B3ce1dfF7AAe', privateKey: '0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399', ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountprivatekeytoaccount","text":"Creates an account object from a private key. NOTE: compare to eth latest, we don\u2019t have sign methods in the return account object function privateKeyToAccount(privateKey)","title":"ConfluxWeb.cfx.account.privateKeyToAccount"},{"location":"javascript-api/#parameters_19","text":"Name Type Required Default Description privateKey string true The private key to convert.","title":"Parameters"},{"location":"javascript-api/#return_19","text":"object The account object.","title":"Return"},{"location":"javascript-api/#example_30","text":"> confluxWeb.cfx.accounts.privateKeyToAccount('0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399'); Account { address: '0xbaE14daA250D6BCE69E695217AE8B3ce1dfF7AAe', privateKey: '0xed66cd654e2d714445dd159801f7e8144d227715c1eb33865d44c056d8e23399', ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountrecovertransaction","text":"Recovers the Conflux address which was used to sign the given RLP encoded transaction. function recoverTransaction(rawTransaction)","title":"ConfluxWeb.cfx.account.recoverTransaction"},{"location":"javascript-api/#parameters_20","text":"Name Type Required Default Description rawTransaction string true The RLP encoded transaction.","title":"Parameters"},{"location":"javascript-api/#return_20","text":"string The Conflux address used to sign this transaction.","title":"Return"},{"location":"javascript-api/#example_31","text":"> confluxWeb.cfx.accounts.recoverTransaction('0xf867800a825208941ead8630345121d19ee3604128e5dc54b36e8ea6880429d069189e00008001a01feaa7a3d6ae22c013b0987e8fa8e39ff1df1e6080c95d7d5e085e2cd9b02ff2a00451df58547f0e0ad36d06058cd0c8cfa4eb201b4d09255f56ba0d750e520a67'); \"0xbbd9E9bE525AB967e633BcDAEaC8bD5723ED4D6B\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccounthashmessage","text":"function hashMessage(message)","title":"ConfluxWeb.cfx.account.hashMessage"},{"location":"javascript-api/#parameters_21","text":"Name Type Required Default Description message string true A message to hash, if its HEX it will be UTF8 decoded before.","title":"Parameters"},{"location":"javascript-api/#return_21","text":"string The hashed message","title":"Return"},{"location":"javascript-api/#example_32","text":"> confluxWeb.cfx.accounts.hashMessage(\"Hello World\"); \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\" > confluxWeb.cfx.accounts.hashMessage(confluxWeb.cfx.utf8ToHex(\"Hello World\")); // the below results in the same hash \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountsign","text":"Signs arbitrary data. This data is before UTF-8 HEX decoded and enveloped as follows: \"\\x19Ethereum Signed Message:\\n\" + message.length + message function sign(data,privateKey)","title":"ConfluxWeb.cfx.account.sign"},{"location":"javascript-api/#parameters_22","text":"Name Type Required Default Description data string true The data to sign. privateKey string true The private key to sign with.","title":"Parameters"},{"location":"javascript-api/#return_22","text":"object","title":"Return"},{"location":"javascript-api/#example_33","text":"> confluxWeb.cfx.accounts.sign('Hello World', 'a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); { \"message\": \"Hello World\", \"messageHash\": \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\", \"v\": \"0x1b\", \"r\": \"0x14e05a1ff41165dc420414e96acd7710a49ff05eecbd2caf520ac8d2e37426b0\", \"s\": \"0x4236443a89cd5a5d14559bc5c115988b704d40dea7e39ed087ae80cd7822f99c\", \"signature\": \"0x14e05a1ff41165dc420414e96acd7710a49ff05eecbd2caf520ac8d2e37426b04236443a89cd5a5d14559bc5c115988b704d40dea7e39ed087ae80cd7822f99c1b\" }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountrecover","text":"Recovers the Conflux address which was used to sign the given data. confluxWeb.cfx.accounts.recover(message, signature [, preFixed]); confluxWeb.cfx.accounts.recover(message, v, r, s [, preFixed]); confluxWeb.cfx.accounts.recover(signatureObject); function recover(message,signature,r,s,v,preFixed,signatureObject)","title":"ConfluxWeb.cfx.account.recover"},{"location":"javascript-api/#parameters_23","text":"Name Type Required Default Description message string true signature string true The raw RLP encoded signature, OR parameter 2-4 as v, r, s values. r string true First 32 bytes of the signature s string true Next 32 bytes of the signature v string true Recovery value preFixed boolean false false If the last parameter is true, the given message will NOT automatically be prefixed with \"\\x19Ethereum Signed Message:\\n\" + message.length + message, and assumed to be already prefixed. signatureObject object true signatureObject.messageHash string true The hash of the given message already prefixed with \"\\x19Ethereum Signed Message:\\n\" + message.length + message. signatureObject.r string true same as r signatureObject.s string true same as s signatureObject.v string true same as v","title":"Parameters"},{"location":"javascript-api/#return_23","text":"string The Conflux address used to sign this data.","title":"Return"},{"location":"javascript-api/#example_34","text":"> confluxWeb.cfx.accounts.recover({ messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655', v: '0x1', r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029' }) \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" > confluxWeb.cfx.accounts.recover('Some data', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a02901'); // message, signature \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" > confluxWeb.cfx.accounts.recover('Some data', '0x01', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029'); // message, v, r, s \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountwallet","text":"","title":"ConfluxWeb.cfx.account.wallet"},{"location":"javascript-api/#confluxwebcfxaccountwalletcreate","text":"Generates one or more accounts in the wallet. If wallets already exist they will not be overridden. function create(numberOfAccounts,entropy)","title":"ConfluxWeb.cfx.account.wallet.create"},{"location":"javascript-api/#parameters_24","text":"Name Type Required Default Description numberOfAccounts number true Number of accounts to create. Leave empty to create an empty wallet. entropy string false A string with random characters as additional entropy when generating accounts. If given it should be at least 32 characters.","title":"Parameters"},{"location":"javascript-api/#return_24","text":"object The wallet object","title":"Return"},{"location":"javascript-api/#example_35","text":"> confluxWeb.cfx.accounts.wallet.create(2); Wallet { ... accounts: { '0': Account { address: '0x52B2a035bbC4263D46a327376195e86dbaAF0b42', privateKey: '0x9887b79bd08ac7ee5897a24c50ee366450edd706cd8cec637cbb91234638d6bb', accounts: [Accounts] }, '1': Account { address: '0x52B2a035bbC4263D46a327376195e86dbaAF0b42', privateKey: '0x9887b79bd08ac7ee5897a24c50ee366450edd706cd8cec637cbb91234638d6bb', accounts: [Accounts] }, }, ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountwalletadd","text":"Adds an account using a private key or account object to the wallet. function add(account)","title":"ConfluxWeb.cfx.account.wallet.add"},{"location":"javascript-api/#parameters_25","text":"Name Type Required Default Description account string|object true A private key or account object created with confluxWeb.cfx.accounts.create().","title":"Parameters"},{"location":"javascript-api/#return_25","text":"object The added account","title":"Return"},{"location":"javascript-api/#example_36","text":"> confluxWeb.cfx.accounts.wallet.add('a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); Account { address: '0x4060E99f892E052dF9F59126D3F1eF2240A5df97', privateKey: 'a816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393', ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountwalletremove","text":"Removes an account from the wallet. function remove(address)","title":"ConfluxWeb.cfx.account.wallet.remove"},{"location":"javascript-api/#parameters_26","text":"Name Type Required Default Description address string|number true The account address, or index in the wallet.","title":"Parameters"},{"location":"javascript-api/#return_26","text":"boolean true if the wallet was removed. false if it couldn\u2019t be found.","title":"Return"},{"location":"javascript-api/#example_37","text":"> confluxWeb.cfx.accounts.wallet.remove('0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b'); true > confluxWeb.cfx.accounts.wallet.remove(0); true","title":"Example"},{"location":"javascript-api/#confluxwebcfxaccountwalletclear","text":"Securely empties the wallet and removes all its accounts. function clear()","title":"ConfluxWeb.cfx.account.wallet.clear"},{"location":"javascript-api/#parameters_27","text":"void","title":"Parameters"},{"location":"javascript-api/#return_27","text":"Object The wallet object.","title":"Return"},{"location":"javascript-api/#example_38","text":"> confluxWeb.cfx.accounts.wallet.clear(); Wallet { accounts: {}, accountsIndex: 0 ... }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractmethods_1","text":"","title":"ConfluxWeb.cfx.Contract.methods"},{"location":"javascript-api/#confluxwebcfxcontractmethodsencodeabi","text":"Encodes the ABI for this method. This can be used to send a transaction, call a method, or pass it into another smart contracts method as arguments. NOTE: contract instance create code see Contract.constructor function encodeABI()","title":"ConfluxWeb.cfx.Contract.methods.encodeABI"},{"location":"javascript-api/#parameters_28","text":"void","title":"Parameters"},{"location":"javascript-api/#return_28","text":"string The encoded ABI byte code to send via a transaction or call.","title":"Return"},{"location":"javascript-api/#example_39","text":"> await contract.methods.inc(1).encodeABI(); \"0x812600df0000000000000000000000000000000000000000000000000000000000000001\" > await contract.methods.count().encodeABI(); \"0x06661abd\"","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractmethodsestimategas","text":"Will call estimate the gas a method execution will take when executed in the EVM without sending any transaction. The estimation can differ from the actual gas used when later sending a transaction, as the state of the smart contract can be different at that time. NOTE: contract instance create code see Contract.constructor async function estimateGas()","title":"ConfluxWeb.cfx.Contract.methods.estimateGas"},{"location":"javascript-api/#parameters_29","text":"void","title":"Parameters"},{"location":"javascript-api/#return_29","text":"Promise.<number>","title":"Return"},{"location":"javascript-api/#example_40","text":"> await contract.methods.inc(1).estimateGas(); 26928 > await contract.methods.count().estimateGas(); 21655","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractmethodscall","text":"Will call a \u201cconstant\u201d method and execute its smart contract method in the EVM without sending any transaction. Note calling can not alter the smart contract state. NOTE: contract instance create code see Contract.constructor async function call()","title":"ConfluxWeb.cfx.Contract.methods.call"},{"location":"javascript-api/#parameters_30","text":"void","title":"Parameters"},{"location":"javascript-api/#return_30","text":"Promise contract method return value","title":"Return"},{"location":"javascript-api/#example_41","text":"> await contract.methods.inc(1).call(); BigNumber { _hex: '0xff' } > await contract.methods.count().call(); BigNumber { _hex: '0xfe' }","title":"Example"},{"location":"javascript-api/#confluxwebcfxcontractmethodssend","text":"Will send a transaction to the smart contract and execute its method. Note this can alter the smart contract state. NOTE: contract instance create code see Contract.constructor async function send(options)","title":"ConfluxWeb.cfx.Contract.methods.send"},{"location":"javascript-api/#parameters_31","text":"Name Type Required Default Description options object true options.from string true The address the transaction should be sent from. options.gasPrice string false contract.defaultGasPrice The gas price in wei to use for this transaction. options.gas number false contract.defaultGas The maximum gas provided for this transaction (gas limit). options.value number|string|BN|BigNumber false The value transferred for the transaction in drip.","title":"Parameters"},{"location":"javascript-api/#return_31","text":"Promise.<string> Transaction hash.","title":"Return"},{"location":"javascript-api/#example_42","text":"> await contract.methods.inc(1).send({ from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b', gas: 100000000, gasPrice: 819 }); \"0xb01101228cbd8619ab1f8f017530ff945b655472be211eb828b31bc7c97b9d5c\"","title":"Example"},{"location":"javascript-api/#confluxwebutils_1","text":"","title":"ConfluxWeb.utils"},{"location":"javascript-api/#confluxwebutilsrandomhex","text":"The randomHex library to generate cryptographically strong pseudo-random HEX strings from a given byte size. function randomHex(bytesSize)","title":"ConfluxWeb.utils.randomHex"},{"location":"javascript-api/#parameters_32","text":"Name Type Required Default Description bytesSize number true given byte size","title":"Parameters"},{"location":"javascript-api/#return_32","text":"string The generated random HEX string.","title":"Return"},{"location":"javascript-api/#example_43","text":"> confluxWeb.utils.randomHex(32) 0xd3185018552117d2c4b5277307c455b4746267b27ea133abd288c0b136c3865c > confluxWeb.utils.randomHex(4) 0x472ace2a > confluxWeb.utils.randomHex(2) 0x52ed > confluxWeb.utils.randomHex(1) 0x3b > confluxWeb.utils.randomHex(0) 0x","title":"Example"},{"location":"javascript-api/#confluxwebutilsisbn","text":"Checks if a given value is a BN.js instance. function isBN(bn)","title":"ConfluxWeb.utils.isBN"},{"location":"javascript-api/#parameters_33","text":"Name Type Required Default Description bn BN true An BN.js instance","title":"Parameters"},{"location":"javascript-api/#return_33","text":"boolean","title":"Return"},{"location":"javascript-api/#example_44","text":"> const bn = new BN(10) > confluxWeb.utils.isBN(bn) true","title":"Example"},{"location":"javascript-api/#confluxwebutilssha3","text":"Will calculate the sha3 of the input. function sha3(str)","title":"ConfluxWeb.utils.sha3"},{"location":"javascript-api/#parameters_34","text":"Name Type Required Default Description str string true A string to hash","title":"Parameters"},{"location":"javascript-api/#return_34","text":"string the result hash.","title":"Return"},{"location":"javascript-api/#example_45","text":"> confluxWeb.utils.sha3('234'); \"0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79\" > confluxWeb.utils.keccak256('234'); // alias \"0xc1912fee45d61c87cc5ea59dae311904cd86b84fee17cc96966216f811ce6a79\"","title":"Example"},{"location":"javascript-api/#confluxwebutilssoliditysha3","text":"Will calculate the sha3 of given input parameters in the same way solidity would. This means arguments will be ABI converted and tightly packed before being hashed. function soliditySha3(args)","title":"ConfluxWeb.utils.soliditySha3"},{"location":"javascript-api/#parameters_35","text":"Name Type Required Default Description ...args Array.<(string|number|object|BN)> false","title":"Parameters"},{"location":"javascript-api/#return_35","text":"void","title":"Return"},{"location":"javascript-api/#example_46","text":"> confluxWeb.utils.soliditySha3('234564535', '0xfff23243', true, -10); \"0x3e27a893dc40ef8a7f0841d96639de2f58a132be5ae466d40087a2cfa83b7179\" > confluxWeb.utils.soliditySha3('Hello!%'); // auto detects: string \"0x661136a4267dba9ccdf6bfddb7c00e714de936674c4bdb065a531cf1cb15c7fc\" > confluxWeb.utils.soliditySha3('234'); // auto detects: uint256 \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3(0xea); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3(new BN('234')); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3({type: 'uint256', value: '234'}); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3({t: 'uint', v: new BN('234')}); // same as above \"0x61c831beab28d67d1bb40b5ae1a11e2757fa842f031a2d0bc94a7867bc5d26c2\" > confluxWeb.utils.soliditySha3('0x407D73d8a49eeb85D32Cf465507dd71d507100c1'); \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'bytes', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // same result as above \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'address', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // same as above, but will do a checksum check, if its multi case \"0x4e8ebbefa452077428f93c9520d3edd60594ff452a29ac7d2ccc11d47f3ab95b\" > confluxWeb.utils.soliditySha3({t: 'bytes32', v: '0x407D73d8a49eeb85D32Cf465507dd71d507100c1'}); // different result as above \"0x3c69a194aaf415ba5d6afca734660d0a3d45acdc05d54cd1ca89a8988e7625b4\" > confluxWeb.utils.soliditySha3({t: 'string', v: 'Hello!%'}, {t: 'int8', v:-23}, {t: 'address', v: '0x85F43D8a49eeB85d32Cf465507DD71d507100C1d'}); \"0xa13b31627c1ed7aaded5aecec71baf02fe123797fffd45e662eac8e06fbe4955\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsishex","text":"Checks if a given string is a HEX string. function isHex(hex)","title":"ConfluxWeb.utils.isHex"},{"location":"javascript-api/#parameters_36","text":"Name Type Required Default Description hex string true The given HEX string.","title":"Parameters"},{"location":"javascript-api/#return_36","text":"boolean","title":"Return"},{"location":"javascript-api/#example_47","text":"> confluxWeb.utils.isHex('0xc1912'); true > confluxWeb.utils.isHex(0xc1912); true > confluxWeb.utils.isHex('c1912'); true > confluxWeb.utils.isHex(345); // this is tricky, as 345 can be a a HEX representation or a number, be careful when not having a 0x in front! true > confluxWeb.utils.isHex('0xZ1912'); false > confluxWeb.utils.isHex('Hello'); false","title":"Example"},{"location":"javascript-api/#confluxwebutilsishexstrict","text":"Checks if a given string is a HEX string. Difference to isHex() is that it expects HEX to be prefixed with 0x. function isHexStrict(hex)","title":"ConfluxWeb.utils.isHexStrict"},{"location":"javascript-api/#parameters_37","text":"Name Type Required Default Description hex string true The given HEX string.","title":"Parameters"},{"location":"javascript-api/#return_37","text":"boolean","title":"Return"},{"location":"javascript-api/#example_48","text":"> confluxWeb.utils.isHexStrict('0xc1912'); true > confluxWeb.utils.isHexStrict(0xc1912); false > confluxWeb.utils.isHexStrict('c1912'); false > confluxWeb.utils.isHexStrict(345); // this is tricky, as 345 can be a a HEX representation or a number, be careful when not having a 0x in front! false > confluxWeb.utils.isHexStrict('0xZ1912'); false > confluxWeb.utils.isHex('Hello'); false","title":"Example"},{"location":"javascript-api/#confluxwebutilsisaddress","text":"Checks if a given string is a valid Conflux address. It will also check the checksum, if the address has upper and lowercase letters. function isAddress(address)","title":"ConfluxWeb.utils.isAddress"},{"location":"javascript-api/#parameters_38","text":"Name Type Required Default Description address string true An address string.","title":"Parameters"},{"location":"javascript-api/#return_38","text":"string The checksum address.","title":"Return"},{"location":"javascript-api/#example_49","text":"> confluxWeb.utils.isAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d'); true > confluxWeb.utils.isAddress('c1912fee45d61c87cc5ea59dae31190fffff232d'); true > confluxWeb.utils.isAddress('0XC1912FEE45D61C87CC5EA59DAE31190FFFFF232D'); // as all is uppercase, no checksum will be checked true > confluxWeb.utils.isAddress('0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); true > confluxWeb.utils.isAddress('0xC1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); // wrong checksum false","title":"Example"},{"location":"javascript-api/#confluxwebutilstochecksumaddress","text":"Will convert an upper or lowercase Conflux address to a checksum address. function toChecksumAddress(address)","title":"ConfluxWeb.utils.toChecksumAddress"},{"location":"javascript-api/#parameters_39","text":"Name Type Required Default Description address string true An address string.","title":"Parameters"},{"location":"javascript-api/#return_39","text":"void","title":"Return"},{"location":"javascript-api/#example_50","text":"> confluxWeb.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff2323'); \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\" > confluxWeb.utils.toChecksumAddress('0XC1912FEE45D61C87CC5EA59DAE31190FFFFF232D'); // same as above \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"","title":"Example"},{"location":"javascript-api/#confluxwebutilscheckaddresschecksum","text":"Checks the checksum of a given address. Will also return false on non-checksum addresses. function checkAddressChecksum(address)","title":"ConfluxWeb.utils.checkAddressChecksum"},{"location":"javascript-api/#parameters_40","text":"Name Type Required Default Description address string true An address string.","title":"Parameters"},{"location":"javascript-api/#return_40","text":"boolean true when the checksum of the address is valid, false if its not a checksum address, or the checksum is invalid.","title":"Return"},{"location":"javascript-api/#example_51","text":"> confluxWeb.utils.checkAddressChecksum('0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d'); true","title":"Example"},{"location":"javascript-api/#confluxwebutilstohex","text":"Will auto convert any given value to HEX. Number strings will interpreted as numbers. Text strings will be interpreted as UTF-8 strings. function toHex(value)","title":"ConfluxWeb.utils.toHex"},{"location":"javascript-api/#parameters_41","text":"Name Type Required Default Description value string|number|BN|BigNumber true The input to convert to HEX.","title":"Parameters"},{"location":"javascript-api/#return_41","text":"string The resulting HEX string.","title":"Return"},{"location":"javascript-api/#example_52","text":"> confluxWeb.utils.toHex('234'); \"0xea\" > confluxWeb.utils.toHex(234); \"0xea\" > confluxWeb.utils.toHex(new BN('234')); \"0xea\" > confluxWeb.utils.toHex(new BigNumber('234')); \"0xea\" > confluxWeb.utils.toHex('I have 100\u20ac'); \"0x49206861766520313030e282ac\"","title":"Example"},{"location":"javascript-api/#confluxwebutilstobn","text":"Will safely convert any given value (including BigNumber.js instances) into a BN.js instance, for handling big numbers in JavaScript. NOTE: For just the BN.js class use utils.BN function toBN(num)","title":"ConfluxWeb.utils.toBN"},{"location":"javascript-api/#parameters_42","text":"Name Type Required Default Description num number|string true Number to convert to a big number.","title":"Parameters"},{"location":"javascript-api/#return_42","text":"BN The BN.js instance.","title":"Return"},{"location":"javascript-api/#example_53","text":"> confluxWeb.utils.toBN(1234).toString(); \"1234\" > confluxWeb.utils.toBN('1234').add(confluxWeb.utils.toBN('1')).toString(); \"1235\" > confluxWeb.utils.toBN('0xea').toString(); \"234\"","title":"Example"},{"location":"javascript-api/#confluxwebutilshextonumber","text":"Returns the number representation of a given HEX value. NOTE: This is not useful for big numbers, rather use utils.toBN instead. function hexToNumber(hex)","title":"ConfluxWeb.utils.hexToNumber"},{"location":"javascript-api/#parameters_43","text":"Name Type Required Default Description hex string true A string to hash.","title":"Parameters"},{"location":"javascript-api/#return_43","text":"number","title":"Return"},{"location":"javascript-api/#example_54","text":"> confluxWeb.utils.hexToNumber('0xea'); 234","title":"Example"},{"location":"javascript-api/#confluxwebutilshextonumberstring","text":"Returns the number representation of a given HEX value as a string. function hexToNumberString(hex)","title":"ConfluxWeb.utils.hexToNumberString"},{"location":"javascript-api/#parameters_44","text":"Name Type Required Default Description hex string true A string to hash","title":"Parameters"},{"location":"javascript-api/#return_44","text":"string The number as a string","title":"Return"},{"location":"javascript-api/#example_55","text":"> confluxWeb.utils.hexToNumberString('0xea'); \"234\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsnumbertohex","text":"Returns the HEX representation of a given number value. function numberToHex(num)","title":"ConfluxWeb.utils.numberToHex"},{"location":"javascript-api/#parameters_45","text":"Name Type Required Default Description num number|string|BN|BigNumber true A number as string or number.","title":"Parameters"},{"location":"javascript-api/#return_45","text":"string The HEX value of the given number.","title":"Return"},{"location":"javascript-api/#example_56","text":"> confluxWeb.utils.numberToHex('234'); '0xea'","title":"Example"},{"location":"javascript-api/#confluxwebutilshextoutf8","text":"Returns the UTF-8 string representation of a given HEX value. function hexToUtf8(hex)","title":"ConfluxWeb.utils.hexToUtf8"},{"location":"javascript-api/#parameters_46","text":"Name Type Required Default Description hex string true A HEX string to convert to a UTF-8 string.","title":"Parameters"},{"location":"javascript-api/#return_46","text":"string The UTF-8 string.","title":"Return"},{"location":"javascript-api/#example_57","text":"> confluxWeb.utils.hexToUtf8('0x49206861766520313030e282ac'); \"I have 100\u20ac\"","title":"Example"},{"location":"javascript-api/#confluxwebutilshextoascii","text":"Returns the ASCII string representation of a given HEX value. function hexToAscii(hex)","title":"ConfluxWeb.utils.hexToAscii"},{"location":"javascript-api/#parameters_47","text":"Name Type Required Default Description hex string true A HEX string to convert to a ASCII string.","title":"Parameters"},{"location":"javascript-api/#return_47","text":"string The ASCII string.","title":"Return"},{"location":"javascript-api/#example_58","text":"> confluxWeb.utils.hexToAscii('0x4920686176652031303021'); \"I have 100!\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsutf8tohex","text":"Returns the HEX representation of a given UTF-8 string. function utf8ToHex(str)","title":"ConfluxWeb.utils.utf8ToHex"},{"location":"javascript-api/#parameters_48","text":"Name Type Required Default Description str string true A UTF-8 string to convert to a HEX string.","title":"Parameters"},{"location":"javascript-api/#return_48","text":"string The HEX string","title":"Return"},{"location":"javascript-api/#example_59","text":"> confluxWeb.utils.utf8ToHex('I have 100\u20ac'); \"0x49206861766520313030e282ac\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsasciitohex","text":"Returns the HEX representation of a given ASCII string. NOTE: it behaves differently from 1.2.1 function asciiToHex(str)","title":"ConfluxWeb.utils.asciiToHex"},{"location":"javascript-api/#parameters_49","text":"Name Type Required Default Description str string true A ASCII string to convert to a HEX string.","title":"Parameters"},{"location":"javascript-api/#return_49","text":"string The HEX string","title":"Return"},{"location":"javascript-api/#example_60","text":"> confluxWeb.utils.asciiToHex('I have 100!'); \"0x4920686176652031303021\"","title":"Example"},{"location":"javascript-api/#confluxwebutilshextobytes","text":"Returns a byte array from the given HEX string. NOTE: it behaves differently from 1.2.1 function hexToBytes(hex)","title":"ConfluxWeb.utils.hexToBytes"},{"location":"javascript-api/#parameters_50","text":"Name Type Required Default Description hex string true A HEX to convert.","title":"Parameters"},{"location":"javascript-api/#return_50","text":"array The byte array.","title":"Return"},{"location":"javascript-api/#example_61","text":"> confluxWeb.utils.hexToBytes('0x000000ea'); [ 0, 0, 0, 234 ] > confluxWeb.utils.hexToBytes(0x000000ea); [ 234 ]","title":"Example"},{"location":"javascript-api/#confluxwebutilsbytestohex","text":"Returns a HEX string from a byte array. function bytesToHex(byteArray)","title":"ConfluxWeb.utils.bytesToHex"},{"location":"javascript-api/#parameters_51","text":"Name Type Required Default Description byteArray array true A byte array to convert.","title":"Parameters"},{"location":"javascript-api/#return_51","text":"string The HEX string","title":"Return"},{"location":"javascript-api/#example_62","text":"> confluxWeb.utils.bytesToHex([ 72, 101, 108, 108, 111, 33, 36 ]); \"0x48656c6c6f2124\"","title":"Example"},{"location":"javascript-api/#confluxwebutilstodrip","text":"Converts any cfx value value into drip. NOTE: \"drip\" are the smallest conflux unit, and you should always make calculations in drip and convert only for display reasons. NOTE: can not pass a Number, only string or BN are acceptable function toDrip(str,unit)","title":"ConfluxWeb.utils.toDrip"},{"location":"javascript-api/#parameters_52","text":"Name Type Required Default Description str string|BN true The value unit string false \"cfx\" The cfx to convert from. Possible units are ['cfx', 'gdrip', 'drip']","title":"Parameters"},{"location":"javascript-api/#return_52","text":"string|BN If a number, or string is given it returns a number string, otherwise a BN.js instance.","title":"Return"},{"location":"javascript-api/#example_63","text":"> confluxWeb.utils.toDrip('1'); \"1000000000000000000\" > confluxWeb.utils.toDrip('1', 'cfx'); \"1000000000000000000\" > confluxWeb.utils.toDrip('1', 'gdrip'); \"1000000000\" > confluxWeb.utils.toDrip('1', 'drip'); \"1\"","title":"Example"},{"location":"javascript-api/#confluxwebutilsfromdrip","text":"Converts any drip value into a cfx value. NOTE: \"drip\" are the smallest conflux unit, and you should always make calculations in drip and convert only for display reasons. NOTE: can not pass a Number, only string or BN are acceptable function fromDrip(str,unit)","title":"ConfluxWeb.utils.fromDrip"},{"location":"javascript-api/#parameters_53","text":"Name Type Required Default Description str string|BN true The value in drip unit string false \"cfx\" The cfx to convert to. Possible units are ['cfx', 'gdrip', 'drip']","title":"Parameters"},{"location":"javascript-api/#return_53","text":"string|BN If a number, or string is given it returns a number string, otherwise a BN.js instance.","title":"Return"},{"location":"javascript-api/#example_64","text":"> confluxWeb.utils.fromDrip('1'); \"0.000000000000000001\" > confluxWeb.utils.fromDrip('1', 'cfx'); \"0.000000000000000001\" > confluxWeb.utils.fromDrip('1', 'gdrip'); \"0.000000001\" > confluxWeb.utils.fromDrip('1', 'gdrip'); \"1\"","title":"Example"},{"location":"javascript-api/#confluxwebutilspadleft","text":"Adds a padding on the left of a string, Useful for adding paddings to HEX strings. function padLeft(value,characterAmount,sign)","title":"ConfluxWeb.utils.padLeft"},{"location":"javascript-api/#parameters_54","text":"Name Type Required Default Description value string true The string to add padding on the left. characterAmount number true The number of characters the total string should have. sign string false \"0\" The character sign to use.","title":"Parameters"},{"location":"javascript-api/#return_54","text":"string The padded string.","title":"Return"},{"location":"javascript-api/#example_65","text":"> confluxWeb.utils.padLeft('0x3456ff', 20); \"0x000000000000003456ff\" > confluxWeb.utils.padLeft(0x3456ff, 20); \"0x000000000000003456ff\" > confluxWeb.utils.padLeft('Hello', 20, 'x'); \"xxxxxxxxxxxxxxxHello\"","title":"Example"},{"location":"javascript-api/#confluxwebutilspadright","text":"Adds a padding on the right of a string, Useful for adding paddings to HEX strings. function padRight(value,characterAmount,sign)","title":"ConfluxWeb.utils.padRight"},{"location":"javascript-api/#parameters_55","text":"Name Type Required Default Description value string true The string to add padding on the right. characterAmount number true The number of characters the total string should have. sign string false \"0\" The character sign to use.","title":"Parameters"},{"location":"javascript-api/#return_55","text":"string The padded string.","title":"Return"},{"location":"javascript-api/#example_66","text":"> confluxWeb.utils.padRight('0x3456ff', 20); \"0x3456ff00000000000000\" > confluxWeb.utils.padRight(0x3456ff, 20); \"0x3456ff00000000000000\" > confluxWeb.utils.padRight('Hello', 20, 'x'); \"Helloxxxxxxxxxxxxxxx\"","title":"Example"},{"location":"javascript-api/#confluxwebutilstotwoscomplement","text":"Converts a negative numer into a two\u2019s complement. function toTwosComplement(value)","title":"ConfluxWeb.utils.toTwosComplement"},{"location":"javascript-api/#parameters_56","text":"Name Type Required Default Description value number|string|BigNumber true The number to convert.","title":"Parameters"},{"location":"javascript-api/#return_56","text":"string The converted hex string.","title":"Return"},{"location":"javascript-api/#example_67","text":"> confluxWeb.utils.toTwosComplement('-1'); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" > confluxWeb.utils.toTwosComplement(-1); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" > confluxWeb.utils.toTwosComplement('0x1'); \"0x0000000000000000000000000000000000000000000000000000000000000001\" > confluxWeb.utils.toTwosComplement(-15); \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1\" > confluxWeb.utils.toTwosComplement('-0x1'); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"","title":"Example"},{"location":"javascript-example/","text":"Smart Contracts on Conflux Chain \u00b6 This document will show you the way to deploy a smart contract on conflux chain and interact with it. Preparation \u00b6 At the beginning, we should get the bytecode and ABI of the smart contract we want to deploy, check here for more details. Here we use Hash Time Locked Contract(HTLC): const data = '0x608060405234801561001057600080fd5b5060103373ffffffffffffffffffffffffffffffffffffffff167f7067f915d1c61a35abf2d3154544a7d09111584b648bdef0826a3f4f9a19f11a60405160405180910390a3611355806100656000396000f3fe608060405260043610610078576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063335ef5bd1461007d57806363615149146100e957806368ec2294146101465780637249fbb614610195578063bbe4fd50146101e8578063e16c7d9814610213575b600080fd5b6100d36004803603606081101561009357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001909291905050506102f3565b6040518082815260200191505060405180910390f35b3480156100f557600080fd5b5061012c6004803603604081101561010c57600080fd5b8101908080359060200190929190803590602001909291905050506107d7565b604051808215151515815260200191505060405180910390f35b34801561015257600080fd5b5061017f6004803603602081101561016957600080fd5b8101908080359060200190929190505050610cb3565b6040518082815260200191505060405180910390f35b3480156101a157600080fd5b506101ce600480360360208110156101b857600080fd5b8101908080359060200190929190505050610d7b565b604051808215151515815260200191505060405180910390f35b3480156101f457600080fd5b506101fd61119e565b6040518082815260200191505060405180910390f35b34801561021f57600080fd5b5061024c6004803603602081101561023657600080fd5b81019080803590602001909291905050506111a6565b604051808973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200187815260200186815260200185815260200184151515158152602001831515151581526020018281526020019850505050505050505060405180910390f35b6000803411151561036c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f6d73672e76616c7565206d757374206265203e2030000000000000000000000081525060200191505060405180910390fd5b81428111151561040a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001807f74696d656c6f636b2074696d65206d75737420626520696e207468652066757481526020017f757265000000000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b60023386348787604051602001808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401848152602001838152602001828152602001955050505050506040516020818303038152906040526040518082805190602001908083835b6020831015156104f757805182526020820191506020810190506020830392506104d2565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610539573d6000803e3d6000fd5b5050506040513d602081101561054e57600080fd5b8101908080519060200190929190505050915061056a826112bb565b156105dd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260138152602001807f4475706c696361746520636f6e7472616374210000000000000000000000000081525060200191505060405180910390fd5b610100604051908101604052803373ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff168152602001348152602001858152602001848152602001600015158152602001600015158152602001600060010281525060008084815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160020155606082015181600301556080820151816004015560a08201518160050160006101000a81548160ff02191690831515021790555060c08201518160050160016101000a81548160ff02191690831515021790555060e082015181600601559050508473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16837f329a8316ed9c3b2299597538371c2944c5026574e803b1ec31d6113e1cd67bde34888860405180848152602001838152602001828152602001935050505060405180910390a4509392505050565b6000826107e3816112bb565b1515610857576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f636f6e7472616374496420646f6573206e6f742065786973740000000000000081525060200191505060405180910390fd5b8383600281604051602001808281526020019150506040516020818303038152906040526040518082805190602001908083835b6020831015156108b0578051825260208201915060208101905060208303925061088b565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa1580156108f2573d6000803e3d6000fd5b5050506040513d602081101561090757600080fd5b8101908080519060200190929190505050600080848152602001908152602001600020600301541415156109a3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f686173686c6f636b206861736820646f6573206e6f74206d617463680000000081525060200191505060405180910390fd5b853373ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515610a7c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f776974686472617761626c653a206e6f7420726563656976657200000000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160009054906101000a900460ff161515141515610b1a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601f8152602001807f776974686472617761626c653a20616c72656164792077697468647261776e0081525060200191505060405180910390fd5b4260008083815260200190815260200160002060040154111515610bcc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001807f776974686472617761626c653a2074696d656c6f636b2074696d65206d75737481526020017f20626520696e207468652066757475726500000000000000000000000000000081525060400191505060405180910390fd5b6000806000898152602001908152602001600020905086816006018190555060018160050160006101000a81548160ff0219169083151502179055508060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600201549081150290604051600060405180830381858888f19350505050158015610c76573d6000803e3d6000fd5b50877fd6fd4c8e45bf0c70693141c7ce46451b6a6a28ac8386fca2ba914044e0e2391660405160405180910390a260019550505050505092915050565b6000600282604051602001808281526020019150506040516020818303038152906040526040518082805190602001908083835b602083101515610d0c5780518252602082019150602081019050602083039250610ce7565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610d4e573d6000803e3d6000fd5b5050506040513d6020811015610d6357600080fd5b81019080805190602001909291905050509050919050565b600081610d87816112bb565b1515610dfb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f636f6e7472616374496420646f6573206e6f742065786973740000000000000081525060200191505060405180910390fd5b823373ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515610ed4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f726566756e6461626c653a206e6f742073656e6465720000000000000000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160019054906101000a900460ff161515141515610f72576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f726566756e6461626c653a20616c726561647920726566756e6465640000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160009054906101000a900460ff161515141515611010576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f726566756e6461626c653a20616c72656164792077697468647261776e00000081525060200191505060405180910390fd5b4260008083815260200190815260200160002060040154111515156110c3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001807f726566756e6461626c653a2074696d656c6f636b206e6f74207965742070617381526020017f736564000000000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b6000806000868152602001908152602001600020905060018160050160016101000a81548160ff0219169083151502179055508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600201549081150290604051600060405180830381858888f19350505050158015611164573d6000803e3d6000fd5b50847f989b3a845197c9aec15f8982bbb30b5da714050e662a7a287bb1a94c81e2e70e60405160405180910390a260019350505050919050565b600042905090565b600080600080600080600080600015156111bf8a6112bb565b1515141561120057600080600080600080600080879750869650859550846001029450839350806001029050975097509750975097509750975097506112b0565b60008060008b815260200190815260200160002090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168260020154836003015484600401548560050160009054906101000a900460ff168660050160019054906101000a900460ff16876006015487975086965098509850985098509850985098509850505b919395975091939597565b60008073ffffffffffffffffffffffffffffffffffffffff1660008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415905091905056fea165627a7a72305820933970f75b5a7e373d3dcd9b9b46074042159b21a16d450c072e94ab9230d2ec0029'; const abi = [{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_hashlock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"newContract\",\"outputs\":[{\"name\":\"contractId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_preimage\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"bytes32\"}],\"name\":\"getSha256\",\"outputs\":[{\"name\":\"hashvalue\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getContract\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"name\":\"timelock\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"bool\"},{\"name\":\"refunded\",\"type\":\"bool\"},{\"name\":\"preimage\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"LogHTLCNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"Constructed\",\"type\":\"event\"}]; The source code of corresponding Solidity code can be found here: https://github.com/posaggen/confluxWeb-HTLC-Example/blob/master/HashedTimelock.sol We will use this smart contract as example in the rest of this document. Deploy \u00b6 Create a confluxWeb instance and set a proper provider: const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); Add a wallet account using your private key. For new Conflux user, new accounts can be created from official website: https://wallet.confluxscan.io/login const priv_key = '0xdd84f341fb45c764a094d35bf484367b8d2797a997142f9c5cd4d488556f0db7'; const pub_key = '0x81f3521d71990945b99e1c592750d7157f2b544f'; confluxWeb.cfx.accounts.wallet.add(priv_key); Check your balance. For new Conflux users, they can claim some conflux test token at the mainpage of web wallet. ConfluxWeb.cfx.getBalance(pub_key).then(console.log); Construct a contract instance with ABI: const cfx_htlc = new confluxWeb.cfx.Contract(abi); call deploy() method and send the transaction to create contract, get the transaction hash: const tx_hash = await cfx_htlc.deploy({ data: data, }).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); Here, our contract creation transaction has been sent and we should wait for its receipt to make sure the transaction has been confirmed and executed. Following function periodically requests transaction receipt from Conflux chain until it got the receipt whose state root is not empty, which means the transaction has been executed successfully and the state tree has been computed. const sleep = (ms) => { return new Promise(resolve => setTimeout(resolve, ms)); }; async function waitForReceipt(hash) { while (true) { // get receipt let res = await confluxWeb.cfx.getTransactionReceipt(hash); if (res != null) { // make sure state root is already calculated if (res.stateRoot != '0x0000000000000000000000000000000000000000000000000000000000000000') { return res; } } await sleep(10000); } } Retrieve transaction receipt and get the address of the smart contract created in this transaction: const receipt = await waitForReceipt(tx_hash); let cfx_htlc_addr = receipt.contractCreated; Now we have deployed the HTLC successfully. Here is a summary of the code about deploy: async function deployHTLC() { // get contract instance from abi const cfx_htlc = new confluxWeb.cfx.Contract(abi); // deploy contract and send transaction const tx_hash = await cfx_htlc.deploy({ data: data, }).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); // wait for receipt const receipt = await waitForReceipt(tx_hash); return receipt.contractCreated; } Call method \u00b6 In this session, we will fund some money to the HTLC and build a hash timed lock. Firstly, we need to set the hash secret, timelock and amount of conflux: const secret = \"0xc4d2751c52311d0d7efe44e5c4195e058ad5ef4bb89b3e1761b24dc277b132c2\"; const secret_hash = \"0x2bc79b7514884ab00da924607d71542cc4fed3beb8518e747726ae30ab6c7944\"; const timelock = confluxWeb.utils.toHex(BigNumber((new Date()).getTime() + 3600 * 72)); const amount = confluxWeb.utils.toHex(BigNumber(10000000000000000)); // 1e16 = 0.01 cfx(eth) Then we try to interact with the HTLC we deployed just now. To do this, we need to construct a contract instance from the contract address and ABI: const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); Same as above, we call the newContract method and send a transaction, then wait for its receipt. const tx_hash = await cfx_htlc.methods.newContract(pub_key, secret_hash, timelock).send({ from: pub_key, gas: 10000000, gasPrice: 100, value: amount, }); const receipt = await waitForReceipt(tx_hash); After that, we successfully created a new hash timed lock and we can check its id from the events emitted during the execution of the smart contract method: let logs = await confluxWeb.cfx.getPastLogs({ fromEpoch: 'earliest', toEpoch: 'latest_mined', address : cfx_htlc_addr, topics: [confluxWeb.utils.soliditySha3(\"LogHTLCNew(bytes32,address,address,uint256,bytes32,uint256)\")], }); let htlc_id = null; for (let i = 0; i < logs.length; ++i) if (logs[i].transactionHash === tx_hash) htlc_id = logs[i].topics[1]; Summary of the code of this session: async function fund(cfx_htlc_addr) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // call methods newContract() to build a new htlc to pub_key itself const tx_hash = await cfx_htlc.methods.newContract(pub_key, secret_hash, timelock).send({ from: pub_key, gas: 10000000, gasPrice: 100, value: amount, }); const receipt = await waitForReceipt(tx_hash); // get the created hash time lock id from event logs let logs = await confluxWeb.cfx.getPastLogs({ fromEpoch: 'earliest', toEpoch: 'latest_mined', address : cfx_htlc_addr, topics: [confluxWeb.utils.soliditySha3(\"LogHTLCNew(bytes32,address,address,uint256,bytes32,uint256)\")], }); for (let i = 0; i < logs.length; ++i) if (logs[i].transactionHash === tx_hash) return logs[i].topics[1]; } Check \u00b6 We can will use a 'constant' call to getContract method to check the hash timed lock we created, make sure its parameters is correct: // check if created HTLC is valid using a \"constant\" call async function checkHTLC(cfx_htlc_addr, htlc_id) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // make a call to get information of HTLC with htlc_id let c = await cfx_htlc.methods.getContract(htlc_id).call(); // check information if (pub_key !== c[0].toLowerCase() || pub_key !== c[1].toLowerCase() || amount !== confluxWeb.utils.toHex(c[2]) || secret_hash !== c[3] || timelock !== confluxWeb.utils.toHex(c[4]) || c[5] || c[6]) { return false; } return true; } Withdraw \u00b6 Now we want to withdraw the money. Similar to fund, we call withdraw method to do this: async function withdraw(cfx_htlc_addr, htlc_id) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // call methods newContract() to build a new htlc to pub_key itself const tx_hash = await cfx_htlc.methods.withdraw(htlc_id, secret).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); const receipt = await waitForReceipt(tx_hash); return receipt.outcomeStatus; } Summary \u00b6 In this document, we showed the basic ways to use ConfluxWeb library to develop smart contract on Conflux chain, including deployment, interaction, monitoring the events. The summary of the HTLC demo can be found here .","title":"Smart Contracts on Conflux Chain"},{"location":"javascript-example/#smart-contracts-on-conflux-chain","text":"This document will show you the way to deploy a smart contract on conflux chain and interact with it.","title":"Smart Contracts on Conflux Chain"},{"location":"javascript-example/#preparation","text":"At the beginning, we should get the bytecode and ABI of the smart contract we want to deploy, check here for more details. Here we use Hash Time Locked Contract(HTLC): const data = '0x608060405234801561001057600080fd5b5060103373ffffffffffffffffffffffffffffffffffffffff167f7067f915d1c61a35abf2d3154544a7d09111584b648bdef0826a3f4f9a19f11a60405160405180910390a3611355806100656000396000f3fe608060405260043610610078576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063335ef5bd1461007d57806363615149146100e957806368ec2294146101465780637249fbb614610195578063bbe4fd50146101e8578063e16c7d9814610213575b600080fd5b6100d36004803603606081101561009357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001909291905050506102f3565b6040518082815260200191505060405180910390f35b3480156100f557600080fd5b5061012c6004803603604081101561010c57600080fd5b8101908080359060200190929190803590602001909291905050506107d7565b604051808215151515815260200191505060405180910390f35b34801561015257600080fd5b5061017f6004803603602081101561016957600080fd5b8101908080359060200190929190505050610cb3565b6040518082815260200191505060405180910390f35b3480156101a157600080fd5b506101ce600480360360208110156101b857600080fd5b8101908080359060200190929190505050610d7b565b604051808215151515815260200191505060405180910390f35b3480156101f457600080fd5b506101fd61119e565b6040518082815260200191505060405180910390f35b34801561021f57600080fd5b5061024c6004803603602081101561023657600080fd5b81019080803590602001909291905050506111a6565b604051808973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200187815260200186815260200185815260200184151515158152602001831515151581526020018281526020019850505050505050505060405180910390f35b6000803411151561036c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f6d73672e76616c7565206d757374206265203e2030000000000000000000000081525060200191505060405180910390fd5b81428111151561040a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001807f74696d656c6f636b2074696d65206d75737420626520696e207468652066757481526020017f757265000000000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b60023386348787604051602001808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401848152602001838152602001828152602001955050505050506040516020818303038152906040526040518082805190602001908083835b6020831015156104f757805182526020820191506020810190506020830392506104d2565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610539573d6000803e3d6000fd5b5050506040513d602081101561054e57600080fd5b8101908080519060200190929190505050915061056a826112bb565b156105dd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260138152602001807f4475706c696361746520636f6e7472616374210000000000000000000000000081525060200191505060405180910390fd5b610100604051908101604052803373ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff168152602001348152602001858152602001848152602001600015158152602001600015158152602001600060010281525060008084815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160020155606082015181600301556080820151816004015560a08201518160050160006101000a81548160ff02191690831515021790555060c08201518160050160016101000a81548160ff02191690831515021790555060e082015181600601559050508473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16837f329a8316ed9c3b2299597538371c2944c5026574e803b1ec31d6113e1cd67bde34888860405180848152602001838152602001828152602001935050505060405180910390a4509392505050565b6000826107e3816112bb565b1515610857576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f636f6e7472616374496420646f6573206e6f742065786973740000000000000081525060200191505060405180910390fd5b8383600281604051602001808281526020019150506040516020818303038152906040526040518082805190602001908083835b6020831015156108b0578051825260208201915060208101905060208303925061088b565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa1580156108f2573d6000803e3d6000fd5b5050506040513d602081101561090757600080fd5b8101908080519060200190929190505050600080848152602001908152602001600020600301541415156109a3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f686173686c6f636b206861736820646f6573206e6f74206d617463680000000081525060200191505060405180910390fd5b853373ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515610a7c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f776974686472617761626c653a206e6f7420726563656976657200000000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160009054906101000a900460ff161515141515610b1a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601f8152602001807f776974686472617761626c653a20616c72656164792077697468647261776e0081525060200191505060405180910390fd5b4260008083815260200190815260200160002060040154111515610bcc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001807f776974686472617761626c653a2074696d656c6f636b2074696d65206d75737481526020017f20626520696e207468652066757475726500000000000000000000000000000081525060400191505060405180910390fd5b6000806000898152602001908152602001600020905086816006018190555060018160050160006101000a81548160ff0219169083151502179055508060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600201549081150290604051600060405180830381858888f19350505050158015610c76573d6000803e3d6000fd5b50877fd6fd4c8e45bf0c70693141c7ce46451b6a6a28ac8386fca2ba914044e0e2391660405160405180910390a260019550505050505092915050565b6000600282604051602001808281526020019150506040516020818303038152906040526040518082805190602001908083835b602083101515610d0c5780518252602082019150602081019050602083039250610ce7565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610d4e573d6000803e3d6000fd5b5050506040513d6020811015610d6357600080fd5b81019080805190602001909291905050509050919050565b600081610d87816112bb565b1515610dfb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f636f6e7472616374496420646f6573206e6f742065786973740000000000000081525060200191505060405180910390fd5b823373ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515610ed4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f726566756e6461626c653a206e6f742073656e6465720000000000000000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160019054906101000a900460ff161515141515610f72576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f726566756e6461626c653a20616c726561647920726566756e6465640000000081525060200191505060405180910390fd5b6000151560008083815260200190815260200160002060050160009054906101000a900460ff161515141515611010576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f726566756e6461626c653a20616c72656164792077697468647261776e00000081525060200191505060405180910390fd5b4260008083815260200190815260200160002060040154111515156110c3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001807f726566756e6461626c653a2074696d656c6f636b206e6f74207965742070617381526020017f736564000000000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b6000806000868152602001908152602001600020905060018160050160016101000a81548160ff0219169083151502179055508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600201549081150290604051600060405180830381858888f19350505050158015611164573d6000803e3d6000fd5b50847f989b3a845197c9aec15f8982bbb30b5da714050e662a7a287bb1a94c81e2e70e60405160405180910390a260019350505050919050565b600042905090565b600080600080600080600080600015156111bf8a6112bb565b1515141561120057600080600080600080600080879750869650859550846001029450839350806001029050975097509750975097509750975097506112b0565b60008060008b815260200190815260200160002090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168260020154836003015484600401548560050160009054906101000a900460ff168660050160019054906101000a900460ff16876006015487975086965098509850985098509850985098509850505b919395975091939597565b60008073ffffffffffffffffffffffffffffffffffffffff1660008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415905091905056fea165627a7a72305820933970f75b5a7e373d3dcd9b9b46074042159b21a16d450c072e94ab9230d2ec0029'; const abi = [{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_hashlock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"newContract\",\"outputs\":[{\"name\":\"contractId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_preimage\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"bytes32\"}],\"name\":\"getSha256\",\"outputs\":[{\"name\":\"hashvalue\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getContract\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"name\":\"timelock\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"bool\"},{\"name\":\"refunded\",\"type\":\"bool\"},{\"name\":\"preimage\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"LogHTLCNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"Constructed\",\"type\":\"event\"}]; The source code of corresponding Solidity code can be found here: https://github.com/posaggen/confluxWeb-HTLC-Example/blob/master/HashedTimelock.sol We will use this smart contract as example in the rest of this document.","title":"Preparation"},{"location":"javascript-example/#deploy","text":"Create a confluxWeb instance and set a proper provider: const ConfluxWeb = require('conflux-web'); const confluxWeb = new ConfluxWeb('http://testnet-jsonrpc.conflux-chain.org:12537'); Add a wallet account using your private key. For new Conflux user, new accounts can be created from official website: https://wallet.confluxscan.io/login const priv_key = '0xdd84f341fb45c764a094d35bf484367b8d2797a997142f9c5cd4d488556f0db7'; const pub_key = '0x81f3521d71990945b99e1c592750d7157f2b544f'; confluxWeb.cfx.accounts.wallet.add(priv_key); Check your balance. For new Conflux users, they can claim some conflux test token at the mainpage of web wallet. ConfluxWeb.cfx.getBalance(pub_key).then(console.log); Construct a contract instance with ABI: const cfx_htlc = new confluxWeb.cfx.Contract(abi); call deploy() method and send the transaction to create contract, get the transaction hash: const tx_hash = await cfx_htlc.deploy({ data: data, }).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); Here, our contract creation transaction has been sent and we should wait for its receipt to make sure the transaction has been confirmed and executed. Following function periodically requests transaction receipt from Conflux chain until it got the receipt whose state root is not empty, which means the transaction has been executed successfully and the state tree has been computed. const sleep = (ms) => { return new Promise(resolve => setTimeout(resolve, ms)); }; async function waitForReceipt(hash) { while (true) { // get receipt let res = await confluxWeb.cfx.getTransactionReceipt(hash); if (res != null) { // make sure state root is already calculated if (res.stateRoot != '0x0000000000000000000000000000000000000000000000000000000000000000') { return res; } } await sleep(10000); } } Retrieve transaction receipt and get the address of the smart contract created in this transaction: const receipt = await waitForReceipt(tx_hash); let cfx_htlc_addr = receipt.contractCreated; Now we have deployed the HTLC successfully. Here is a summary of the code about deploy: async function deployHTLC() { // get contract instance from abi const cfx_htlc = new confluxWeb.cfx.Contract(abi); // deploy contract and send transaction const tx_hash = await cfx_htlc.deploy({ data: data, }).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); // wait for receipt const receipt = await waitForReceipt(tx_hash); return receipt.contractCreated; }","title":"Deploy"},{"location":"javascript-example/#call-method","text":"In this session, we will fund some money to the HTLC and build a hash timed lock. Firstly, we need to set the hash secret, timelock and amount of conflux: const secret = \"0xc4d2751c52311d0d7efe44e5c4195e058ad5ef4bb89b3e1761b24dc277b132c2\"; const secret_hash = \"0x2bc79b7514884ab00da924607d71542cc4fed3beb8518e747726ae30ab6c7944\"; const timelock = confluxWeb.utils.toHex(BigNumber((new Date()).getTime() + 3600 * 72)); const amount = confluxWeb.utils.toHex(BigNumber(10000000000000000)); // 1e16 = 0.01 cfx(eth) Then we try to interact with the HTLC we deployed just now. To do this, we need to construct a contract instance from the contract address and ABI: const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); Same as above, we call the newContract method and send a transaction, then wait for its receipt. const tx_hash = await cfx_htlc.methods.newContract(pub_key, secret_hash, timelock).send({ from: pub_key, gas: 10000000, gasPrice: 100, value: amount, }); const receipt = await waitForReceipt(tx_hash); After that, we successfully created a new hash timed lock and we can check its id from the events emitted during the execution of the smart contract method: let logs = await confluxWeb.cfx.getPastLogs({ fromEpoch: 'earliest', toEpoch: 'latest_mined', address : cfx_htlc_addr, topics: [confluxWeb.utils.soliditySha3(\"LogHTLCNew(bytes32,address,address,uint256,bytes32,uint256)\")], }); let htlc_id = null; for (let i = 0; i < logs.length; ++i) if (logs[i].transactionHash === tx_hash) htlc_id = logs[i].topics[1]; Summary of the code of this session: async function fund(cfx_htlc_addr) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // call methods newContract() to build a new htlc to pub_key itself const tx_hash = await cfx_htlc.methods.newContract(pub_key, secret_hash, timelock).send({ from: pub_key, gas: 10000000, gasPrice: 100, value: amount, }); const receipt = await waitForReceipt(tx_hash); // get the created hash time lock id from event logs let logs = await confluxWeb.cfx.getPastLogs({ fromEpoch: 'earliest', toEpoch: 'latest_mined', address : cfx_htlc_addr, topics: [confluxWeb.utils.soliditySha3(\"LogHTLCNew(bytes32,address,address,uint256,bytes32,uint256)\")], }); for (let i = 0; i < logs.length; ++i) if (logs[i].transactionHash === tx_hash) return logs[i].topics[1]; }","title":"Call method"},{"location":"javascript-example/#check","text":"We can will use a 'constant' call to getContract method to check the hash timed lock we created, make sure its parameters is correct: // check if created HTLC is valid using a \"constant\" call async function checkHTLC(cfx_htlc_addr, htlc_id) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // make a call to get information of HTLC with htlc_id let c = await cfx_htlc.methods.getContract(htlc_id).call(); // check information if (pub_key !== c[0].toLowerCase() || pub_key !== c[1].toLowerCase() || amount !== confluxWeb.utils.toHex(c[2]) || secret_hash !== c[3] || timelock !== confluxWeb.utils.toHex(c[4]) || c[5] || c[6]) { return false; } return true; }","title":"Check"},{"location":"javascript-example/#withdraw","text":"Now we want to withdraw the money. Similar to fund, we call withdraw method to do this: async function withdraw(cfx_htlc_addr, htlc_id) { // get contract instance from address and abi const cfx_htlc = new confluxWeb.cfx.Contract(abi, cfx_htlc_addr); // call methods newContract() to build a new htlc to pub_key itself const tx_hash = await cfx_htlc.methods.withdraw(htlc_id, secret).send({ from: pub_key, gas: 10000000, gasPrice: 100, }); const receipt = await waitForReceipt(tx_hash); return receipt.outcomeStatus; }","title":"Withdraw"},{"location":"javascript-example/#summary","text":"In this document, we showed the basic ways to use ConfluxWeb library to develop smart contract on Conflux chain, including deployment, interaction, monitoring the events. The summary of the HTLC demo can be found here .","title":"Summary"},{"location":"json-rpc/","text":"Conflux JSON-RPC API \u00b6 The Conflux JSON-RPC API is a collection of interfaces which allow you to interact with a local or remote Conflux node, using an HTTP connection in JSON-RPC protocol. The following is an API reference documentation with examples. JSON-RPC \u00b6 JSON is a lightweight data-interchange format. It can represent numbers, strings, ordered sequences of values, and collections of name/value pairs. JSON-RPC is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over HTTP, or in many various message passing environments. It uses JSON (RFC 4627) as data format. JavaScript API \u00b6 There is also a JavaScript library js-conflux-sdk provided, for you to interact with a Conflux node from inside a JavaScript application, which gives a convenient interface for the RPC methods. JSON-RPC endpoint && support \u00b6 Currently, Conflux has a Rust implementation that supports JSON-RPC 2.0 and HTTP. HEX value encoding \u00b6 At present there are two key datatypes that are passed over JSON: unformatted byte arrays and quantities. Both are passed with a hex encoding, however with different requirements to formatting: When encoding QUANTITIES (integers, numbers): encode as hex, prefix with \"0x\", the most compact representation (slight exception: zero should be represented as \"0x0\"). Examples: 0x41 (65 in decimal) 0x400 (1024 in decimal) WRONG: 0x (should always have at least one digit - zero is \"0x0\") WRONG: 0x0400 (no leading zeroes allowed) WRONG: ff (must be prefixed 0x) When encoding UNFORMATTED DATA (byte arrays, account addresses, hashes, bytecode arrays): encode as hex, prefix with \"0x\", two hex digits per byte. Examples: 0x41 (size 1, \"A\") 0x004200 (size 3, \"\\0B\\0\") 0x (size 0, \"\") WRONG: 0xf0f0f (must be even number of digits) WRONG: 004200 (must be prefixed 0x) The epoch number parameter \u00b6 The following methods have an epoch number parameter: cfx_call cfx_epochNumber cfx_estimateGasAndCollateral cfx_getAccumulateInterestRate cfx_getAdmin cfx_getBalance cfx_getBlockByEpochNumber cfx_getBlocksByEpoch cfx_getCode cfx_getCollateralForStorage cfx_getInterestRate cfx_getNextNonce cfx_getSponsorInfo cfx_getStakingBalance cfx_getStorageAt cfx_getStorageRoot When requests are made that act on the state of conflux, the epoch number parameter determines the height of the epoch. The following options are possible for the epoch number parameter: HEX String - an integer epoch number String \"earliest\" for the earliest epoch where the genesis block in String \"latest_mined\" - for the latest epoch where the latest mined block in String \"latest_state\" - for the latest epoch where the latest block with an executed state in Noticed that for performance optimization concern, the lasted mined epochs are not executed, so there is no state available in these epochs. For most of RPCs related to state query, the \"latest_state\" is recommended. Curl Examples Explained \u00b6 The curl options below might return a response where the node complains about the content type, this is because the --data option sets the content type to application/x-www-form-urlencoded . If your node does complain, manually set the header by placing -H \"Content-Type: application/json\" at the start of the call. The examples also include the URL/IP & port combination which must be the last argument given to curl e.x. http://localhost:12345 Example for cfx_getbestblockhash curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBestBlockHash\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:12345 Migrating from Ethereum JSON-RPC \u00b6 There is a correspondence between some JSON-RPCs from Ethereum and Conflux. Even though the details of JSON-RPC may defer from each other, the following mapping table could be helpful on migrating from Ethereum to Conflux: eth_gasPrice => cfx_gasPrice eth_blockNumber => cfx_epochNumber eth_getBalance => cfx_getBalance eth_getStorageAt => cfx_getStorageAt eth_getTransactionCount => cfx_getNextNonce eth_getCode => cfx_getCode eth_sendRawTransaction => cfx_sendRawTransaction eth_call => cfx_call eth_estimateGas => cfx_estimateGasAndCollateral eth_getBlockByHash => cfx_getBlockByHash eth_getBlockByNumber => cfx_getBlockByEpochNumber eth_getTransactionByHash => cfx_getTransactionByHash eth_getTransactionReceipt => cfx_getTransactionReceipt eth_getLogs => cfx_getLogs JSON-RPC methods \u00b6 cfx_getTransactionByHash \u00b6 Returns the information about a transaction requested by transaction hash. Parameters \u00b6 DATA, 32 Bytes - hash of a transaction params: [ '0x88df016429689c079f3b2f6ad39fa052532c56795b733da78a91ebe6a713944b', ] Returns \u00b6 Object - A transaction object, or null when no transaction was found: blockHash : DATA , 32 Bytes - hash of the block where this transaction was in and got executed. null when its pending. contractCreated : DATA , 20 Bytes - address of created contract. null when it's not a contract creating transaction. data : DATA - the data send along with the transaction. from : DATA , 20 Bytes - address of the sender. gas : QUANTITY - gas provided by the sender. gasPrice : QUANTITY - gas price provided by the sender in Drip. hash : DATA , 32 Bytes - hash of the transaction. nonce : QUANTITY - the number of transactions made by the sender prior to this one. r : DATA , 32 Bytes - ECDSA signature r s : DATA , 32 Bytes - ECDSA signature s status : QUANTITY - 0 for success, 1 for error occured, null when the transaction is skipped or not packed. to : DATA , 20 Bytes - address of the receiver. null when its a contract creation transaction. transactionIndex : QUANTITY - integer of the transaction's index position in the block. null when its pending. v : QUANTITY - ECDSA recovery id value : QUANTITY - value transferred in Drip. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionByHash\",\"params\":[\"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"blockHash\": \"0xbb1eea3c8a574dc19f7d8311a2096e23a39f12e649a20766544f2df67aac0bed\", \"contractCreated\": null, \"data\": \"0x\", \"from\": \"0xb2988210c05a43ebd76575f5421ef84b120ebf80\", \"gas\": \"0x5208\", \"gasPrice\": \"0x174876e800\", \"hash\": \"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\", \"nonce\": \"0x1\", \"r\": \"0x27e5cb110dd198b8fc963d4741ec0840400a6351d9e0c458eeda6af5e0a12760\", \"s\": \"0x2c486d8e26da3c867fbcf4ab242af1265a5036c5e23ea42c8ab23437ce4c0bca\", \"status\": \"0x0\", \"to\": \"0xb2988210c05a43ebd76575f5421ef84b120ebf80\", \"transactionIndex\": \"0x0\", \"v\": \"0x1\", \"value\": \"0x3635c9adc5dea00000\" }, \"id\": 1 } cfx_getBlockByHash \u00b6 Returns information about a block by hash. Parameters \u00b6 DATA , 32 Bytes - Hash of a block. Boolean - If true it returns the full transaction objects, if false only the hashes of the transactions. params: [ '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331', true ] Returns \u00b6 Object - A block object, or null when no block was found: adaptive : Boolean - If true the weight of the block is adaptive under GHAST rule, if false otherwise. blame : QUANTITY - If 0, then no blocks are blamed on its parent path, If greater than 0, then the nearest blamed block on the parent path is blame steps away. deferredLogsBloomHash : DATA , 32 Bytes - The bloom hash of deferred logs. deferredReceiptsRoot : DATA , 32 Bytes - the hash of the receipts of the block after deferred execution. deferredStateRoot : DATA , 32 Bytes - the root of the final state trie of the block after deferred execution. difficulty : QUANTITY - integer of the difficulty for this block. epochNumber : QUANTITY - the current block epoch number in the client's view. null when it's not in best block's past set and the epoch number is not determined. gasLimit : QUANTITY - the maximum gas allowed in this block. hash : DATA , 32 Bytes - hash of the block. null when its pending block. height : QUANTITY - the block heights. null when its pending block. miner : DATA , 20 Bytes - the address of the beneficiary to whom the mining rewards were given. nonce : DATA , 8 Bytes - hash of the generated proof-of-work. null when its pending block. parentHash : DATA , 32 Bytes - hash of the parent block. powQuality : , DATA , Bytes - hash of the generated proof-of-work. null when its pending block. refereeHashes : Array - Array of referee hashes. size : QUANTITY - integer the size of this block in bytes. timestamp : QUANTITY - the unix timestamp for when the block was collated. transactions : Array - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. transactionsRoot : DATA , 32 Bytes - the hash of the transactions of the block. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlockByHash\",\"params\":[\"0x692373025c7315fa18b2d02139d08e987cd7016025920f59ada4969c24e44e06\", false],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"adaptive\": false, \"blame\": 0, \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xd449df4ba49f5ab02abf261e976197beecf93c5198a6f0b6bd2713d84115c4ec\", \"difficulty\": \"0xeee440\", \"epochNumber\": \"0x1394cb\", \"gasLimit\": \"0xb2d05e00\", \"hash\": \"0x692373025c7315fa18b2d02139d08e987cd7016025920f59ada4969c24e44e06\", \"height\": \"0x1394c9\", \"miner\": \"0x000000000000000000000000000000000000000b\", \"nonce\": \"0x329243b1063c6773\", \"parentHash\": \"0xd1c2ff79834f86eb4bc98e0e526de475144a13719afba6385cf62a4023c02ae3\", \"powQuality\": \"0x2ab0c3513\", \"refereeHashes\": [ \"0xcc103077ede14825a5667bddad79482d7bbf1f1a658fed6894fa0e9287fc6be1\" ], \"size\": \"0x180\", \"timestamp\": \"0x5e8d32a1\", \"transactions\": [ \"0xedfa5b9c38ba51e791cc72b8f75ff758533c8c38f426eddee3fd95d984dd59ff\" ], \"transactionsRoot\": \"0xfb245dae4539ea49812e822adbffa9dd2ee9b3de8f3d9a7d186d351dcc9a6ed4\" }, \"id\": 1 } cfx_getBlockByEpochNumber \u00b6 Returns information about a block by epoch number. Parameters \u00b6 QUANTITY|TAG - the epoch number, or the string \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter . Boolean - If true it returns the full transaction objects, if false only the hashes of the transactions. params: [ 'latest_mined', true ] Returns \u00b6 See cfx_getBlockByHash . Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlockByEpochNumber\",\"params\":[\"latest_mined\", false],\"id\":1}' Result see cfx_getBlockByHash . cfx_getBestBlockHash \u00b6 Returns the hash of best block. Parameters \u00b6 none Returns \u00b6 DATA , 32 Bytes - hash of the best block. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBestBlockHash\",\"params\":[],\"id\":1}' // Result { \"result\" : \"0x7d54c03f4fe971d5c45d95dddc770a0ec8d5bd27d57c049ce8adc469269e35a4\", \"id\" : 1, \"jsonrpc\" : \"2.0\" } cfx_epochNumber \u00b6 Returns the epoch number of given parameter. Parameters \u00b6 TAG - (optional, default: \"latest_mined\") String \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter . Returns \u00b6 QUANTITY - integer of the current epoch number of given parameter. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_epochNumber\",\"params\":[],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"id\" : 1, \"result\" : \"0x49\" } cfx_gasPrice \u00b6 Returns the current price per gas in Drip. Parameters \u00b6 none Returns \u00b6 QUANTITY - integer of the current gas price in Drip. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_gasPrice\",\"params\":[],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"id\" : 1, \"result\" : \"0x09184e72a000\" } cfx_getBlocksByEpoch \u00b6 Returns hashes of blocks located in some epoch. Parameters \u00b6 QUANTITY|TAG - the epoch number, or the string \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter . Returns \u00b6 Array - Array of block hashes, sorted by execution(topological) order. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlocksByEpoch\",\"params\":[\"0x11\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": [ \"0x618e813ed93f1020bab13a1ab77e1550da6c89d9c69de837033512e91ac46bd0\", \"0x0f6ac81dcbc612e72e0019681bcec32254a34bd29a6bbab91e5e8dc37ecb64d5\", \"0xad3238c00456adfbf847d251b004c1e306fe637227bb1b9917d77bd5b207af68\", \"0x0f92c2e796be7b016d8b74c6c270fb1851e47fabaca3e464d407544286d6cd34\", \"0x5bcc2b8d2493797fcadf7b80228ef5b713eb9ff65f7cdd86562db629d0caf721\", \"0x7fcdc6fff506b19a2bd72cd3430310915f19a59b046759bb790ba4eeb95e9956\", \"0xf4f33ed08e1c625f4dde608eeb92991d77fff26122bab28a6b3a2037511dcc83\", \"0xa3762adc7f066d5cb62c683c2655be3bc3405ff1397f77d2e1dbeff2d8522e00\", \"0xba7588476a5ec7e0ade00f060180cadb7430fd1be48940414baac48c0d39556d\", \"0xe4dc4541d07118b598b2ec67bbdaa219eb1d649471fe7b5667a0001d83b1e9b6\", \"0x93a15564544c57d6cb68dbdf60133b318a94439e1f0a9ccb331b0f5a0aaf8049\" ], \"id\": 1 } cfx_getBalance \u00b6 Returns the balance of the account of given address. Parameters \u00b6 DATA , 20 Bytes - address to check for balance. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ] Returns \u00b6 QUANTITY - integer of the current balance in Drip. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBalance\",\"params\":[\"0xc94770007dda54cF92009BFF0dE90c06F603a09f\", \"latest_state\"],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 } cfx_getStakingBalance \u00b6 Returns the balance of the staking account of given address. Parameters \u00b6 DATA , 20 Bytes - address to check for staking balance. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ] Returns \u00b6 QUANTITY - integer of the current staking balance in Drip. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getStakingBalance\",\"params\":[\"0xc94770007dda54cF92009BFF0dE90c06F603a09f\", \"latest_state\"],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 } cfx_getCollateralForStorage \u00b6 Returns the size of the collateral storage of given address, in Byte. Parameters \u00b6 DATA , 20 Bytes - address to check for collateral storage. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ] Returns \u00b6 QUANTITY - integer of the collateral storage in Byte. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getCollateralForStorage\",\"params\":[\"0xc94770007dda54cF92009BFF0dE90c06F603a09f\", \"latest_state\"],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x0234c8a8\" } cfx_getAdmin \u00b6 Returns the admin of given contract. Parameters \u00b6 DATA , 20 Bytes - address to contract. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', 'latest_state' ] Returns \u00b6 DATA - 20 Bytes - address to admin, or 0x0000000000000000000000000000000000000000 if the contract does not exist. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getAdmin\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x144aa8f554d2ffbc81e0aa0f533f76f5220db09c\", \"id\": 1 } cfx_getCode \u00b6 Returns the code of given contract. Parameters \u00b6 DATA , 20 Bytes - address to contract. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', 'latest_state' ] Returns \u00b6 DATA - byte code of contract, or 0x if the contract does not exist. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getCode\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\",\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x\", \"id\": 1 } cfx_getStorageAt \u00b6 Returns storage entries from a given contract. Parameters \u00b6 DATA , 20 Bytes - address to contract. DATA , 32 Bytes - the given position. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', '0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9', 'latest_state' ] Returns \u00b6 DATA - 32 Bytes - storage entry of given query, or null if the it does not exist. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getStorageAt\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\",\"0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9\",\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x000000000000000000000000000000000000000000000000000000000000162e\", \"id\": 1 } cfx_getStorageRoot \u00b6 Returns the storage root of a given contract. Parameters \u00b6 DATA , 20 Bytes - address to contract. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', 'latest_state' ] Returns \u00b6 Object - A storage root object, or null if the contract does not exist: delta : DATA , 32 Bytes - storage root in the delta trie. intermediate : DATA , 32 Bytes - storage root in the intermediate trie. snapshot : DATA , 32 Bytes - storage root in the snapshot. If all three of these fields match for two invocations of this RPC, the contract's storage is guaranteed to be identical. If they do not match, storage has likely changed (or the system transitioned into a new era). Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getStorageRoot\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\",\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"delta\": \"0x0240a5a3486ac1cee71db22b8e12f1bb6ac9f207ecd81b06031c407663c20a94\", \"intermediate\": \"0x314a41f277b678a1dc811a1fc0393b6d30c35e900cb27762ec9e9042bfdbdd49\", \"snapshot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"id\" :1 } cfx_getSponsorInfo \u00b6 Returns the sponsor info of given contract. Parameters \u00b6 DATA , 20 Bytes - address to contract. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', 'latest_state' ] Returns \u00b6 Object - A sponsor info object, if the contract doesn't have a sponsor, then the all fields in returned object will be 0 : sponsorBalanceForCollateral : QUANTITY - the sponsored balance for storage. sponsorBalanceForGas : QUANTITY - the sponsored balance for gas. sponsorGasBound : QUANTITY - the max gas could be sponsored for one transaction. sponsorForCollateral : DATA , 20 Bytes - the address of the storage sponsor. sponsorForGas : DATA , 20 Bytes - the address of the gas sponsor. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getSponsorInfo\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"sponsorBalanceForCollateral\": \"0x0\", \"sponsorBalanceForGas\": \"0x0\", \"sponsorForCollateral\": \"0x0000000000000000000000000000000000000000\", \"sponsorForGas\": \"0x0000000000000000000000000000000000000000\", \"sponsorGasBound\": \"0x0\" }, \"id\": 1 } cfx_getNextNonce \u00b6 Returns the next nonce should be used by given address. Parameters \u00b6 DATA , 20 Bytes - address. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8', 'latest_state' // state at the latest executed epoch ] Returns \u00b6 QUANTITY - integer of the next nonce should be used by given address. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getNextNonce\",\"params\":[\"0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8\", 'latest_state'],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"result\" : \"0x1\", \"id\" : 1 } cfx_sendRawTransaction \u00b6 Creates new message call transaction or a contract creation for signed transactions. Parameters \u00b6 DATA , The signed transaction data. params: [ '0xf86eea8201a28207d0830f4240943838197c0c88d0d5b13b67e1bfdbdc132d4842e389056bc75e2d631000008080a017b8b26f473820475edc49bd153660e56b973b5985bbdb2828fceacb4c91f389a03452f9a69da34ef35acc9c554d7b1d63e9041141674b42c3abb1b57b9f83a2d3' ] Returns \u00b6 DATA , 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_sendRawTransaction\",\"params\":[{see above}],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0xf5338a6cb85d10acc9108869f94fe322b2dfa2715d16d264676c91f6a0404b61\" } cfx_call \u00b6 Virtually call a contract, return the output data. Parameters \u00b6 Object - A call request object: from : DATA , 20 Bytes - (optional, default: random address) address of sender. to : DATA , 20 Bytes - (optional, default: null for contract creation) address of receiver. gasPrice : QUANTITY - (optional, default: 0 ) gas price provided by the sender in Drip. gas : QUANTITY - (optional, default: 500000000 ) gas provided by the sender. value : QUANTITY - (optional, default: 0 ) value transferred in Drip. data : DATA - (optional, default: 0x ) the data send along with the transaction. nonce : QUANTITY - (optional, default: 0 ) the number of transactions made by the sender prior to this one. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ { \"from\":\"0xf6B7219AF657e14B5103e915839dD12f51cDBA68\", \"to\":\"0x63428378C5D7d168c9Ef2809a76812d40E018Ac9\", \"data\":\"0x\", \"gasPrice\":\"0x2540be400\", \"nonce\": \"0x0\" }, 'latest_state' // state at the latest executed epoch ] Returns \u00b6 DATA , Bytes - the output data. Example \u00b6 // Request curl -X POST --data '{\"method\":\"cfx_call\",\"id\":1,\"jsonrpc\":\"2.0\",\"params\":[{\"from\":\"0xf6B7219AF657e14B5103e915839dD12f51cDBA68\",\"to\":\"0x63428378C5D7d168c9Ef2809a76812d40E018Ac9\",\"data\":\"0x\",\"gasPrice\":\"0x2540be400\", \"nonce\": \"0x0\"}]}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x\", \"id\": 1 } cfx_estimateGasAndCollateral \u00b6 Virtually call a contract, return the output data. Parameters \u00b6 See cfx_call . params: [ { \"from\":\"0xf6B7219AF657e14B5103e915839dD12f51cDBA68\", \"to\":\"0x63428378C5D7d168c9Ef2809a76812d40E018Ac9\", \"data\":\"0x\", \"gasPrice\":\"0x2540be400\", \"nonce\": \"0x0\" }, 'latest_state' // state at the latest executed epoch ] Returns \u00b6 Object - A estimate result object: * gasUsed : QUANTITY - gas used after execution. * storageCollateralized : QUANTITY - stroage collateralized, in Byte. Example \u00b6 // Request curl -X POST --data '{\"method\":\"cfx_estimateGasAndCollateral\",\"id\":1,\"jsonrpc\":\"2.0\",\"params\":[{\"from\":\"0xf6B7219AF657e14B5103e915839dD12f51cDBA68\",\"to\":\"0x63428378C5D7d168c9Ef2809a76812d40E018Ac9\",\"data\":\"0x\",\"gasPrice\":\"0x2540be400\", \"nonce\": \"0x0\"}]}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"gasUsed\": \"0x5208\", \"storageCollateralized\": \"0x0\" }, \"id\": 1 } cfx_getLogs \u00b6 Returns logs matching the filter provided. Parameters \u00b6 Object - A log filter object: fromEpoch : QUANTITY - (optional, default: \"earliest\" ) search will be applied from this epoch number. toEpoch : QUANTITY - (optional, default: \"latest_mined\" ) till this epoch number. blockHashes : Array of DATA - (optional, default: null ) Array of block hashes that the search will be applied. This will override from/to epoch fields if it's not null . address : Array of DATA - (optional, default: null ) Search addresses, If null , match all. If specified, log must be produced by one of these addresses. topics : Array - (optional, default: null ) Search topics. Logs can have 4 topics: the function signature and up to 3 indexed event arguments. The elements of topics match the corresponding log topics. Example: [\"0xA\", null, [\"0xB\", \"0xC\"], null] matches logs with \"0xA\" as the 1st topic AND ( \"0xB\" OR \"0xC\" ) as the 3rd topic. If null , match all. limit : QUANTITY - (optional, default: null ) If null return all logs, otherwise should only return last limit logs. params: [ {} ] Returns \u00b6 Array - Array of Log Object , that the logs matching the filter provided: address : DATA , 20 Bytes - address of log. topics : Array of DATA - Array of topics. data : DATA - data of log. blockHash : DATA - 32 Bytes - hash of the block where the log in. epochNumber : QUANTITY - epoch number of the block where the log in. transactionHash : DATA , 32 Bytes - hash of the transaction where the log in. transactionIndex : QUANTITY - transaction index in the block. logIndex : QUANTITY - log index in block. transactionLogIndex : QUANTITY - log index in transaction. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getLogs\",\"params\":[{}],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": [ { \"address\": \"0x866aca87ff33a0ae05d2164b3d999a804f583222\", \"blockHash\": \"0x0ecbc75aca22cd1566a18c6a7a55f235ae12684c2749b40ac91262d6e8783b0b\", \"data\": \"0x\", \"epochNumber\": \"0x1504a7\", \"logIndex\": \"0x2\", \"topics\": [ \"0x93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db153\", \"0x000000000000000000000000873c4bd4d847bcf7dc066bf4a7cd31dcf182258c\", \"0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b\", \"0x000000000000000000000000873c4bd4d847bcf7dc066bf4a7cd31dcf182258c\" ], \"transactionHash\": \"0x2a696f7be50c364333bc145f082e79da3a6e730318b7f7822e3e1fe22e42560b\", \"transactionIndex\": \"0x0\", \"transactionLogIndex\": \"0x2\" }, { \"address\": \"0x873c4bd4d847bcf7dc066bf4a7cd31dcf182258c\", \"blockHash\": \"0x0ecbc75aca22cd1566a18c6a7a55f235ae12684c2749b40ac91262d6e8783b0b\", \"data\": \"0x\", \"epochNumber\": \"0x1504a7\", \"logIndex\": \"0x3\", \"topics\": [ \"0x0040d54d5e5b097202376b55bcbaaedd2ee468ce4496f1d30030c4e5308bf94d\", \"0x00000000000000000000000015cf2b2c91e6eff901f10ab7363ae58cf1bfccc5\" ], \"transactionHash\": \"0x2a696f7be50c364333bc145f082e79da3a6e730318b7f7822e3e1fe22e42560b\", \"transactionIndex\": \"0x0\", \"transactionLogIndex\": \"0x3\" } ], \"id\": 1 } cfx_getTransactionReceipt \u00b6 Returns the information about a transaction receipt requested by transaction hash. Parameters \u00b6 DATA, 32 Bytes - hash of a transaction params: [ '0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514', ] Returns \u00b6 Object - A transaction receipt object, or null when no transaction was found or the transaction was not executed yet: transactionHash : DATA , 32 Bytes - hash of the given transaction. index : QUANTITY - transaction index within the block. blockHash : DATA , 32 Bytes - hash of the block where this transaction was in and got executed. epochNumber : QUANTITY - epoch number of the block where this transaction was in and got executed. from : DATA , 20 Bytes - address of the sender. to : DATA , 20 Bytes - address of the receiver. null when its a contract creation transaction. gasUsed : QUANTITY - gas used the transaction. contractCreated : DATA , 20 Bytes - address of created contract. null when it's not a contract creating transaction. stateRoot : DATA , 32 Bytes - hash of the state root. outcomeStatus : QUANTITY - the outcome status code. logsBloom : DATA , 256 Bytes - bloom filter for light clients to quickly retrieve related logs. logs : Array - Array of log objects, which this transaction generated, see cfx_getLogs Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionReceipt\",\"params\":[\"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"blockHash\": \"0xbb1eea3c8a574dc19f7d8311a2096e23a39f12e649a20766544f2df67aac0bed\", \"contractCreated\": null, \"epochNumber\": 451990, \"from\": \"0xb2988210c05a43ebd76575f5421ef84b120ebf80\", \"gasUsed\": \"0x5208\", \"index\": 0, \"logs\": [], \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"outcomeStatus\": 0, \"stateRoot\": \"0x1bc37c63c03d7e7066f9427f69e515988d19ebb26998087d75b50d2235e55ee7\", \"to\": \"0xb2988210c05a43ebd76575f5421ef84b120ebf80\", \"transactionHash\": \"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\" }, \"id\": 1 } cfx_getAccount \u00b6 Return account related states of the given account Parameters \u00b6 DATA , 20 Bytes - address to get account. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ] Returns \u00b6 Object - states of the given account: balance : QUANTITY - the balance of the account. nonce : QUANTITY - the nonce of the account's next transaction. codeHash : QUANTITY - the code hash of the account. stakingBalance : QUANTITY - the staking balance of the account. collateralForStorage : QUANTITY - the collateral storage of the account. accumulatedInterestReturn : QUANTITY -accumulated unterest return of the account. admin : DATA`, 20 Bytes - admin of the account. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getAccount\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\", \"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"accumulatedInterestReturn\": \"0x0\", \"admin\": \"0x144aa8f554d2ffbc81e0aa0f533f76f5220db09c\", \"balance\": \"0x0\", \"codeHash\": \"0x45fed62dd2b7c5ed76a63628ddc811e69bb5770cf31dd55647ca219aaee5434f\", \"collateralForStorage\": \"0x0\", \"nonce\": \"0x1\", \"stakingBalance\": \"0x0\" }, \"id\": 1 } cfx_getInterestRate \u00b6 Returns the interest rate of given parameter. Parameters \u00b6 TAG - (optional, default: \"latest_mined\") String \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter . params: [ 'latest_state' ] Returns \u00b6 QUANTITY - the interest rate of given parameter. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getInterestRate\",\"params\":[\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x24b675dc000\", \"id\": 1 } cfx_getAccumulateInterestRate \u00b6 Returns the accumulate interest rate of given parameter. Parameters \u00b6 TAG - (optional, default: \"latest_mined\") String \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter . params: [ 'latest_state' ] Returns \u00b6 QUANTITY - the accumulate interest rate of given parameter. Example \u00b6 // Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getAccumulateInterestRate\",\"params\":[\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x3c35a9e557dc9ef76719db0226f\", \"id\": 1 }","title":"JSON-RPC API"},{"location":"json-rpc/#conflux-json-rpc-api","text":"The Conflux JSON-RPC API is a collection of interfaces which allow you to interact with a local or remote Conflux node, using an HTTP connection in JSON-RPC protocol. The following is an API reference documentation with examples.","title":"Conflux JSON-RPC API"},{"location":"json-rpc/#json-rpc","text":"JSON is a lightweight data-interchange format. It can represent numbers, strings, ordered sequences of values, and collections of name/value pairs. JSON-RPC is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over HTTP, or in many various message passing environments. It uses JSON (RFC 4627) as data format.","title":"JSON-RPC"},{"location":"json-rpc/#javascript-api","text":"There is also a JavaScript library js-conflux-sdk provided, for you to interact with a Conflux node from inside a JavaScript application, which gives a convenient interface for the RPC methods.","title":"JavaScript API"},{"location":"json-rpc/#json-rpc-endpoint-support","text":"Currently, Conflux has a Rust implementation that supports JSON-RPC 2.0 and HTTP.","title":"JSON-RPC endpoint &amp;&amp; support"},{"location":"json-rpc/#hex-value-encoding","text":"At present there are two key datatypes that are passed over JSON: unformatted byte arrays and quantities. Both are passed with a hex encoding, however with different requirements to formatting: When encoding QUANTITIES (integers, numbers): encode as hex, prefix with \"0x\", the most compact representation (slight exception: zero should be represented as \"0x0\"). Examples: 0x41 (65 in decimal) 0x400 (1024 in decimal) WRONG: 0x (should always have at least one digit - zero is \"0x0\") WRONG: 0x0400 (no leading zeroes allowed) WRONG: ff (must be prefixed 0x) When encoding UNFORMATTED DATA (byte arrays, account addresses, hashes, bytecode arrays): encode as hex, prefix with \"0x\", two hex digits per byte. Examples: 0x41 (size 1, \"A\") 0x004200 (size 3, \"\\0B\\0\") 0x (size 0, \"\") WRONG: 0xf0f0f (must be even number of digits) WRONG: 004200 (must be prefixed 0x)","title":"HEX value encoding"},{"location":"json-rpc/#the-epoch-number-parameter","text":"The following methods have an epoch number parameter: cfx_call cfx_epochNumber cfx_estimateGasAndCollateral cfx_getAccumulateInterestRate cfx_getAdmin cfx_getBalance cfx_getBlockByEpochNumber cfx_getBlocksByEpoch cfx_getCode cfx_getCollateralForStorage cfx_getInterestRate cfx_getNextNonce cfx_getSponsorInfo cfx_getStakingBalance cfx_getStorageAt cfx_getStorageRoot When requests are made that act on the state of conflux, the epoch number parameter determines the height of the epoch. The following options are possible for the epoch number parameter: HEX String - an integer epoch number String \"earliest\" for the earliest epoch where the genesis block in String \"latest_mined\" - for the latest epoch where the latest mined block in String \"latest_state\" - for the latest epoch where the latest block with an executed state in Noticed that for performance optimization concern, the lasted mined epochs are not executed, so there is no state available in these epochs. For most of RPCs related to state query, the \"latest_state\" is recommended.","title":"The epoch number parameter"},{"location":"json-rpc/#curl-examples-explained","text":"The curl options below might return a response where the node complains about the content type, this is because the --data option sets the content type to application/x-www-form-urlencoded . If your node does complain, manually set the header by placing -H \"Content-Type: application/json\" at the start of the call. The examples also include the URL/IP & port combination which must be the last argument given to curl e.x. http://localhost:12345 Example for cfx_getbestblockhash curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBestBlockHash\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:12345","title":"Curl Examples Explained"},{"location":"json-rpc/#migrating-from-ethereum-json-rpc","text":"There is a correspondence between some JSON-RPCs from Ethereum and Conflux. Even though the details of JSON-RPC may defer from each other, the following mapping table could be helpful on migrating from Ethereum to Conflux: eth_gasPrice => cfx_gasPrice eth_blockNumber => cfx_epochNumber eth_getBalance => cfx_getBalance eth_getStorageAt => cfx_getStorageAt eth_getTransactionCount => cfx_getNextNonce eth_getCode => cfx_getCode eth_sendRawTransaction => cfx_sendRawTransaction eth_call => cfx_call eth_estimateGas => cfx_estimateGasAndCollateral eth_getBlockByHash => cfx_getBlockByHash eth_getBlockByNumber => cfx_getBlockByEpochNumber eth_getTransactionByHash => cfx_getTransactionByHash eth_getTransactionReceipt => cfx_getTransactionReceipt eth_getLogs => cfx_getLogs","title":"Migrating from Ethereum JSON-RPC"},{"location":"json-rpc/#json-rpc-methods","text":"","title":"JSON-RPC methods"},{"location":"json-rpc/#cfx_gettransactionbyhash","text":"Returns the information about a transaction requested by transaction hash.","title":"cfx_getTransactionByHash"},{"location":"json-rpc/#parameters","text":"DATA, 32 Bytes - hash of a transaction params: [ '0x88df016429689c079f3b2f6ad39fa052532c56795b733da78a91ebe6a713944b', ]","title":"Parameters"},{"location":"json-rpc/#returns","text":"Object - A transaction object, or null when no transaction was found: blockHash : DATA , 32 Bytes - hash of the block where this transaction was in and got executed. null when its pending. contractCreated : DATA , 20 Bytes - address of created contract. null when it's not a contract creating transaction. data : DATA - the data send along with the transaction. from : DATA , 20 Bytes - address of the sender. gas : QUANTITY - gas provided by the sender. gasPrice : QUANTITY - gas price provided by the sender in Drip. hash : DATA , 32 Bytes - hash of the transaction. nonce : QUANTITY - the number of transactions made by the sender prior to this one. r : DATA , 32 Bytes - ECDSA signature r s : DATA , 32 Bytes - ECDSA signature s status : QUANTITY - 0 for success, 1 for error occured, null when the transaction is skipped or not packed. to : DATA , 20 Bytes - address of the receiver. null when its a contract creation transaction. transactionIndex : QUANTITY - integer of the transaction's index position in the block. null when its pending. v : QUANTITY - ECDSA recovery id value : QUANTITY - value transferred in Drip.","title":"Returns"},{"location":"json-rpc/#example","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionByHash\",\"params\":[\"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"blockHash\": \"0xbb1eea3c8a574dc19f7d8311a2096e23a39f12e649a20766544f2df67aac0bed\", \"contractCreated\": null, \"data\": \"0x\", \"from\": \"0xb2988210c05a43ebd76575f5421ef84b120ebf80\", \"gas\": \"0x5208\", \"gasPrice\": \"0x174876e800\", \"hash\": \"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\", \"nonce\": \"0x1\", \"r\": \"0x27e5cb110dd198b8fc963d4741ec0840400a6351d9e0c458eeda6af5e0a12760\", \"s\": \"0x2c486d8e26da3c867fbcf4ab242af1265a5036c5e23ea42c8ab23437ce4c0bca\", \"status\": \"0x0\", \"to\": \"0xb2988210c05a43ebd76575f5421ef84b120ebf80\", \"transactionIndex\": \"0x0\", \"v\": \"0x1\", \"value\": \"0x3635c9adc5dea00000\" }, \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getblockbyhash","text":"Returns information about a block by hash.","title":"cfx_getBlockByHash"},{"location":"json-rpc/#parameters_1","text":"DATA , 32 Bytes - Hash of a block. Boolean - If true it returns the full transaction objects, if false only the hashes of the transactions. params: [ '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331', true ]","title":"Parameters"},{"location":"json-rpc/#returns_1","text":"Object - A block object, or null when no block was found: adaptive : Boolean - If true the weight of the block is adaptive under GHAST rule, if false otherwise. blame : QUANTITY - If 0, then no blocks are blamed on its parent path, If greater than 0, then the nearest blamed block on the parent path is blame steps away. deferredLogsBloomHash : DATA , 32 Bytes - The bloom hash of deferred logs. deferredReceiptsRoot : DATA , 32 Bytes - the hash of the receipts of the block after deferred execution. deferredStateRoot : DATA , 32 Bytes - the root of the final state trie of the block after deferred execution. difficulty : QUANTITY - integer of the difficulty for this block. epochNumber : QUANTITY - the current block epoch number in the client's view. null when it's not in best block's past set and the epoch number is not determined. gasLimit : QUANTITY - the maximum gas allowed in this block. hash : DATA , 32 Bytes - hash of the block. null when its pending block. height : QUANTITY - the block heights. null when its pending block. miner : DATA , 20 Bytes - the address of the beneficiary to whom the mining rewards were given. nonce : DATA , 8 Bytes - hash of the generated proof-of-work. null when its pending block. parentHash : DATA , 32 Bytes - hash of the parent block. powQuality : , DATA , Bytes - hash of the generated proof-of-work. null when its pending block. refereeHashes : Array - Array of referee hashes. size : QUANTITY - integer the size of this block in bytes. timestamp : QUANTITY - the unix timestamp for when the block was collated. transactions : Array - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. transactionsRoot : DATA , 32 Bytes - the hash of the transactions of the block.","title":"Returns"},{"location":"json-rpc/#example_1","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlockByHash\",\"params\":[\"0x692373025c7315fa18b2d02139d08e987cd7016025920f59ada4969c24e44e06\", false],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"adaptive\": false, \"blame\": 0, \"deferredLogsBloomHash\": \"0xd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5\", \"deferredReceiptsRoot\": \"0x522717233b96e0a03d85f02f8127aa0e23ef2e0865c95bb7ac577ee3754875e4\", \"deferredStateRoot\": \"0xd449df4ba49f5ab02abf261e976197beecf93c5198a6f0b6bd2713d84115c4ec\", \"difficulty\": \"0xeee440\", \"epochNumber\": \"0x1394cb\", \"gasLimit\": \"0xb2d05e00\", \"hash\": \"0x692373025c7315fa18b2d02139d08e987cd7016025920f59ada4969c24e44e06\", \"height\": \"0x1394c9\", \"miner\": \"0x000000000000000000000000000000000000000b\", \"nonce\": \"0x329243b1063c6773\", \"parentHash\": \"0xd1c2ff79834f86eb4bc98e0e526de475144a13719afba6385cf62a4023c02ae3\", \"powQuality\": \"0x2ab0c3513\", \"refereeHashes\": [ \"0xcc103077ede14825a5667bddad79482d7bbf1f1a658fed6894fa0e9287fc6be1\" ], \"size\": \"0x180\", \"timestamp\": \"0x5e8d32a1\", \"transactions\": [ \"0xedfa5b9c38ba51e791cc72b8f75ff758533c8c38f426eddee3fd95d984dd59ff\" ], \"transactionsRoot\": \"0xfb245dae4539ea49812e822adbffa9dd2ee9b3de8f3d9a7d186d351dcc9a6ed4\" }, \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getblockbyepochnumber","text":"Returns information about a block by epoch number.","title":"cfx_getBlockByEpochNumber"},{"location":"json-rpc/#parameters_2","text":"QUANTITY|TAG - the epoch number, or the string \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter . Boolean - If true it returns the full transaction objects, if false only the hashes of the transactions. params: [ 'latest_mined', true ]","title":"Parameters"},{"location":"json-rpc/#returns_2","text":"See cfx_getBlockByHash .","title":"Returns"},{"location":"json-rpc/#example_2","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlockByEpochNumber\",\"params\":[\"latest_mined\", false],\"id\":1}' Result see cfx_getBlockByHash .","title":"Example"},{"location":"json-rpc/#cfx_getbestblockhash","text":"Returns the hash of best block.","title":"cfx_getBestBlockHash"},{"location":"json-rpc/#parameters_3","text":"none","title":"Parameters"},{"location":"json-rpc/#returns_3","text":"DATA , 32 Bytes - hash of the best block.","title":"Returns"},{"location":"json-rpc/#example_3","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBestBlockHash\",\"params\":[],\"id\":1}' // Result { \"result\" : \"0x7d54c03f4fe971d5c45d95dddc770a0ec8d5bd27d57c049ce8adc469269e35a4\", \"id\" : 1, \"jsonrpc\" : \"2.0\" }","title":"Example"},{"location":"json-rpc/#cfx_epochnumber","text":"Returns the epoch number of given parameter.","title":"cfx_epochNumber"},{"location":"json-rpc/#parameters_4","text":"TAG - (optional, default: \"latest_mined\") String \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter .","title":"Parameters"},{"location":"json-rpc/#returns_4","text":"QUANTITY - integer of the current epoch number of given parameter.","title":"Returns"},{"location":"json-rpc/#example_4","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_epochNumber\",\"params\":[],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"id\" : 1, \"result\" : \"0x49\" }","title":"Example"},{"location":"json-rpc/#cfx_gasprice","text":"Returns the current price per gas in Drip.","title":"cfx_gasPrice"},{"location":"json-rpc/#parameters_5","text":"none","title":"Parameters"},{"location":"json-rpc/#returns_5","text":"QUANTITY - integer of the current gas price in Drip.","title":"Returns"},{"location":"json-rpc/#example_5","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_gasPrice\",\"params\":[],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"id\" : 1, \"result\" : \"0x09184e72a000\" }","title":"Example"},{"location":"json-rpc/#cfx_getblocksbyepoch","text":"Returns hashes of blocks located in some epoch.","title":"cfx_getBlocksByEpoch"},{"location":"json-rpc/#parameters_6","text":"QUANTITY|TAG - the epoch number, or the string \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter .","title":"Parameters"},{"location":"json-rpc/#returns_6","text":"Array - Array of block hashes, sorted by execution(topological) order.","title":"Returns"},{"location":"json-rpc/#example_6","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBlocksByEpoch\",\"params\":[\"0x11\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": [ \"0x618e813ed93f1020bab13a1ab77e1550da6c89d9c69de837033512e91ac46bd0\", \"0x0f6ac81dcbc612e72e0019681bcec32254a34bd29a6bbab91e5e8dc37ecb64d5\", \"0xad3238c00456adfbf847d251b004c1e306fe637227bb1b9917d77bd5b207af68\", \"0x0f92c2e796be7b016d8b74c6c270fb1851e47fabaca3e464d407544286d6cd34\", \"0x5bcc2b8d2493797fcadf7b80228ef5b713eb9ff65f7cdd86562db629d0caf721\", \"0x7fcdc6fff506b19a2bd72cd3430310915f19a59b046759bb790ba4eeb95e9956\", \"0xf4f33ed08e1c625f4dde608eeb92991d77fff26122bab28a6b3a2037511dcc83\", \"0xa3762adc7f066d5cb62c683c2655be3bc3405ff1397f77d2e1dbeff2d8522e00\", \"0xba7588476a5ec7e0ade00f060180cadb7430fd1be48940414baac48c0d39556d\", \"0xe4dc4541d07118b598b2ec67bbdaa219eb1d649471fe7b5667a0001d83b1e9b6\", \"0x93a15564544c57d6cb68dbdf60133b318a94439e1f0a9ccb331b0f5a0aaf8049\" ], \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getbalance","text":"Returns the balance of the account of given address.","title":"cfx_getBalance"},{"location":"json-rpc/#parameters_7","text":"DATA , 20 Bytes - address to check for balance. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_7","text":"QUANTITY - integer of the current balance in Drip.","title":"Returns"},{"location":"json-rpc/#example_7","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBalance\",\"params\":[\"0xc94770007dda54cF92009BFF0dE90c06F603a09f\", \"latest_state\"],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 }","title":"Example"},{"location":"json-rpc/#cfx_getstakingbalance","text":"Returns the balance of the staking account of given address.","title":"cfx_getStakingBalance"},{"location":"json-rpc/#parameters_8","text":"DATA , 20 Bytes - address to check for staking balance. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_8","text":"QUANTITY - integer of the current staking balance in Drip.","title":"Returns"},{"location":"json-rpc/#example_8","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getStakingBalance\",\"params\":[\"0xc94770007dda54cF92009BFF0dE90c06F603a09f\", \"latest_state\"],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 }","title":"Example"},{"location":"json-rpc/#cfx_getcollateralforstorage","text":"Returns the size of the collateral storage of given address, in Byte.","title":"cfx_getCollateralForStorage"},{"location":"json-rpc/#parameters_9","text":"DATA , 20 Bytes - address to check for collateral storage. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_9","text":"QUANTITY - integer of the collateral storage in Byte.","title":"Returns"},{"location":"json-rpc/#example_9","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getCollateralForStorage\",\"params\":[\"0xc94770007dda54cF92009BFF0dE90c06F603a09f\", \"latest_state\"],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x0234c8a8\" }","title":"Example"},{"location":"json-rpc/#cfx_getadmin","text":"Returns the admin of given contract.","title":"cfx_getAdmin"},{"location":"json-rpc/#parameters_10","text":"DATA , 20 Bytes - address to contract. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_10","text":"DATA - 20 Bytes - address to admin, or 0x0000000000000000000000000000000000000000 if the contract does not exist.","title":"Returns"},{"location":"json-rpc/#example_10","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getAdmin\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x144aa8f554d2ffbc81e0aa0f533f76f5220db09c\", \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getcode","text":"Returns the code of given contract.","title":"cfx_getCode"},{"location":"json-rpc/#parameters_11","text":"DATA , 20 Bytes - address to contract. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_11","text":"DATA - byte code of contract, or 0x if the contract does not exist.","title":"Returns"},{"location":"json-rpc/#example_11","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getCode\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\",\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x\", \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getstorageat","text":"Returns storage entries from a given contract.","title":"cfx_getStorageAt"},{"location":"json-rpc/#parameters_12","text":"DATA , 20 Bytes - address to contract. DATA , 32 Bytes - the given position. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', '0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_12","text":"DATA - 32 Bytes - storage entry of given query, or null if the it does not exist.","title":"Returns"},{"location":"json-rpc/#example_12","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getStorageAt\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\",\"0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9\",\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x000000000000000000000000000000000000000000000000000000000000162e\", \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getstorageroot","text":"Returns the storage root of a given contract.","title":"cfx_getStorageRoot"},{"location":"json-rpc/#parameters_13","text":"DATA , 20 Bytes - address to contract. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_13","text":"Object - A storage root object, or null if the contract does not exist: delta : DATA , 32 Bytes - storage root in the delta trie. intermediate : DATA , 32 Bytes - storage root in the intermediate trie. snapshot : DATA , 32 Bytes - storage root in the snapshot. If all three of these fields match for two invocations of this RPC, the contract's storage is guaranteed to be identical. If they do not match, storage has likely changed (or the system transitioned into a new era).","title":"Returns"},{"location":"json-rpc/#example_13","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getStorageRoot\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\",\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"delta\": \"0x0240a5a3486ac1cee71db22b8e12f1bb6ac9f207ecd81b06031c407663c20a94\", \"intermediate\": \"0x314a41f277b678a1dc811a1fc0393b6d30c35e900cb27762ec9e9042bfdbdd49\", \"snapshot\": \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" }, \"id\" :1 }","title":"Example"},{"location":"json-rpc/#cfx_getsponsorinfo","text":"Returns the sponsor info of given contract.","title":"cfx_getSponsorInfo"},{"location":"json-rpc/#parameters_14","text":"DATA , 20 Bytes - address to contract. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_14","text":"Object - A sponsor info object, if the contract doesn't have a sponsor, then the all fields in returned object will be 0 : sponsorBalanceForCollateral : QUANTITY - the sponsored balance for storage. sponsorBalanceForGas : QUANTITY - the sponsored balance for gas. sponsorGasBound : QUANTITY - the max gas could be sponsored for one transaction. sponsorForCollateral : DATA , 20 Bytes - the address of the storage sponsor. sponsorForGas : DATA , 20 Bytes - the address of the gas sponsor.","title":"Returns"},{"location":"json-rpc/#example_14","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getSponsorInfo\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"sponsorBalanceForCollateral\": \"0x0\", \"sponsorBalanceForGas\": \"0x0\", \"sponsorForCollateral\": \"0x0000000000000000000000000000000000000000\", \"sponsorForGas\": \"0x0000000000000000000000000000000000000000\", \"sponsorGasBound\": \"0x0\" }, \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getnextnonce","text":"Returns the next nonce should be used by given address.","title":"cfx_getNextNonce"},{"location":"json-rpc/#parameters_15","text":"DATA , 20 Bytes - address. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8', 'latest_state' // state at the latest executed epoch ]","title":"Parameters"},{"location":"json-rpc/#returns_15","text":"QUANTITY - integer of the next nonce should be used by given address.","title":"Returns"},{"location":"json-rpc/#example_15","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getNextNonce\",\"params\":[\"0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8\", 'latest_state'],\"id\":1}' // Result { \"jsonrpc\" : \"2.0\", \"result\" : \"0x1\", \"id\" : 1 }","title":"Example"},{"location":"json-rpc/#cfx_sendrawtransaction","text":"Creates new message call transaction or a contract creation for signed transactions.","title":"cfx_sendRawTransaction"},{"location":"json-rpc/#parameters_16","text":"DATA , The signed transaction data. params: [ '0xf86eea8201a28207d0830f4240943838197c0c88d0d5b13b67e1bfdbdc132d4842e389056bc75e2d631000008080a017b8b26f473820475edc49bd153660e56b973b5985bbdb2828fceacb4c91f389a03452f9a69da34ef35acc9c554d7b1d63e9041141674b42c3abb1b57b9f83a2d3' ]","title":"Parameters"},{"location":"json-rpc/#returns_16","text":"DATA , 32 Bytes - the transaction hash, or the zero hash if the transaction is not yet available.","title":"Returns"},{"location":"json-rpc/#example_16","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_sendRawTransaction\",\"params\":[{see above}],\"id\":1}' // Result { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0xf5338a6cb85d10acc9108869f94fe322b2dfa2715d16d264676c91f6a0404b61\" }","title":"Example"},{"location":"json-rpc/#cfx_call","text":"Virtually call a contract, return the output data.","title":"cfx_call"},{"location":"json-rpc/#parameters_17","text":"Object - A call request object: from : DATA , 20 Bytes - (optional, default: random address) address of sender. to : DATA , 20 Bytes - (optional, default: null for contract creation) address of receiver. gasPrice : QUANTITY - (optional, default: 0 ) gas price provided by the sender in Drip. gas : QUANTITY - (optional, default: 500000000 ) gas provided by the sender. value : QUANTITY - (optional, default: 0 ) value transferred in Drip. data : DATA - (optional, default: 0x ) the data send along with the transaction. nonce : QUANTITY - (optional, default: 0 ) the number of transactions made by the sender prior to this one. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ { \"from\":\"0xf6B7219AF657e14B5103e915839dD12f51cDBA68\", \"to\":\"0x63428378C5D7d168c9Ef2809a76812d40E018Ac9\", \"data\":\"0x\", \"gasPrice\":\"0x2540be400\", \"nonce\": \"0x0\" }, 'latest_state' // state at the latest executed epoch ]","title":"Parameters"},{"location":"json-rpc/#returns_17","text":"DATA , Bytes - the output data.","title":"Returns"},{"location":"json-rpc/#example_17","text":"// Request curl -X POST --data '{\"method\":\"cfx_call\",\"id\":1,\"jsonrpc\":\"2.0\",\"params\":[{\"from\":\"0xf6B7219AF657e14B5103e915839dD12f51cDBA68\",\"to\":\"0x63428378C5D7d168c9Ef2809a76812d40E018Ac9\",\"data\":\"0x\",\"gasPrice\":\"0x2540be400\", \"nonce\": \"0x0\"}]}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x\", \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_estimategasandcollateral","text":"Virtually call a contract, return the output data.","title":"cfx_estimateGasAndCollateral"},{"location":"json-rpc/#parameters_18","text":"See cfx_call . params: [ { \"from\":\"0xf6B7219AF657e14B5103e915839dD12f51cDBA68\", \"to\":\"0x63428378C5D7d168c9Ef2809a76812d40E018Ac9\", \"data\":\"0x\", \"gasPrice\":\"0x2540be400\", \"nonce\": \"0x0\" }, 'latest_state' // state at the latest executed epoch ]","title":"Parameters"},{"location":"json-rpc/#returns_18","text":"Object - A estimate result object: * gasUsed : QUANTITY - gas used after execution. * storageCollateralized : QUANTITY - stroage collateralized, in Byte.","title":"Returns"},{"location":"json-rpc/#example_18","text":"// Request curl -X POST --data '{\"method\":\"cfx_estimateGasAndCollateral\",\"id\":1,\"jsonrpc\":\"2.0\",\"params\":[{\"from\":\"0xf6B7219AF657e14B5103e915839dD12f51cDBA68\",\"to\":\"0x63428378C5D7d168c9Ef2809a76812d40E018Ac9\",\"data\":\"0x\",\"gasPrice\":\"0x2540be400\", \"nonce\": \"0x0\"}]}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"gasUsed\": \"0x5208\", \"storageCollateralized\": \"0x0\" }, \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getlogs","text":"Returns logs matching the filter provided.","title":"cfx_getLogs"},{"location":"json-rpc/#parameters_19","text":"Object - A log filter object: fromEpoch : QUANTITY - (optional, default: \"earliest\" ) search will be applied from this epoch number. toEpoch : QUANTITY - (optional, default: \"latest_mined\" ) till this epoch number. blockHashes : Array of DATA - (optional, default: null ) Array of block hashes that the search will be applied. This will override from/to epoch fields if it's not null . address : Array of DATA - (optional, default: null ) Search addresses, If null , match all. If specified, log must be produced by one of these addresses. topics : Array - (optional, default: null ) Search topics. Logs can have 4 topics: the function signature and up to 3 indexed event arguments. The elements of topics match the corresponding log topics. Example: [\"0xA\", null, [\"0xB\", \"0xC\"], null] matches logs with \"0xA\" as the 1st topic AND ( \"0xB\" OR \"0xC\" ) as the 3rd topic. If null , match all. limit : QUANTITY - (optional, default: null ) If null return all logs, otherwise should only return last limit logs. params: [ {} ]","title":"Parameters"},{"location":"json-rpc/#returns_19","text":"Array - Array of Log Object , that the logs matching the filter provided: address : DATA , 20 Bytes - address of log. topics : Array of DATA - Array of topics. data : DATA - data of log. blockHash : DATA - 32 Bytes - hash of the block where the log in. epochNumber : QUANTITY - epoch number of the block where the log in. transactionHash : DATA , 32 Bytes - hash of the transaction where the log in. transactionIndex : QUANTITY - transaction index in the block. logIndex : QUANTITY - log index in block. transactionLogIndex : QUANTITY - log index in transaction.","title":"Returns"},{"location":"json-rpc/#example_19","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getLogs\",\"params\":[{}],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": [ { \"address\": \"0x866aca87ff33a0ae05d2164b3d999a804f583222\", \"blockHash\": \"0x0ecbc75aca22cd1566a18c6a7a55f235ae12684c2749b40ac91262d6e8783b0b\", \"data\": \"0x\", \"epochNumber\": \"0x1504a7\", \"logIndex\": \"0x2\", \"topics\": [ \"0x93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db153\", \"0x000000000000000000000000873c4bd4d847bcf7dc066bf4a7cd31dcf182258c\", \"0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b\", \"0x000000000000000000000000873c4bd4d847bcf7dc066bf4a7cd31dcf182258c\" ], \"transactionHash\": \"0x2a696f7be50c364333bc145f082e79da3a6e730318b7f7822e3e1fe22e42560b\", \"transactionIndex\": \"0x0\", \"transactionLogIndex\": \"0x2\" }, { \"address\": \"0x873c4bd4d847bcf7dc066bf4a7cd31dcf182258c\", \"blockHash\": \"0x0ecbc75aca22cd1566a18c6a7a55f235ae12684c2749b40ac91262d6e8783b0b\", \"data\": \"0x\", \"epochNumber\": \"0x1504a7\", \"logIndex\": \"0x3\", \"topics\": [ \"0x0040d54d5e5b097202376b55bcbaaedd2ee468ce4496f1d30030c4e5308bf94d\", \"0x00000000000000000000000015cf2b2c91e6eff901f10ab7363ae58cf1bfccc5\" ], \"transactionHash\": \"0x2a696f7be50c364333bc145f082e79da3a6e730318b7f7822e3e1fe22e42560b\", \"transactionIndex\": \"0x0\", \"transactionLogIndex\": \"0x3\" } ], \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_gettransactionreceipt","text":"Returns the information about a transaction receipt requested by transaction hash.","title":"cfx_getTransactionReceipt"},{"location":"json-rpc/#parameters_20","text":"DATA, 32 Bytes - hash of a transaction params: [ '0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514', ]","title":"Parameters"},{"location":"json-rpc/#returns_20","text":"Object - A transaction receipt object, or null when no transaction was found or the transaction was not executed yet: transactionHash : DATA , 32 Bytes - hash of the given transaction. index : QUANTITY - transaction index within the block. blockHash : DATA , 32 Bytes - hash of the block where this transaction was in and got executed. epochNumber : QUANTITY - epoch number of the block where this transaction was in and got executed. from : DATA , 20 Bytes - address of the sender. to : DATA , 20 Bytes - address of the receiver. null when its a contract creation transaction. gasUsed : QUANTITY - gas used the transaction. contractCreated : DATA , 20 Bytes - address of created contract. null when it's not a contract creating transaction. stateRoot : DATA , 32 Bytes - hash of the state root. outcomeStatus : QUANTITY - the outcome status code. logsBloom : DATA , 256 Bytes - bloom filter for light clients to quickly retrieve related logs. logs : Array - Array of log objects, which this transaction generated, see cfx_getLogs","title":"Returns"},{"location":"json-rpc/#example_20","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionReceipt\",\"params\":[\"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"blockHash\": \"0xbb1eea3c8a574dc19f7d8311a2096e23a39f12e649a20766544f2df67aac0bed\", \"contractCreated\": null, \"epochNumber\": 451990, \"from\": \"0xb2988210c05a43ebd76575f5421ef84b120ebf80\", \"gasUsed\": \"0x5208\", \"index\": 0, \"logs\": [], \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"outcomeStatus\": 0, \"stateRoot\": \"0x1bc37c63c03d7e7066f9427f69e515988d19ebb26998087d75b50d2235e55ee7\", \"to\": \"0xb2988210c05a43ebd76575f5421ef84b120ebf80\", \"transactionHash\": \"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\" }, \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getaccount","text":"Return account related states of the given account","title":"cfx_getAccount"},{"location":"json-rpc/#parameters_21","text":"DATA , 20 Bytes - address to get account. QUANTITY|TAG - integer epoch number, or the string \"latest_mined\", \"latest_state\", \"earliest\", see the epoch number parameter params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_21","text":"Object - states of the given account: balance : QUANTITY - the balance of the account. nonce : QUANTITY - the nonce of the account's next transaction. codeHash : QUANTITY - the code hash of the account. stakingBalance : QUANTITY - the staking balance of the account. collateralForStorage : QUANTITY - the collateral storage of the account. accumulatedInterestReturn : QUANTITY -accumulated unterest return of the account. admin : DATA`, 20 Bytes - admin of the account.","title":"Returns"},{"location":"json-rpc/#example_21","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getAccount\",\"params\":[\"0x8af71f222b6e05b47d8385fe437fe2f2a9ec1f1f\", \"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": { \"accumulatedInterestReturn\": \"0x0\", \"admin\": \"0x144aa8f554d2ffbc81e0aa0f533f76f5220db09c\", \"balance\": \"0x0\", \"codeHash\": \"0x45fed62dd2b7c5ed76a63628ddc811e69bb5770cf31dd55647ca219aaee5434f\", \"collateralForStorage\": \"0x0\", \"nonce\": \"0x1\", \"stakingBalance\": \"0x0\" }, \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getinterestrate","text":"Returns the interest rate of given parameter.","title":"cfx_getInterestRate"},{"location":"json-rpc/#parameters_22","text":"TAG - (optional, default: \"latest_mined\") String \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter . params: [ 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_22","text":"QUANTITY - the interest rate of given parameter.","title":"Returns"},{"location":"json-rpc/#example_22","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getInterestRate\",\"params\":[\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x24b675dc000\", \"id\": 1 }","title":"Example"},{"location":"json-rpc/#cfx_getaccumulateinterestrate","text":"Returns the accumulate interest rate of given parameter.","title":"cfx_getAccumulateInterestRate"},{"location":"json-rpc/#parameters_23","text":"TAG - (optional, default: \"latest_mined\") String \"latest_mined\", \"latest_state\" or \"earliest\", see the epoch number parameter . params: [ 'latest_state' ]","title":"Parameters"},{"location":"json-rpc/#returns_23","text":"QUANTITY - the accumulate interest rate of given parameter.","title":"Returns"},{"location":"json-rpc/#example_23","text":"// Request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getAccumulateInterestRate\",\"params\":[\"latest_state\"],\"id\":1}' // Result { \"jsonrpc\": \"2.0\", \"result\": \"0x3c35a9e557dc9ef76719db0226f\", \"id\": 1 }","title":"Example"},{"location":"key_management/","text":"In this document, we go through the process of using command-line interface toolkit to create and manage your key-pair, create and sign your transaction, and submit your transaction to Conflux. Get Key Management Toolkit \u00b6 You can download the key management toolkit of Conflux ( keymgr ) from here . Or you can directly build keymgr from Conflux source code with the following steps. $ git clone ssh://git@base.conflux-chain.org:2222/source/conflux-rust.git $ cd conflux-rust/key_manager/cli $ cargo build The binary of keymgr is then under the folder conflux-rust/key_manager/cli/target/ . Create Key Pair Using KeyMgr \u00b6 You can use keymgr to create your own secret/public key-pair. $ keymgr generate random A sample output is: secret: 074842cdfa28a02fd23f244126618bcb49588a5530e7135dcd8c86aa3fbf0103 public: 7827b388197a9b4c4c97aafff400b1d168439b0b6b2428dad9a8f8ec461789155a9318c7d0d38a2e696e41c99faa0e7f7ab55bc21814b6e7809936f1d51ee5b0 address: 71e177b579a4b1ad24382f4b559f479ca0099572 address is the 160-bit account Id derived from the public key. You can keep privately your secret key at anywhere that only you know. Generate, Sign, and Submit Token Transferring Transaction \u00b6 Conflux provides Javascript library CfxWeb to help user generate transactions in programmable way. The following is a sample code snippet. #!/usr/bin/env node var Tx = require('ethereumjs-tx'); var secretKey = Buffer.from('e331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109', 'hex') var rawTx = { nonce: '0x00', gasPrice: '0x09184e72a000', gasLimit: '0x2710', to: '0x0000000000000000000000000000000000000000', value: '0x00', data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057' } var tx = new Tx(rawTx); tx.sign(secretKey); console.log('0x' + serializedTx.toString('hex')); var Web3 = require('web3'); var web3 = new Web3(); web3.setProvider(new web3.providers.HttpProvider('http://localhost:12345')); let answer = web3.cfx.sendRawTransaction('0x' + serializedTx.toString('hex')); console.log(answer); To run the above code, you need to first install Node.js and CfxWeb.js.","title":"Key management"},{"location":"key_management/#get-key-management-toolkit","text":"You can download the key management toolkit of Conflux ( keymgr ) from here . Or you can directly build keymgr from Conflux source code with the following steps. $ git clone ssh://git@base.conflux-chain.org:2222/source/conflux-rust.git $ cd conflux-rust/key_manager/cli $ cargo build The binary of keymgr is then under the folder conflux-rust/key_manager/cli/target/ .","title":"Get Key Management Toolkit"},{"location":"key_management/#create-key-pair-using-keymgr","text":"You can use keymgr to create your own secret/public key-pair. $ keymgr generate random A sample output is: secret: 074842cdfa28a02fd23f244126618bcb49588a5530e7135dcd8c86aa3fbf0103 public: 7827b388197a9b4c4c97aafff400b1d168439b0b6b2428dad9a8f8ec461789155a9318c7d0d38a2e696e41c99faa0e7f7ab55bc21814b6e7809936f1d51ee5b0 address: 71e177b579a4b1ad24382f4b559f479ca0099572 address is the 160-bit account Id derived from the public key. You can keep privately your secret key at anywhere that only you know.","title":"Create Key Pair Using KeyMgr"},{"location":"key_management/#generate-sign-and-submit-token-transferring-transaction","text":"Conflux provides Javascript library CfxWeb to help user generate transactions in programmable way. The following is a sample code snippet. #!/usr/bin/env node var Tx = require('ethereumjs-tx'); var secretKey = Buffer.from('e331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109', 'hex') var rawTx = { nonce: '0x00', gasPrice: '0x09184e72a000', gasLimit: '0x2710', to: '0x0000000000000000000000000000000000000000', value: '0x00', data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057' } var tx = new Tx(rawTx); tx.sign(secretKey); console.log('0x' + serializedTx.toString('hex')); var Web3 = require('web3'); var web3 = new Web3(); web3.setProvider(new web3.providers.HttpProvider('http://localhost:12345')); let answer = web3.cfx.sendRawTransaction('0x' + serializedTx.toString('hex')); console.log(answer); To run the above code, you need to first install Node.js and CfxWeb.js.","title":"Generate, Sign, and Submit Token Transferring Transaction"},{"location":"overview/","text":"Overview \u00b6","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"recovery/","text":"","title":"Recovery"},{"location":"rigorous-testing/","text":"Rigorous Testing Tools for Conflux \u00b6 Ensuring the correctness of a blockchain system like Conflux is a challenging task. The Conflux Rust implementation repository comes with several rigorous testing tools and scripts. Note that in some terminals, the default maximum number of open file descriptors may not be enough. This is especially true if you are using Mac with its default zsh terminal. You will need to change the limit to a larger number as follows: $ ulimit -n 22288 Unit Tests and Integration Tests \u00b6 Unit tests come together with the rust code. It can be invoked via cargo test --release --all after Conflux being complied from the source code. See the Getting Started page for more information. Integration tests are python test scripts ended with _test.py in the tests/scripts directory. After compiled the release version of the Conflux from code. One can run tests/test_all.py to run all integration tests together. These tests are executed routinely for every commit to the Conflux Rust implementation. Consensus Fuzzing Tool \u00b6 Inside the directory core/benchmark/consensus/test , there is a random fuzzing tool for the consensus component. It works as follows. core/benchmark/consensus/test/gen-random-graph.cpp is a slow C++ implementation of the Conflux TreeGraph consensus algorithm together with a random graph generator that generates random TreeGraph blocks in a special format. consensus_bench is capable of processing this input format, run the Conflux consensus, and compare the results with the slow C++ implementation. iter-gen-random.py is a python script that iteratively invoke the generation-processing-comparing process. To run this fuzzing tool: $ cd core/benchmark/consensus/test $ g++ -O2 -o gen-random-graph gen-random-graph.cpp $ ./iter-gen-random.py 10000 3 30 10 10 100 The python script will not stop until it finds an error or you manually terminate it. If the python script finds an error, the rand.in file will correspond to the bug triggering input for the consensus_bench program. The six parameters passed to the python scripts corresponds to the number of randomly generated block per test case, the TIMER_CHAIN_BLOCK_DIFFICULTY_RATIO parameter, the TIMER_CHAIN_BETA parameter, the ADAPTIVE_WEIGHT_BETA parameter, the HEAVY_BLOCK_DIFFICULTY_RATIO parameter, the ERA_EPOCH_COUNT parameter, respectively. You can pass any legitimate consensus parameter to the python script. These numbers are default that we empirically find them useful for detecting bugs. The python script will also print out the processing speed of the consensus graph in the test. The expected speed is ~1000 blocks per second (on a Mac Book Pro 2019 laptop) and ~350 blocks per second on m5a.xlarge. If the reported speed is significantly lower than expected, it typically means a potential performance issue. For every release, we execute this fuzzing for at least one hour using the default parameters. Note that if you terminate this script brutally (which you will like do). It leaves two to three temporary directories with the __ prefix and sqlite_db . You should remove these directories manually. Random Tracing Test \u00b6 tests/conflux_tracing.py is a random testing script with the failure injection capability. It will start a Conflux network with a fixed number of nodes and inject node crashes, db crashes, and node restarts during. During the running, it keep fetches states from different node and verify that these nodes have the consensus for the TreeGraph and block state. To run Conflux tracing, you need to first compile the release version of the Conflux Rust implementation from the source code. Then you can invoke the script as follows: $ tests/conflux_tracing.py run The python script will then start 10 different instances together with a mock instance. It will run non-stop until it finds an error (inconsistent state or unexpected crash). For every release, we execute this tracing script for at least one hour. In case of errors, it will generate trace files snapshot*.json and txs*.json to help diagnose the issue. Note that if you terminate this script brutally (which you will likely do). It also generates these files so you may want to clean them manually. Transaction Propagation and Performance Test \u00b6 tests/scripts/one_click.sh together with the remaining bash scripts in the same directory provide an automatic deployment of Conflux network on AWS for testing the simple payment TPS and transaction pool performance. You can run this test as follows: First you need to download and install AWS CLI tools. Properly configure the AWS credential for the CLI tool. Make your default public key registered as a named key pair in the us-west-2 region . Decide the branch of the Conflux repo you want to test. Note that this script pulls the source code from a GitHub repo that contains the Conflux rust implementation and compile them on the fly. You cannot run your local Conflux copy with this script. If you do not specify the repo/branch name, it will pull from the official Conflux-rust repo from the GitHub. Run the following command: $ cd tests/scripts $ ./one_click.sh key-pair-name 20 branch-name [repo-name] This will start 20 instances at the us-west-2 region together with a random transaction generator. It will take roughly 15 minutes to setup the experiments and then 20 minutes to finish the run. In the end, it will report the TPS performance. The expected good TPS number is ~4000TPS. If you get a TPS number much lower than the expectation, there is a performance regression at the transaction pool or at the storage layer. For every release, we run this script to test its performance. Storage Benchmark Test \u00b6 The storage layer in Conflux is often the performance bottleneck. core/benchmark/storage therefore contains a benchmark tool to measure the performance of the storage layer, eliminating other layer from the execution. We also converted Ethereum network history payment transactions (first ~4m blocks) as the benchmark traces. Here are steps to run the storage benchmark test: From the AWS S3 conflux-storage-bench bucket, download foundation.json and eth_from_0_to_4141811_txs.rlp.tar.gz . Untar the rlp history file to obtain eth_from_0_to_4141811_txs.rlp . Go to core/benchmark/storage and run cargo build --release to compile the binary storage_bench . Create a temporary directory tmp_storage_db for holding the blockchain database generated in the experiment. Invoke the following command: $ cd core/benchmark/storage $ RUST_BACKTRACE=full target/release/storage_bench run -g /path/to/foundation.json -t /path/to/eth_from_0_to_4141811_txs.rlp -d /path/to/tmp_storage_db --txs_to_process 30000000 --skip 1156773812 This command will process the first 30 million transactiosn from the parsed history file and then quit. It is a good idea to time the running time of this command for computing the achieved processing throughput of the storage layer. The performance will largely depend on the quality of the underlying disk I/O. In MacBook Pro 2019, the throughput is 25000-30000 TPS. In m5a.xlarge, the throughput is 15000-20000 TPS. If the performance is lower than the expectation, it indicates a potential regression at the storage layer. For every relealse, we will run this test to check the storage layer performance. Consensus Performance Benchmark Tool \u00b6 The consensus implementation is typically fast and can process close to one thousand blocks per second in the normal scenarios. However, if the TreeGraph is unstable and it contains a lot of forks, the consensus component may fail back to slow routines. Its performance under such unstable scenarios is critical because it corresponds to the catch-up speed during DoS attacks. tests/attack_bench contains a list of python scripts to benchmark the consensus performance under attack scenarios: fork_same_height_merge.py creates a unstable TreeGraph with roughly 95000 blocks. In the TreeGraph, it has three branches and in each branch there are star shape forks attached at a fixed height. It corresponds to one worst case scenario for the consensus procesing engine. The expected speed is ~70 blocks/s on MacBook Pro 2019 and ~45 blocks/s on m5a.xlarge. fork_same_height_hiding.py tests the scenario where an attacker tries to actively mine at a fixed height, hides the mined blocks, and release them together. It measures the block generation capaiblity of the victim at this scenario. The expected generation speed is always faster than 1000 blocks in less than 1 minutes. fork_same_height_attack.py tests a similar attack as 2 but the attacker does not hide the blocks. The expected generation speed is always afster than 100 blocks in less than 10 seconds. fork_chain_hiding.py tests the scenario where an attacker tries to actively mine a saperate chain, hides the mined blocks, and release them together. The expected generation speed of the victim is always faster than 100 blocks in less than 10 seconds. fork_chain_attack.py tests a similar attack as 4 but the attacker does not hide the blocks. The expected generation speed of the victim is always faster than 100 blocks in less than 10 seconds. Note that 2, 3, and 5 are long running test scripts and you can terminate the execution after the speed stablizes. For every release, we run these scripts to make sure that there is no performance regression.","title":"Rigorous Testing Tools for Conflux"},{"location":"rigorous-testing/#rigorous-testing-tools-for-conflux","text":"Ensuring the correctness of a blockchain system like Conflux is a challenging task. The Conflux Rust implementation repository comes with several rigorous testing tools and scripts. Note that in some terminals, the default maximum number of open file descriptors may not be enough. This is especially true if you are using Mac with its default zsh terminal. You will need to change the limit to a larger number as follows: $ ulimit -n 22288","title":"Rigorous Testing Tools for Conflux"},{"location":"rigorous-testing/#unit-tests-and-integration-tests","text":"Unit tests come together with the rust code. It can be invoked via cargo test --release --all after Conflux being complied from the source code. See the Getting Started page for more information. Integration tests are python test scripts ended with _test.py in the tests/scripts directory. After compiled the release version of the Conflux from code. One can run tests/test_all.py to run all integration tests together. These tests are executed routinely for every commit to the Conflux Rust implementation.","title":"Unit Tests and Integration Tests"},{"location":"rigorous-testing/#consensus-fuzzing-tool","text":"Inside the directory core/benchmark/consensus/test , there is a random fuzzing tool for the consensus component. It works as follows. core/benchmark/consensus/test/gen-random-graph.cpp is a slow C++ implementation of the Conflux TreeGraph consensus algorithm together with a random graph generator that generates random TreeGraph blocks in a special format. consensus_bench is capable of processing this input format, run the Conflux consensus, and compare the results with the slow C++ implementation. iter-gen-random.py is a python script that iteratively invoke the generation-processing-comparing process. To run this fuzzing tool: $ cd core/benchmark/consensus/test $ g++ -O2 -o gen-random-graph gen-random-graph.cpp $ ./iter-gen-random.py 10000 3 30 10 10 100 The python script will not stop until it finds an error or you manually terminate it. If the python script finds an error, the rand.in file will correspond to the bug triggering input for the consensus_bench program. The six parameters passed to the python scripts corresponds to the number of randomly generated block per test case, the TIMER_CHAIN_BLOCK_DIFFICULTY_RATIO parameter, the TIMER_CHAIN_BETA parameter, the ADAPTIVE_WEIGHT_BETA parameter, the HEAVY_BLOCK_DIFFICULTY_RATIO parameter, the ERA_EPOCH_COUNT parameter, respectively. You can pass any legitimate consensus parameter to the python script. These numbers are default that we empirically find them useful for detecting bugs. The python script will also print out the processing speed of the consensus graph in the test. The expected speed is ~1000 blocks per second (on a Mac Book Pro 2019 laptop) and ~350 blocks per second on m5a.xlarge. If the reported speed is significantly lower than expected, it typically means a potential performance issue. For every release, we execute this fuzzing for at least one hour using the default parameters. Note that if you terminate this script brutally (which you will like do). It leaves two to three temporary directories with the __ prefix and sqlite_db . You should remove these directories manually.","title":"Consensus Fuzzing Tool"},{"location":"rigorous-testing/#random-tracing-test","text":"tests/conflux_tracing.py is a random testing script with the failure injection capability. It will start a Conflux network with a fixed number of nodes and inject node crashes, db crashes, and node restarts during. During the running, it keep fetches states from different node and verify that these nodes have the consensus for the TreeGraph and block state. To run Conflux tracing, you need to first compile the release version of the Conflux Rust implementation from the source code. Then you can invoke the script as follows: $ tests/conflux_tracing.py run The python script will then start 10 different instances together with a mock instance. It will run non-stop until it finds an error (inconsistent state or unexpected crash). For every release, we execute this tracing script for at least one hour. In case of errors, it will generate trace files snapshot*.json and txs*.json to help diagnose the issue. Note that if you terminate this script brutally (which you will likely do). It also generates these files so you may want to clean them manually.","title":"Random Tracing Test"},{"location":"rigorous-testing/#transaction-propagation-and-performance-test","text":"tests/scripts/one_click.sh together with the remaining bash scripts in the same directory provide an automatic deployment of Conflux network on AWS for testing the simple payment TPS and transaction pool performance. You can run this test as follows: First you need to download and install AWS CLI tools. Properly configure the AWS credential for the CLI tool. Make your default public key registered as a named key pair in the us-west-2 region . Decide the branch of the Conflux repo you want to test. Note that this script pulls the source code from a GitHub repo that contains the Conflux rust implementation and compile them on the fly. You cannot run your local Conflux copy with this script. If you do not specify the repo/branch name, it will pull from the official Conflux-rust repo from the GitHub. Run the following command: $ cd tests/scripts $ ./one_click.sh key-pair-name 20 branch-name [repo-name] This will start 20 instances at the us-west-2 region together with a random transaction generator. It will take roughly 15 minutes to setup the experiments and then 20 minutes to finish the run. In the end, it will report the TPS performance. The expected good TPS number is ~4000TPS. If you get a TPS number much lower than the expectation, there is a performance regression at the transaction pool or at the storage layer. For every release, we run this script to test its performance.","title":"Transaction Propagation and Performance Test"},{"location":"rigorous-testing/#storage-benchmark-test","text":"The storage layer in Conflux is often the performance bottleneck. core/benchmark/storage therefore contains a benchmark tool to measure the performance of the storage layer, eliminating other layer from the execution. We also converted Ethereum network history payment transactions (first ~4m blocks) as the benchmark traces. Here are steps to run the storage benchmark test: From the AWS S3 conflux-storage-bench bucket, download foundation.json and eth_from_0_to_4141811_txs.rlp.tar.gz . Untar the rlp history file to obtain eth_from_0_to_4141811_txs.rlp . Go to core/benchmark/storage and run cargo build --release to compile the binary storage_bench . Create a temporary directory tmp_storage_db for holding the blockchain database generated in the experiment. Invoke the following command: $ cd core/benchmark/storage $ RUST_BACKTRACE=full target/release/storage_bench run -g /path/to/foundation.json -t /path/to/eth_from_0_to_4141811_txs.rlp -d /path/to/tmp_storage_db --txs_to_process 30000000 --skip 1156773812 This command will process the first 30 million transactiosn from the parsed history file and then quit. It is a good idea to time the running time of this command for computing the achieved processing throughput of the storage layer. The performance will largely depend on the quality of the underlying disk I/O. In MacBook Pro 2019, the throughput is 25000-30000 TPS. In m5a.xlarge, the throughput is 15000-20000 TPS. If the performance is lower than the expectation, it indicates a potential regression at the storage layer. For every relealse, we will run this test to check the storage layer performance.","title":"Storage Benchmark Test"},{"location":"rigorous-testing/#consensus-performance-benchmark-tool","text":"The consensus implementation is typically fast and can process close to one thousand blocks per second in the normal scenarios. However, if the TreeGraph is unstable and it contains a lot of forks, the consensus component may fail back to slow routines. Its performance under such unstable scenarios is critical because it corresponds to the catch-up speed during DoS attacks. tests/attack_bench contains a list of python scripts to benchmark the consensus performance under attack scenarios: fork_same_height_merge.py creates a unstable TreeGraph with roughly 95000 blocks. In the TreeGraph, it has three branches and in each branch there are star shape forks attached at a fixed height. It corresponds to one worst case scenario for the consensus procesing engine. The expected speed is ~70 blocks/s on MacBook Pro 2019 and ~45 blocks/s on m5a.xlarge. fork_same_height_hiding.py tests the scenario where an attacker tries to actively mine at a fixed height, hides the mined blocks, and release them together. It measures the block generation capaiblity of the victim at this scenario. The expected generation speed is always faster than 1000 blocks in less than 1 minutes. fork_same_height_attack.py tests a similar attack as 2 but the attacker does not hide the blocks. The expected generation speed is always afster than 100 blocks in less than 10 seconds. fork_chain_hiding.py tests the scenario where an attacker tries to actively mine a saperate chain, hides the mined blocks, and release them together. The expected generation speed of the victim is always faster than 100 blocks in less than 10 seconds. fork_chain_attack.py tests a similar attack as 4 but the attacker does not hide the blocks. The expected generation speed of the victim is always faster than 100 blocks in less than 10 seconds. Note that 2, 3, and 5 are long running test scripts and you can terminate the execution after the speed stablizes. For every release, we run these scripts to make sure that there is no performance regression.","title":"Consensus Performance Benchmark Tool"},{"location":"send_transaction/","text":"This document will guide you to compose and send your first transaction into the Conflux network, including the introduction of technical specs of Conflux's transaction, and the basic techniques to track the status of sent transactions in Conflux network and error handling. For common users, it is recommended to use a Conflux wallet like Conflux Portal , which is easy, safe and user-friendly. For developers that want to compose and send transaction in your own program. Conflux provides you several SDKs in different languages: JavaScript: js-conflux-sdk Java: java-conflux-sdk Go: go-conflux-sdk The following document will use js-conflux-sdk as an example. Compose and send my first transaction \u00b6 Create an account with Conflux Portal \u00b6 Install Conflux Protal . Generate a new account. Get and test-net token from the faucet. Export and copy your private key to somewhere, we'll use it later. Installation \u00b6 npm install js-conflux-sdk Send transaction by JavaScript program \u00b6 require js-conflux-sdk and set a Conflux provider. For the Conflux test-net, there is a node provided at http://testnet-jsonrpc.conflux-chain.org:12537. It can also be changed to any other Conflux nodes, even the one set on your own. const { Conflux, util } = require('js-conflux-sdk'); const cfx = new Conflux({ url: 'http://testnet-jsonrpc.conflux-chain.org:12537', defaultGasPrice: 100, // The default gas price of your following transactions defaultGas: 1000000, // The default gas of your following transactions logger: console, }); paste your private key into the program const PRIVATE_KEY = 'Your Private Key'; // const PRIVATE_KEY = '0x5f15f9e52fc5ec6f77115a9f306c120a7e80d83115212d33a843bb6b7989c261'; const account = cfx.Account(PRIVATE_KEY); // create account instance const receiver = '0xa70ddf9b9750c575db453eea6a041f4c8536785a' Compose your transaction, here are the fields could be filled with: nonce : optional, the nonce of a transaction to keep the order of your sending transactions, starting with some random large number and increase one by one. If missing, the result of cfx_getNextNonce will be automatically filled in and it works for general scenarios. Some cases, like sending a lot of transactions in a short period. It's recommended to maintain the nonce on your own. gasPrice : optional, the price in Drip that you would like to pay for each gas consumed. If missing, the result of cfx_gasPrice will be automatically filled in, which is the median of recent transactions. gas : optional, the max gas you would like to use in the transaction. After the end of transaction processing, the unused gas will be refunded if used_gas >= gas * 0.75. If missing, the result of cfx_estimateGasAndCollateral will be automatically filled in and it works for general scenarios. to : the receiver of the transaction, could be a personal account(start with 1) or contract(start with 8). Leave a null here to deploy a contract. value : the value (in Drip) to be transferred. storageLimit : optional, he max storage (in Byte) you would like to collateralize in the transaction. If missing, the result of cfx_estimateGasAndCollateral will be automatically filled in and it works for general senarios.transactions. epochHeight : optional, a transaction is can be verified only in epochs in the range [epochHeight - 10000, epochHeight + 10000], so it's a timeout mechanism. If missing, the result of cfx_epochNumber will be automatically filled in and it works for general scenarios. data : optional, it's either an attached message of a transaction or a function signature of a contract call. If missing, a null will be filled into it. chainId : optional, it used for dealing with a hard fork or preventing a transaction replay attack. If missing, 0 will be filled into it. from : The sender account(with private key) to sign the transaction. let txParams = { from: account, // from account instance and will by sign by account.privateKey // nonce // gasPrice // gas to: receiver, // accept address string or account instance value: util.unit.fromCFXToDrip(0.125), // use unit to transfer from 0.125 CFX to Drip // storageLimit // epochHeight // data }; Send it away by cfx.sendTransaction and get the returned transaction hash, then you can view the transaction details by searching the hash on Conflux Scan . async function main() { const txHash = await cfx.sendTransaction(txParams); console.log(txHash); } main().catch(e => console.error(e)); Track my transaction \u00b6 After sending, the transaction could be in several different states: 1. rejected by RPC provider immediately \u00b6 After the provider got the cfx_sendRawTransaction RPC call, it will try to do the basic verification and insert it into the transaction pool. If there an obvious error of the transaction, e.t.c, RLP decoding error, signature verification error, it will be rejected immediately. Otherwise, it will be inserted into the transaction pool and start to wait to be mined, and the RPC will return a transaction hash. 2. got stucked in the transaction pool \u00b6 However, the transaction hash you got doesn't mean it's successfully executed. Conflux transaction will store as much verified transactions in the pool as possible, even the transactions whose nonce doesn' match expected one or the balance is not enough to pay the gas * gasPrice + value . So if you wait for 1 minute and still cannot find the transaction in ConfluxScan after sending it, it very likely got stuck in the transaction pool. Use cfx_getTransactionByHash, cfx_getBalance and cfx_getNextNonce to check if your transaction is ready to be packed and mined, for example: curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBalance\",\"params\":[\"0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8\"],\"id\":1}' -H \"Content-Type: application/json\" http://testnet-jsonrpc.conflux-chain.org:12537 And compare the result with value + gas * gasPrice. curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getNextNonce\",\"params\":[\"0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8\"],\"id\":1}' -H \"Content-Type: application/json\" http://testnet-jsonrpc.conflux-chain.org:12537 And compare the result with nonce you filled in. You can always get the transaction details by cfx_getTransactionByHash: curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionByHash\",\"params\":[\"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\"],\"id\":1}' -H \"Content-Type: application/json\" http://testnet-jsonrpc.conflux-chain.org:12537 In this situation, you may want to send a new transaction after fixing the nonce or balance problem. Note that, replacing a transaction in the pool with the same nonce, a higher gasPrice is necessary. 3. mined but skipped \u00b6 If you can view the transaction on ConfluxScan but its status always shows \"skip\". Which means it didn't pass the basic verification (etc, nonce doesn't match, balance can't cover the basic fee) in execution engine and got skipped. In this situation, you may want to send a new transaction after fixing the nonce or balance problem. Note that, replacing a transaction in the pool with the same nonce, a higher gasPrice is necessary. 4. mined and executed with some error outcome \u00b6 In this case, you'll see an error message on ConfluxScan. This could be in several causes: EVM error: like assert, require balance is enough to pay the basic fee, but not for the whole transaction fee storageLimit reached It's a good idea to double-check your contract in Remix IDE and check the storageLimit and balance issue by cfx_estimateGasAndCollateral RPC. 5. mined and executed with no error outcome \u00b6 Congrats! Your first transaction finally got there.","title":"My First Transaction"},{"location":"send_transaction/#compose-and-send-my-first-transaction","text":"","title":"Compose and send my first transaction"},{"location":"send_transaction/#create-an-account-with-conflux-portal","text":"Install Conflux Protal . Generate a new account. Get and test-net token from the faucet. Export and copy your private key to somewhere, we'll use it later.","title":"Create an account with Conflux Portal"},{"location":"send_transaction/#installation","text":"npm install js-conflux-sdk","title":"Installation"},{"location":"send_transaction/#send-transaction-by-javascript-program","text":"require js-conflux-sdk and set a Conflux provider. For the Conflux test-net, there is a node provided at http://testnet-jsonrpc.conflux-chain.org:12537. It can also be changed to any other Conflux nodes, even the one set on your own. const { Conflux, util } = require('js-conflux-sdk'); const cfx = new Conflux({ url: 'http://testnet-jsonrpc.conflux-chain.org:12537', defaultGasPrice: 100, // The default gas price of your following transactions defaultGas: 1000000, // The default gas of your following transactions logger: console, }); paste your private key into the program const PRIVATE_KEY = 'Your Private Key'; // const PRIVATE_KEY = '0x5f15f9e52fc5ec6f77115a9f306c120a7e80d83115212d33a843bb6b7989c261'; const account = cfx.Account(PRIVATE_KEY); // create account instance const receiver = '0xa70ddf9b9750c575db453eea6a041f4c8536785a' Compose your transaction, here are the fields could be filled with: nonce : optional, the nonce of a transaction to keep the order of your sending transactions, starting with some random large number and increase one by one. If missing, the result of cfx_getNextNonce will be automatically filled in and it works for general scenarios. Some cases, like sending a lot of transactions in a short period. It's recommended to maintain the nonce on your own. gasPrice : optional, the price in Drip that you would like to pay for each gas consumed. If missing, the result of cfx_gasPrice will be automatically filled in, which is the median of recent transactions. gas : optional, the max gas you would like to use in the transaction. After the end of transaction processing, the unused gas will be refunded if used_gas >= gas * 0.75. If missing, the result of cfx_estimateGasAndCollateral will be automatically filled in and it works for general scenarios. to : the receiver of the transaction, could be a personal account(start with 1) or contract(start with 8). Leave a null here to deploy a contract. value : the value (in Drip) to be transferred. storageLimit : optional, he max storage (in Byte) you would like to collateralize in the transaction. If missing, the result of cfx_estimateGasAndCollateral will be automatically filled in and it works for general senarios.transactions. epochHeight : optional, a transaction is can be verified only in epochs in the range [epochHeight - 10000, epochHeight + 10000], so it's a timeout mechanism. If missing, the result of cfx_epochNumber will be automatically filled in and it works for general scenarios. data : optional, it's either an attached message of a transaction or a function signature of a contract call. If missing, a null will be filled into it. chainId : optional, it used for dealing with a hard fork or preventing a transaction replay attack. If missing, 0 will be filled into it. from : The sender account(with private key) to sign the transaction. let txParams = { from: account, // from account instance and will by sign by account.privateKey // nonce // gasPrice // gas to: receiver, // accept address string or account instance value: util.unit.fromCFXToDrip(0.125), // use unit to transfer from 0.125 CFX to Drip // storageLimit // epochHeight // data }; Send it away by cfx.sendTransaction and get the returned transaction hash, then you can view the transaction details by searching the hash on Conflux Scan . async function main() { const txHash = await cfx.sendTransaction(txParams); console.log(txHash); } main().catch(e => console.error(e));","title":"Send transaction by JavaScript program"},{"location":"send_transaction/#track-my-transaction","text":"After sending, the transaction could be in several different states:","title":"Track my transaction"},{"location":"send_transaction/#1-rejected-by-rpc-provider-immediately","text":"After the provider got the cfx_sendRawTransaction RPC call, it will try to do the basic verification and insert it into the transaction pool. If there an obvious error of the transaction, e.t.c, RLP decoding error, signature verification error, it will be rejected immediately. Otherwise, it will be inserted into the transaction pool and start to wait to be mined, and the RPC will return a transaction hash.","title":"1. rejected by RPC provider immediately"},{"location":"send_transaction/#2-got-stucked-in-the-transaction-pool","text":"However, the transaction hash you got doesn't mean it's successfully executed. Conflux transaction will store as much verified transactions in the pool as possible, even the transactions whose nonce doesn' match expected one or the balance is not enough to pay the gas * gasPrice + value . So if you wait for 1 minute and still cannot find the transaction in ConfluxScan after sending it, it very likely got stuck in the transaction pool. Use cfx_getTransactionByHash, cfx_getBalance and cfx_getNextNonce to check if your transaction is ready to be packed and mined, for example: curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getBalance\",\"params\":[\"0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8\"],\"id\":1}' -H \"Content-Type: application/json\" http://testnet-jsonrpc.conflux-chain.org:12537 And compare the result with value + gas * gasPrice. curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getNextNonce\",\"params\":[\"0xfbe45681ac6c53d5a40475f7526bac1fe7590fb8\"],\"id\":1}' -H \"Content-Type: application/json\" http://testnet-jsonrpc.conflux-chain.org:12537 And compare the result with nonce you filled in. You can always get the transaction details by cfx_getTransactionByHash: curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"cfx_getTransactionByHash\",\"params\":[\"0x53fe995edeec7d241791ff32635244e94ecfd722c9fe90f34ddf59082d814514\"],\"id\":1}' -H \"Content-Type: application/json\" http://testnet-jsonrpc.conflux-chain.org:12537 In this situation, you may want to send a new transaction after fixing the nonce or balance problem. Note that, replacing a transaction in the pool with the same nonce, a higher gasPrice is necessary.","title":"2. got stucked in the transaction pool"},{"location":"send_transaction/#3-mined-but-skipped","text":"If you can view the transaction on ConfluxScan but its status always shows \"skip\". Which means it didn't pass the basic verification (etc, nonce doesn't match, balance can't cover the basic fee) in execution engine and got skipped. In this situation, you may want to send a new transaction after fixing the nonce or balance problem. Note that, replacing a transaction in the pool with the same nonce, a higher gasPrice is necessary.","title":"3. mined but skipped"},{"location":"send_transaction/#4-mined-and-executed-with-some-error-outcome","text":"In this case, you'll see an error message on ConfluxScan. This could be in several causes: EVM error: like assert, require balance is enough to pay the basic fee, but not for the whole transaction fee storageLimit reached It's a good idea to double-check your contract in Remix IDE and check the storageLimit and balance issue by cfx_estimateGasAndCollateral RPC.","title":"4. mined and executed with some error outcome"},{"location":"send_transaction/#5-mined-and-executed-with-no-error-outcome","text":"Congrats! Your first transaction finally got there.","title":"5. mined and executed with no error outcome"},{"location":"setup_independent_chain/","text":"How to Set an Independent Conflux Chain \u00b6 You may want to run Conflux on a single node chain to develop and test smart contracts. You can run Conflux as your indepdent chain with several machines. Run Single Node Development Chain \u00b6 In roder to run a single node Conflux chain for development, you can follow the following steps: Get executable Conflux binary file (use precompiled binary or build from the latest source code). You can refer to the document Installation . Create a directory and prepare a configuration file development.toml . You can copy the default.toml provided in the directory and start from there following the guide Getting Started . Set the bootnodes parameter in the configuration file to empty (or comment the setting line). Set the mode parameter to \"dev\". If you copy from default.toml , you should find the line being commented and you can uncomment it. Set the dev_block_interval_ms parameter to the block generation interval you want. In the development mode, Conflux will automatically generate a block in a fixed interval. Run Conflux binary with development.toml as the configuration file. For example: bash $ ../target/release/conflux --config development.toml Run Multiple Node Production Chain \u00b6 To have your independent Conflux chain with multiple nodes in the production mode, you need to ensure that your nodes can be connected to other nodes in this chain, and will not connect to other chains (like our testnet). To achieve this, you should setup your own boot node, and let other nodes connect to it. Then they will connect to others with our discovery protocol. You need the IP address, the port number, and the node id of the bootnode for others to connect. The node id is the public key corresponding the the node's unique private key for identification at the network layer. And here is an instruction to let the bootnode generate its private key automatically, and get the node id through the log file. A Simple Instruction \u00b6 Get executable Conflux binary file (use precompiled binary or build from the latest source code). You can refer to the document Installation . Create a directory and prepare a configuration file bootnode.toml for the bootnode (the default port is 32323 if not set). You can refer to Getting Started . Ensure that bootnode.toml does not contain the bootnode entry, and the log level for network is at least debug . ```bash $ mkdir run $ cd run Put Conflux executable conflux and the configuration file bootnode.toml under run \u00b6 ``` If you are editing based on our provided default.toml , you need to comment out the bootnode entry. Otherwise the node will connect to the existing Conflux net. Launch the bootnode, and find the node id in the console print out. The information for node id is Self node id: $ID where $ID is the 0x-prefixed node id of this bootnode. Remove the 0x prefix and you'll get the node id $NODEID . If you missed the line from the screen, you can look at the log file with: bash grep \"Self node id\" log/conflux.log|awk '{print $9}'|tr -d '0x' Now we have the $IP , $PORT$ , and $NODEID of the boot node, we can get the url for this boot node with the format cfxnode://$NODEID@$IP:$PORT . Denote this as $BOOTNODE_URL . Start other nodes by setting bootnodes=\"$BOOTNODE_URL\" in their configuration. Note that with the instruction above, other nodes connected to the boot node will stay in untrusted state for a while (3 days by default), and untrusted nodes will not be broadcast in our discovery protocol. Thus, the network structure will be a star with the boot node in the center before other nodes are promoted to trusted state. You can change node_table_promotion_timeout_s in the configurations to make this period shorter. Setting Multiple Bootnodes \u00b6 You can also setup multiple bootnodes at the very beginning. However, this cannot be done by simply replaying the boot node setup steps above multiple times, because you need to set bootnodes of every boot node before they are started. One way to achieve this is to start these bootnodes and stop them immediately. Then gather their node ids, set their configuration, and restart them all. Another better way is to generate their private keys seperately, and manually set their net_key to start. This can be done with the functions provided in our python test framework in the directory test . from conflux.utils import * num_of_bootnodes=10 for _ in range(num_of_bootnodes): pri_key, pub_key = ec_random_keys() node_id = encode_hex(encode_int32(pub_key[0]) + encode_int32(pub_key[1])) print(encode_hex(pri_key), node_id) Then you can construct the bootnode url with the generated node id, and start each node by setting the net_key=\"$NET_KEY\" field to the private key or pass it with the command line option --net-key $NET_KEY . Setting Genesis Accounts \u00b6 In a production environment, you can initialize the initial genesis state with your accounts by setting the genesis_accounts to an account file with formats like 0f947e34fc907008968ec99baa1dbb677b927531=\"1000000000000\" ab4a32bca7500d94a2cc1f3150e12686c692c590=\"1000000000000\" Every line is an account. The key is the account address, and the value is a string representing its balance in Drip. Note that genesis_accounts does not apply if mode is test or dev . If the mode is test or dev, you can setup the genesis accounts with their secret keys by setting genesis_secrets . Each line is an account private key without 0x-prefix. The balance of each account is set to 10000000000000000000000 by default.","title":"Run an Indepdent Chain"},{"location":"setup_independent_chain/#how-to-set-an-independent-conflux-chain","text":"You may want to run Conflux on a single node chain to develop and test smart contracts. You can run Conflux as your indepdent chain with several machines.","title":"How to Set an Independent Conflux Chain"},{"location":"setup_independent_chain/#run-single-node-development-chain","text":"In roder to run a single node Conflux chain for development, you can follow the following steps: Get executable Conflux binary file (use precompiled binary or build from the latest source code). You can refer to the document Installation . Create a directory and prepare a configuration file development.toml . You can copy the default.toml provided in the directory and start from there following the guide Getting Started . Set the bootnodes parameter in the configuration file to empty (or comment the setting line). Set the mode parameter to \"dev\". If you copy from default.toml , you should find the line being commented and you can uncomment it. Set the dev_block_interval_ms parameter to the block generation interval you want. In the development mode, Conflux will automatically generate a block in a fixed interval. Run Conflux binary with development.toml as the configuration file. For example: bash $ ../target/release/conflux --config development.toml","title":"Run Single Node Development Chain"},{"location":"setup_independent_chain/#run-multiple-node-production-chain","text":"To have your independent Conflux chain with multiple nodes in the production mode, you need to ensure that your nodes can be connected to other nodes in this chain, and will not connect to other chains (like our testnet). To achieve this, you should setup your own boot node, and let other nodes connect to it. Then they will connect to others with our discovery protocol. You need the IP address, the port number, and the node id of the bootnode for others to connect. The node id is the public key corresponding the the node's unique private key for identification at the network layer. And here is an instruction to let the bootnode generate its private key automatically, and get the node id through the log file.","title":"Run Multiple Node Production Chain"},{"location":"setup_independent_chain/#a-simple-instruction","text":"Get executable Conflux binary file (use precompiled binary or build from the latest source code). You can refer to the document Installation . Create a directory and prepare a configuration file bootnode.toml for the bootnode (the default port is 32323 if not set). You can refer to Getting Started . Ensure that bootnode.toml does not contain the bootnode entry, and the log level for network is at least debug . ```bash $ mkdir run $ cd run","title":"A Simple Instruction"},{"location":"setup_independent_chain/#put-conflux-executable-conflux-and-the-configuration-file-bootnodetoml-under-run","text":"``` If you are editing based on our provided default.toml , you need to comment out the bootnode entry. Otherwise the node will connect to the existing Conflux net. Launch the bootnode, and find the node id in the console print out. The information for node id is Self node id: $ID where $ID is the 0x-prefixed node id of this bootnode. Remove the 0x prefix and you'll get the node id $NODEID . If you missed the line from the screen, you can look at the log file with: bash grep \"Self node id\" log/conflux.log|awk '{print $9}'|tr -d '0x' Now we have the $IP , $PORT$ , and $NODEID of the boot node, we can get the url for this boot node with the format cfxnode://$NODEID@$IP:$PORT . Denote this as $BOOTNODE_URL . Start other nodes by setting bootnodes=\"$BOOTNODE_URL\" in their configuration. Note that with the instruction above, other nodes connected to the boot node will stay in untrusted state for a while (3 days by default), and untrusted nodes will not be broadcast in our discovery protocol. Thus, the network structure will be a star with the boot node in the center before other nodes are promoted to trusted state. You can change node_table_promotion_timeout_s in the configurations to make this period shorter.","title":"Put Conflux executable conflux and the configuration file bootnode.toml under run"},{"location":"setup_independent_chain/#setting-multiple-bootnodes","text":"You can also setup multiple bootnodes at the very beginning. However, this cannot be done by simply replaying the boot node setup steps above multiple times, because you need to set bootnodes of every boot node before they are started. One way to achieve this is to start these bootnodes and stop them immediately. Then gather their node ids, set their configuration, and restart them all. Another better way is to generate their private keys seperately, and manually set their net_key to start. This can be done with the functions provided in our python test framework in the directory test . from conflux.utils import * num_of_bootnodes=10 for _ in range(num_of_bootnodes): pri_key, pub_key = ec_random_keys() node_id = encode_hex(encode_int32(pub_key[0]) + encode_int32(pub_key[1])) print(encode_hex(pri_key), node_id) Then you can construct the bootnode url with the generated node id, and start each node by setting the net_key=\"$NET_KEY\" field to the private key or pass it with the command line option --net-key $NET_KEY .","title":"Setting Multiple Bootnodes"},{"location":"setup_independent_chain/#setting-genesis-accounts","text":"In a production environment, you can initialize the initial genesis state with your accounts by setting the genesis_accounts to an account file with formats like 0f947e34fc907008968ec99baa1dbb677b927531=\"1000000000000\" ab4a32bca7500d94a2cc1f3150e12686c692c590=\"1000000000000\" Every line is an account. The key is the account address, and the value is a string representing its balance in Drip. Note that genesis_accounts does not apply if mode is test or dev . If the mode is test or dev, you can setup the genesis accounts with their secret keys by setting genesis_secrets . Each line is an account private key without 0x-prefix. The balance of each account is set to 10000000000000000000000 by default.","title":"Setting Genesis Accounts"},{"location":"sync/","text":"Block Synchronization Process \u00b6 Synchronization Graph \u00b6 Synchronization graph is designed to organize newly arrived blocks (received from the peers, loaded from local storage, or self-mined) even when their past blocks haven\u2019t been completely collected. Once all the past blocks of a block have been collected in synchronization graph, it will be dispatched to consensus graph for further processing. The block header and block body enter the synchronization graph in separate processes, because, typically, the block header and body are transferred separately in peer-to-peer layer. The graph structure in the synchronization graph is constructed by block header arrival. Each block is represented as a node in the graph structure, and the nodes are linked through the parent/child and referrer/referee relations between blocks. Synchronization graph checks the validity of arriving blocks. The blocks that do not pass the validity checks are invalid and will not be dispatched to consensus graph further. The following validity checks are conducted: Check whether the parent or referees of a block are invalid. If one of them is invalid, the block is invalid too. Check whether the nonce in the block header is correctly set based on the difficulty in the block header, i.e., the miner of the block correctly solved the POW puzzle. Check whether the number of referees in the block header is larger than a threshold (200). If so, the block is invalid. Check whether there are duplicated hashes in the parent and referees of a block. If so, the block is invalid. Check whether the length (in byte) of the custom field in the block header is beyond a threshold (64). If so, the block is invalid. Check whether the height of a block is larger than the height of its parent block by 1. If NOT, the block is invalid. Check whether the timestamp of a block is larger than or equal to the timestamp of its parent block. If NOT, the block is invalid. Check the block gas limit is correctly set. Check the block difficulty is correctly set. Check whether the block header contains the correct transaction root according to the transactions in the block body. Check whether every transaction in the block body has valid signature structure. Check whether the total size of the transactions in the block body is larger than the block size limit (800KB). If so, the block is invalid. Check whether the total gas limit of transactions in the block body is larger than the block gas limit. If so, the block is invalid. The validity checks 1~9 only use information in block header. The validity checks 10~13 use the information in block body. The checks 6~9 require graph structure information like parent information and are conducted on a block when the headers of all its past blocks have entered the synchronization graph. To speed up the block relay process, when both the header and body of a block have entered the synchronization graph and the headers of all its past blocks have also entered, the block can be relayed to the peers. It is not needed to wait for the bodies of all the past blocks of a block to be received in order to relay the block. This may lead to relaying invalid blocks, but since all the relayed blocks already have valid difficulty and POW settings, the attackers who make this case also pay the corresponding cost of computation power. Graph Structure Maintenance \u00b6 The node structure of synchronization graph is defined as follows: pub struct SynchronizationGraphNode { pub block_header: Arc<BlockHeader>, // The status of graph connectivity in the current block view. pub graph_status: u8, // Whether the block body is ready. pub block_ready: bool, // Whether parent is in old era and already reclaimed pub parent_reclaimed: bool, // The index of the parent of the block. pub parent: usize, // The indices of the children of the block. pub children: Vec<usize>, // The indices of the blocks referenced by the block. pub referees: Vec<usize>, // The number of blocks referenced by the block but // haven't been inserted in synchronization graph. pub pending_referee_count: usize, // The indices of the blocks referencing the block. pub referrers: Vec<usize>, // the timestamp in seconds when graph_status updated pub last_update_timestamp: u64, } The graph structure is maintained by the fields parent , children , referees , and referrers . Each node has a graph_status field representing its status changing during the period from the time when the header arrives to the time when the block is ready to be dispatched to consensus graph. When a block header enters synchronization graph, it is first checked whether this block is already processed by synchronization graph. If not, it will be added into the graph and the graph structure will be updated accordingly. First, the parent/children edge will be established. If the parent of this newly arrived block hasn\u2019t come into synchronization graph, the graph uses a collection children_by_hash to handle this. This is a map from block hash to a set of graph nodes. In this case, the graph node representing this newly arrived block header will be added into the graph node set mapped from the parent block hash of this block. This functions as a bookkeeping to remember the relation between the parent block hash and this newly arrived block. Once this parent block comes into the synchronization graph in the future, the corresponding edge between the parent and child nodes can be established and the hash of the parent block will be removed from the children_by_hash map. Secondly, the referees/referrers edges will also be established. Similarly, the synchronization graph uses a map referrers_by_hash to remember the relation between the unarrived referee block and the newly arrived referrer block. The graph node also maintains a pending_referee_count field to remember how many referees of the block haven\u2019t come into the synchronization graph. A graph node may be in the following 5 status: // This block is an invalid block. const BLOCK_INVALID: u8 = 0; // Just get the header of the block. const BLOCK_HEADER_ONLY: u8 = 1; // The headers of all the blocks on the path from genesis to this block have // already entered synchronization graph. const BLOCK_HEADER_PARENTAL_TREE_READY: u8 = 2; // The headers of all the blocks in the past set of this block have already entered // synchronization graph. const BLOCK_HEADER_GRAPH_READY: u8 = 3; // Both the headers and bodies of all the blocks in the past set of this block have // entered synchronization graph. const BLOCK_GRAPH_READY: u8 = 4; When a block header just enters the synchronization graph and triggers a new graph node being created and added in the graph, the initial status of the node is BLOCK_HEADER_ONLY . And according to this graph structure update, the status of other nodes in the graph may also change. The effects of these changes are fulfilled by conducting a BFS traversal from the node to all its descendants. During this traversal process, for each node, 1) if it is invalid, all its descendants are invalid; 2) if it is new to be BLOCK_HEADER_GRAPH_READY , some graph-related validity checks (6~9) are applied on it. If it passes these checks, it is then checked whether its block body has already entered synchronization graph (by checking the block_ready field of the graph node). If so, this block is ready to be relayed. And this block may make some of its descendants become BLOCK_HEADER_PARENTAL_TREE_READY or BLOCK_HEADER_GRAPH_READY . Note that this cannot make its descendants become BLOCK_GRAPH_READY since the original node (at the starting point of the BFS process) for the newly arrived block header can only be BLOCK_HEADER_GRAPH_READY ; 3) if it is new to be BLOCK_HEADER_PARENTAL_TREE_READY , it may make some of its descendants (following the child edge) become BLOCK_HEADER_PARENTAL_TREE_READY . When a block body just enters the synchronization graph, the corresponding graph node should already exist in synchronization graph, otherwise, the block will be ignored (this may happen if it is garbage collected). The block_ready field of this node will be set as true now. The block then goes through the corresponding validity checks (10~13). And similarly, this newly arrived block body will change the status of some of its descendants. This is also done by conducting a BFS traversal from this node. During this traversal process, for each node, 1) if it is invalid, all its descendants are invalid; 2) if it is new to be BLOCK_GRAPH_READY , it is dispatched to consensus graph. It may make some of its descendants become BLOCK_GRAPH_READY . If the block with the newly arrived body is at least BLOCK_HEADER_GRAPH_READY , it becomes ready to be relayed. Garbage Collect Dangling Blocks \u00b6 Some (adversarial) nodes may send to a full node some blocks that cannot be in status of BLOCK_GRAPH_READY forever, e.g., to conduct DDOS attack or to be in the case of serious message delay so that the block does not belong to the current checkpoint era anymore. These blocks will be held in synchronization graph but should be garbage-collected eventually to avoid wasting memory resources. In order to do this, the synchronization graph maintains a set of blocks representing the frontier of these graph-unready blocks. A block should be a frontier block if 1) the block is not in status of BLOCK_GRAPH_READY but its parent block is; or 2) its parent block has not come into the synchronization graph. To garbage collect these graph-unready blocks, it starts from the frontier of these blocks, and removes them and all their descendants that can be reached through BFS traversal by following children and referrers edges. The reason that we must remove all the descendants of the frontier blocks from the synchronization graph is related to the design of block synchronization process. During the block synchronization, it follows the parent and referees edges of a newly arrived block and tries to fetch the missing ancestors. When it encounters such an ancestor block that already exists in synchronization graph, the process stops following its parent and referees edges further. Therefore, if the ancestor block is the descendant block of some frontier graph-unready block that has already been garbage collected, this removed unready block will never get chance to be fetched from peer again. However, this removed frontier block may be graph-unready merely because a temporary bad network situation which may recover later. This garbage collection process is triggered periodically, and in each of this process, it only tries to remove frontier blocks and their descendants which have already been in unready status for a long time. In order to get the timing information, each graph node has a field last_update_timestamp to remember the timestamp of the last update of the node status. One optimization in the synchronization process is that it does not always fetch from peers the parent and referees of newly arrived block that are missing in memory. It checks whether the height of the block is far less than the height of the local best epoch block. If so, it is highly probable that the ancestors of this block exist in local database, so it deserves the effort of trying to get these blocks from local database first. It is also an effective way to avoid unnecessary backward tree-graph traversing merely according to the peer information, which we also cover a bit more detail in Recovery Process section.","title":"Sync"},{"location":"sync/#block-synchronization-process","text":"","title":"Block Synchronization Process"},{"location":"sync/#synchronization-graph","text":"Synchronization graph is designed to organize newly arrived blocks (received from the peers, loaded from local storage, or self-mined) even when their past blocks haven\u2019t been completely collected. Once all the past blocks of a block have been collected in synchronization graph, it will be dispatched to consensus graph for further processing. The block header and block body enter the synchronization graph in separate processes, because, typically, the block header and body are transferred separately in peer-to-peer layer. The graph structure in the synchronization graph is constructed by block header arrival. Each block is represented as a node in the graph structure, and the nodes are linked through the parent/child and referrer/referee relations between blocks. Synchronization graph checks the validity of arriving blocks. The blocks that do not pass the validity checks are invalid and will not be dispatched to consensus graph further. The following validity checks are conducted: Check whether the parent or referees of a block are invalid. If one of them is invalid, the block is invalid too. Check whether the nonce in the block header is correctly set based on the difficulty in the block header, i.e., the miner of the block correctly solved the POW puzzle. Check whether the number of referees in the block header is larger than a threshold (200). If so, the block is invalid. Check whether there are duplicated hashes in the parent and referees of a block. If so, the block is invalid. Check whether the length (in byte) of the custom field in the block header is beyond a threshold (64). If so, the block is invalid. Check whether the height of a block is larger than the height of its parent block by 1. If NOT, the block is invalid. Check whether the timestamp of a block is larger than or equal to the timestamp of its parent block. If NOT, the block is invalid. Check the block gas limit is correctly set. Check the block difficulty is correctly set. Check whether the block header contains the correct transaction root according to the transactions in the block body. Check whether every transaction in the block body has valid signature structure. Check whether the total size of the transactions in the block body is larger than the block size limit (800KB). If so, the block is invalid. Check whether the total gas limit of transactions in the block body is larger than the block gas limit. If so, the block is invalid. The validity checks 1~9 only use information in block header. The validity checks 10~13 use the information in block body. The checks 6~9 require graph structure information like parent information and are conducted on a block when the headers of all its past blocks have entered the synchronization graph. To speed up the block relay process, when both the header and body of a block have entered the synchronization graph and the headers of all its past blocks have also entered, the block can be relayed to the peers. It is not needed to wait for the bodies of all the past blocks of a block to be received in order to relay the block. This may lead to relaying invalid blocks, but since all the relayed blocks already have valid difficulty and POW settings, the attackers who make this case also pay the corresponding cost of computation power.","title":"Synchronization Graph"},{"location":"sync/#graph-structure-maintenance","text":"The node structure of synchronization graph is defined as follows: pub struct SynchronizationGraphNode { pub block_header: Arc<BlockHeader>, // The status of graph connectivity in the current block view. pub graph_status: u8, // Whether the block body is ready. pub block_ready: bool, // Whether parent is in old era and already reclaimed pub parent_reclaimed: bool, // The index of the parent of the block. pub parent: usize, // The indices of the children of the block. pub children: Vec<usize>, // The indices of the blocks referenced by the block. pub referees: Vec<usize>, // The number of blocks referenced by the block but // haven't been inserted in synchronization graph. pub pending_referee_count: usize, // The indices of the blocks referencing the block. pub referrers: Vec<usize>, // the timestamp in seconds when graph_status updated pub last_update_timestamp: u64, } The graph structure is maintained by the fields parent , children , referees , and referrers . Each node has a graph_status field representing its status changing during the period from the time when the header arrives to the time when the block is ready to be dispatched to consensus graph. When a block header enters synchronization graph, it is first checked whether this block is already processed by synchronization graph. If not, it will be added into the graph and the graph structure will be updated accordingly. First, the parent/children edge will be established. If the parent of this newly arrived block hasn\u2019t come into synchronization graph, the graph uses a collection children_by_hash to handle this. This is a map from block hash to a set of graph nodes. In this case, the graph node representing this newly arrived block header will be added into the graph node set mapped from the parent block hash of this block. This functions as a bookkeeping to remember the relation between the parent block hash and this newly arrived block. Once this parent block comes into the synchronization graph in the future, the corresponding edge between the parent and child nodes can be established and the hash of the parent block will be removed from the children_by_hash map. Secondly, the referees/referrers edges will also be established. Similarly, the synchronization graph uses a map referrers_by_hash to remember the relation between the unarrived referee block and the newly arrived referrer block. The graph node also maintains a pending_referee_count field to remember how many referees of the block haven\u2019t come into the synchronization graph. A graph node may be in the following 5 status: // This block is an invalid block. const BLOCK_INVALID: u8 = 0; // Just get the header of the block. const BLOCK_HEADER_ONLY: u8 = 1; // The headers of all the blocks on the path from genesis to this block have // already entered synchronization graph. const BLOCK_HEADER_PARENTAL_TREE_READY: u8 = 2; // The headers of all the blocks in the past set of this block have already entered // synchronization graph. const BLOCK_HEADER_GRAPH_READY: u8 = 3; // Both the headers and bodies of all the blocks in the past set of this block have // entered synchronization graph. const BLOCK_GRAPH_READY: u8 = 4; When a block header just enters the synchronization graph and triggers a new graph node being created and added in the graph, the initial status of the node is BLOCK_HEADER_ONLY . And according to this graph structure update, the status of other nodes in the graph may also change. The effects of these changes are fulfilled by conducting a BFS traversal from the node to all its descendants. During this traversal process, for each node, 1) if it is invalid, all its descendants are invalid; 2) if it is new to be BLOCK_HEADER_GRAPH_READY , some graph-related validity checks (6~9) are applied on it. If it passes these checks, it is then checked whether its block body has already entered synchronization graph (by checking the block_ready field of the graph node). If so, this block is ready to be relayed. And this block may make some of its descendants become BLOCK_HEADER_PARENTAL_TREE_READY or BLOCK_HEADER_GRAPH_READY . Note that this cannot make its descendants become BLOCK_GRAPH_READY since the original node (at the starting point of the BFS process) for the newly arrived block header can only be BLOCK_HEADER_GRAPH_READY ; 3) if it is new to be BLOCK_HEADER_PARENTAL_TREE_READY , it may make some of its descendants (following the child edge) become BLOCK_HEADER_PARENTAL_TREE_READY . When a block body just enters the synchronization graph, the corresponding graph node should already exist in synchronization graph, otherwise, the block will be ignored (this may happen if it is garbage collected). The block_ready field of this node will be set as true now. The block then goes through the corresponding validity checks (10~13). And similarly, this newly arrived block body will change the status of some of its descendants. This is also done by conducting a BFS traversal from this node. During this traversal process, for each node, 1) if it is invalid, all its descendants are invalid; 2) if it is new to be BLOCK_GRAPH_READY , it is dispatched to consensus graph. It may make some of its descendants become BLOCK_GRAPH_READY . If the block with the newly arrived body is at least BLOCK_HEADER_GRAPH_READY , it becomes ready to be relayed.","title":"Graph Structure Maintenance"},{"location":"sync/#garbage-collect-dangling-blocks","text":"Some (adversarial) nodes may send to a full node some blocks that cannot be in status of BLOCK_GRAPH_READY forever, e.g., to conduct DDOS attack or to be in the case of serious message delay so that the block does not belong to the current checkpoint era anymore. These blocks will be held in synchronization graph but should be garbage-collected eventually to avoid wasting memory resources. In order to do this, the synchronization graph maintains a set of blocks representing the frontier of these graph-unready blocks. A block should be a frontier block if 1) the block is not in status of BLOCK_GRAPH_READY but its parent block is; or 2) its parent block has not come into the synchronization graph. To garbage collect these graph-unready blocks, it starts from the frontier of these blocks, and removes them and all their descendants that can be reached through BFS traversal by following children and referrers edges. The reason that we must remove all the descendants of the frontier blocks from the synchronization graph is related to the design of block synchronization process. During the block synchronization, it follows the parent and referees edges of a newly arrived block and tries to fetch the missing ancestors. When it encounters such an ancestor block that already exists in synchronization graph, the process stops following its parent and referees edges further. Therefore, if the ancestor block is the descendant block of some frontier graph-unready block that has already been garbage collected, this removed unready block will never get chance to be fetched from peer again. However, this removed frontier block may be graph-unready merely because a temporary bad network situation which may recover later. This garbage collection process is triggered periodically, and in each of this process, it only tries to remove frontier blocks and their descendants which have already been in unready status for a long time. In order to get the timing information, each graph node has a field last_update_timestamp to remember the timestamp of the last update of the node status. One optimization in the synchronization process is that it does not always fetch from peers the parent and referees of newly arrived block that are missing in memory. It checks whether the height of the block is far less than the height of the local best epoch block. If so, it is highly probable that the ancestors of this block exist in local database, so it deserves the effort of trying to get these blocks from local database first. It is also an effective way to avoid unnecessary backward tree-graph traversing merely according to the peer information, which we also cover a bit more detail in Recovery Process section.","title":"Garbage Collect Dangling Blocks"},{"location":"test_framework/","text":"Test Framework \u00b6 The framework is written in python3 . It can setup multiple Conflux nodes and test the distributed system behavior locally. It controls the nodes behavior by setting the node configurations, calling their RPCs, or sending them P2P messages directly. All related files are included in the directory tests . After compiling the source code with cargo build --release under the project directory, you can run tests/test_all.py to run all included python tests. An Example Test \u00b6 Here is an example test. It setups 2 nodes, makes each node generate some blocks separately, and finally connects them to check if they can receive the blocks generated by the other. from test_framework.test_framework import ConfluxTestFramework from test_framework.util import * class ExampleTest(ConfluxTestFramework): def set_test_params(self): self.setup_clean_chain = True self.num_nodes = 2 def setup_network(self): self.setup_nodes() # connect_sample_nodes(self.nodes, self.log) def run_test(self): self.nodes[0].generate(1, 0) assert (self.nodes[0].getblockcount() == 2) self.nodes[1].generate(2, 0) assert (self.nodes[1].getblockcount() == 3) connect_nodes(self.nodes, 0, 1) sync_blocks(self.nodes) assert (self.nodes[0].getblockcount() == 4) self.log.info(\"PASS\") if __name__ == '__main__': ExampleTest().main() The framework will Call set_test_params to set basic test initialization parameters. Setup the test directories and node configurations according to the parameters set in set_test_params . By default, a temp directory will be created and all files will be kept within it. For example, setting self.num_nodes = 2 will initialize directories for two nodes. Call setup_network to add nodes and connect them. Here self.setup_nodes() will add 2 Conflux nodes by running pre-compiled Conflux executable binary within the directory setupped in step 2. We do not connect them here because we want nodes seperated at the beginning. Call run_test to run the actual test codes. After running self.setup_nodes() , self.nodes is a list of TestNode , and each can be used to interact with the corresponding Conflux node. For example, to get the number of blocks in node 0 by calling the RPC named getblockcount , you simply call self.nodes[0].getblockcount and an integer will be returned. connect_nodes(self.nodes, 0, 1) connects nodes 0 and 1. sync_blocks(self.nodes) waits until all nodes have the same pivot chain tip. Them are both implemented by calling RPCs, and more useful functions will be introduced in [Utility Function List][#utility-function-list]. Sending P2P Messages \u00b6 After calling start_p2p_connection(self.nodes) , the field p2p of each TestNode will be initialized with a simulated Conflux node written in Python, and this simulated node will be connected to the Conflux process controled by the corresponding TestNode . After that, you can send and receive P2P messages within python code. Here is an example about how to use p2p to interact with the Conflux node. def run_test(self): def assert_length(_node, msg): assert_equal(len(msg.headers), 1) h = WaitHandler(self.nodes[0].p2p, GET_BLOCK_HEADERS_RESPONSE, assert_length) self.nodes[0].p2p.send_protocol_msg(GetBlockHeaders(hashes=[self.nodes[0].p2p.genesis.hash])) h.wait() This example tries to get the genesis block header from node 0 with P2P requests (instead of using RPC), and asserts that only one header is returned. WaitHandler will wait for the first message of the designated message type and run a function on this received message. p2p.send_protocol_msg is used to send a rlp-encodable message. h.wait() waits and handles the first received GET_BLOCK_HEADERS_RESPONSE message. Note that WaitHandler starts listening right after it's initialized. Configurations \u00b6 By default, tests will use the release version executable binary built by cargo . If you want to use a file at another path (e.g., a debug version binary), you can set the environment variable CONFLUX to the full path of the used binary file before running the tests. TODO Utility Function List \u00b6 TODO Introduction to Existing Python Tests \u00b6 TODO","title":"Test framework"},{"location":"test_framework/#test-framework","text":"The framework is written in python3 . It can setup multiple Conflux nodes and test the distributed system behavior locally. It controls the nodes behavior by setting the node configurations, calling their RPCs, or sending them P2P messages directly. All related files are included in the directory tests . After compiling the source code with cargo build --release under the project directory, you can run tests/test_all.py to run all included python tests.","title":"Test Framework"},{"location":"test_framework/#an-example-test","text":"Here is an example test. It setups 2 nodes, makes each node generate some blocks separately, and finally connects them to check if they can receive the blocks generated by the other. from test_framework.test_framework import ConfluxTestFramework from test_framework.util import * class ExampleTest(ConfluxTestFramework): def set_test_params(self): self.setup_clean_chain = True self.num_nodes = 2 def setup_network(self): self.setup_nodes() # connect_sample_nodes(self.nodes, self.log) def run_test(self): self.nodes[0].generate(1, 0) assert (self.nodes[0].getblockcount() == 2) self.nodes[1].generate(2, 0) assert (self.nodes[1].getblockcount() == 3) connect_nodes(self.nodes, 0, 1) sync_blocks(self.nodes) assert (self.nodes[0].getblockcount() == 4) self.log.info(\"PASS\") if __name__ == '__main__': ExampleTest().main() The framework will Call set_test_params to set basic test initialization parameters. Setup the test directories and node configurations according to the parameters set in set_test_params . By default, a temp directory will be created and all files will be kept within it. For example, setting self.num_nodes = 2 will initialize directories for two nodes. Call setup_network to add nodes and connect them. Here self.setup_nodes() will add 2 Conflux nodes by running pre-compiled Conflux executable binary within the directory setupped in step 2. We do not connect them here because we want nodes seperated at the beginning. Call run_test to run the actual test codes. After running self.setup_nodes() , self.nodes is a list of TestNode , and each can be used to interact with the corresponding Conflux node. For example, to get the number of blocks in node 0 by calling the RPC named getblockcount , you simply call self.nodes[0].getblockcount and an integer will be returned. connect_nodes(self.nodes, 0, 1) connects nodes 0 and 1. sync_blocks(self.nodes) waits until all nodes have the same pivot chain tip. Them are both implemented by calling RPCs, and more useful functions will be introduced in [Utility Function List][#utility-function-list].","title":"An Example Test"},{"location":"test_framework/#sending-p2p-messages","text":"After calling start_p2p_connection(self.nodes) , the field p2p of each TestNode will be initialized with a simulated Conflux node written in Python, and this simulated node will be connected to the Conflux process controled by the corresponding TestNode . After that, you can send and receive P2P messages within python code. Here is an example about how to use p2p to interact with the Conflux node. def run_test(self): def assert_length(_node, msg): assert_equal(len(msg.headers), 1) h = WaitHandler(self.nodes[0].p2p, GET_BLOCK_HEADERS_RESPONSE, assert_length) self.nodes[0].p2p.send_protocol_msg(GetBlockHeaders(hashes=[self.nodes[0].p2p.genesis.hash])) h.wait() This example tries to get the genesis block header from node 0 with P2P requests (instead of using RPC), and asserts that only one header is returned. WaitHandler will wait for the first message of the designated message type and run a function on this received message. p2p.send_protocol_msg is used to send a rlp-encodable message. h.wait() waits and handles the first received GET_BLOCK_HEADERS_RESPONSE message. Note that WaitHandler starts listening right after it's initialized.","title":"Sending P2P Messages"},{"location":"test_framework/#configurations","text":"By default, tests will use the release version executable binary built by cargo . If you want to use a file at another path (e.g., a debug version binary), you can set the environment variable CONFLUX to the full path of the used binary file before running the tests. TODO","title":"Configurations"},{"location":"test_framework/#utility-function-list","text":"TODO","title":"Utility Function List"},{"location":"test_framework/#introduction-to-existing-python-tests","text":"TODO","title":"Introduction to Existing Python Tests"},{"location":"trans/","text":"","title":"Trans"}]}